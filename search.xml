<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Unity Shader 入门精要</title>
    <url>/BookNote/Unity_Shader_Book/</url>
    <content><![CDATA[<h1 id="Unity-Shader-入门精要"><a href="#Unity-Shader-入门精要" class="headerlink" title="Unity Shader 入门精要"></a>Unity Shader 入门精要</h1><h2 id="2-渲染管线"><a href="#2-渲染管线" class="headerlink" title="2. 渲染管线"></a>2. 渲染管线</h2><ul>
<li><p>应用阶段  </p>
<ol>
<li>把数据(顶点的位悝信息、 法线方向、 顶点颜色、 纹理坐标)加载到显存中。</li>
<li>设置渲染状态(使用哪个顶点着色器/片元着色器、 光源属性、材质等)。</li>
<li>调用 Draw Call(一个渲染命令来告诉GPU开始渲染)</li>
</ol>
</li>
<li><p>几何阶段  </p>
</li>
<li>光栅化阶段  </li>
<li>逐片元操作(片元并不是真正意义上的像素 而是包含了很多状态的集合 包括屏幕坐标 深度信息，以及其他从几何阶段输出的顶点信息 例如法线、纹理坐标等)  </li>
</ul>
<hr>
<ul>
<li><p>双重缓冲<br>对场景的渲染是在幕后发生的后置缓冲中。 一旦场景已经被渲染到了后置缓冲中， GPU 就会交换后置缓冲区和前置缓冲，前置缓冲区是之前显示在屏幕上的图像。保证看到的图像总是连续的  </p>
</li>
<li><p>OpenGL/DirectX<br>图像应用编程接口<br>应用程序运行在 CPU 上通过调用 OpenGL DirectX 的图形接口将渲染所需的数据，如顶点数据、纹理数据、材质参数等数据存储在显存中的特定区域 随后，开发者可以通过图像编程接口发出渲染命令(Draw Call), 它们将会被显卡驱动翻译成 GPU 够理解的代码，进行真正的绘制。<br><img src="/BookNote/Unity_Shader_Book/1.png" alt="1">  </p>
</li>
<li><p>命令缓冲区<br>包含命令队列 CPU 向其中添加命令 而由 GPU 从中读取命令，添加和读取的过程是互相独立的 命令缓冲区使得 CPU GPU 可以相互独立工作  </p>
</li>
<li><p>批处理<br>  GPU渲染速度往往快于 CPU 提交命令的速度 Draw Call 的数量太多， CPU 就会把大量时间花费在提交 Draw Call 上，造成 CPU 的过载<br>  把很多小的 DrawCall 合并成一个大DrawCall 更加适合于那些静态的物体 只需要合并一次即可 动态物体每一帧都需要重新进行合并然后再发送给 GPU<br>  使用批处理合并的网格将会使用同一种渲染状态  </p>
<p>  减少DrawCall开销:<br>  避免使用大量很小的网格<br>  避免使用过多的材质  </p>
</li>
<li><p>Shader<br>GPU 流水线上一些可高度编程的阶段 可以控制流水线中的渲染细节  </p>
</li>
</ul>
<h2 id="4-数学基础"><a href="#4-数学基础" class="headerlink" title="4.数学基础"></a>4.数学基础</h2><p>矩阵变换顺序 缩放旋转平移  </p>
<p>模型变换 将顶点坐标从模型空间变换到世界空间中  </p>
<p>法线变换 逆转置矩阵  </p>
<h2 id="7-纹理"><a href="#7-纹理" class="headerlink" title="7.纹理"></a>7.纹理</h2><ul>
<li><p>模型空间的法线纹理<br>更加直观 记录的是绝对法线信息<br>可以提供平滑的边界  </p>
</li>
<li><p>切线空间的法线纹理<br>自由度很高 相对法线信息 可以重用法线纹理<br>可进行 UV 动画<br>可压缩 仅存储XY 方向，而推导得到Z方向  </p>
</li>
<li><p>计算光照模型</p>
<ol>
<li>在切线空间下进行光照计算，把光照方向、视角方向变换到切线空间下；  </li>
<li>在世界空间下进行光照计算，把采样得到的法线方向变换到世界空间下，  </li>
</ol>
</li>
</ul>
<h2 id="8-透明"><a href="#8-透明" class="headerlink" title="8.透明"></a>8.透明</h2><ol>
<li>先渲染所有不透明物体，并开启它们的深度测试和深度写入 可从近到远渲染(优化)</li>
<li>再渲染全透明物, 使用透明度测试</li>
<li>把半透明物体按它们距离摄像机的远近进行排序，然后按照从后往前的顺序渲染这些半透明物体，并开启它们的深度测试，但关闭深度写入。</li>
<li>循环覆盖分割网格解决</li>
</ol>
<p>关闭背面剔除<br>两个pass</p>
]]></content>
      <categories>
        <category>BookNote</category>
      </categories>
  </entry>
  <entry>
    <title>Cherno</title>
    <url>/CPlusPlus/Cherno/</url>
    <content><![CDATA[<h1 id="Cherno"><a href="#Cherno" class="headerlink" title="Cherno"></a>Cherno</h1><p><a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb">TheCherno原视频</a><br>防御式声明防御在同一个cpp里重复引用.h。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _CONST_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _CONST_</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//另一种简单常用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br></pre></td></tr></table></figure></p>
<p>多个相同的定义linker报错<br>在头文件里定义了函数体并被多个cpp重复引用:</p>
<ol>
<li>对.h里的文件的函数体前增加static(仅自己cpp使用)或inline(将函数体直接套入主函数)</li>
<li>把函数体放到一个cpp文件中, .h头文件里只声明</li>
</ol>
<p>无论什么类型的指针本质都是存储内存地址的整数<br>指针类型只是在读取或修改数据时告诉编译器数据的类型(占多大的内存)  </p>
<p>new底层其实是call了malloc，malloc是memory allocation的简写，它负责分配内存，delete则调用了free()，区别是new和delete不仅管理内存，还会调用constructor和destructor，另外它们都是operator，可以重载。<br>new【】和delete【】其实另两个operator，它们做的事情稍微有点不一样，你调用new【】的时候，必须要指定一个size，但调用delete【】的时候，并没有指定size，这是因为new【】不仅分配了所需要的内存，还会多分配一个额外的空间，来存储这个size，所以<code>char* buffer = new char[8];</code>，它所做的是分配这样一块内存【8, 0, 0, 0, 0, 0, 0, 0, 0】，连续的，但是多一块在最前面，但是return给你的是跳过那块内存的地址，比如malloc返回的是0x1，但new【】给你返回的是0x1+2（我记得它分配的是一个word（一般是short）的大小，具体大小需要看系统），然后在<code>delete[] buffer;</code>的时候，它会往前推一个word，因为它知道前面一个word肯定是size，从而拿到size，进而delete所有  </p>
<p><code>memset(buffer,0,8)</code> 将buffer所指的首地址后八个字节都填0</p>
<p><code>int&amp; ref = a;</code>引用即别名：引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。引用定义的同时必须赋值 并且赋值后不能改变引用对象<br>函数传值和传引用(只要在函数定义的形参前加&amp;)  引用能做的指针都能做  </p>
<p>C++中struct和class的用法作用相同 不过struct默认成员都为public class默认为private(struct中也可定义方法)  </p>
<p>类或结构体外的static表示只对它声明所在的cpp文件中“可见” extern表示要在别的cpp文件中寻找定义<br>类或结构体内的static共享空间，可看作在类或结构体的命名空间中 <code>Class::element</code> 静态成员函数中不能调用非静态成员 静态成员函数没有 this 指针<br>静态成员变量使用前必须先初始化(如 int MyClass::m_nNumber = 0;)，否则会在 linker 时出错  </p>
<p>virtual会创建虚表，虚表中类似存储函数指针，不同类初始化时，保存的函数指针不同，因此不同实例的基类指针，访问虚函数时，其获取的函数指针不同，完成重载  </p>
<p><code>virtual std::string GetName() = 0;</code> 纯虚函数 包含pure vertual function的类我们无法实例化 一定需要子类提供所有纯虚函数的实现子类才能实例化 (接口)  </p>
<p>父类中的protected的作用是让子类可以访问父类中的private成员  </p>
<p>函数中要返回数组(数组在函数中创建的)需要用new来分配除非传入的是数组的地址参数 <code>int arr[5];</code>储存在栈中 <code>int* arr = new int[5];</code>储存在堆中(不能用sizeof求大小)  </p>
<p>字符串字面量 只读常量  </p>
<p><code>const Entity&amp;</code> 相当于常量指针常量，指向的内容和本身都不能修改 常对象只能调用常成员函数，而不能调用其他的成员函数 所以调用的函数要加const<code>int GetX const()&#123;&#125;</code>表示不能修改实际的类成员  </p>
<p>mutable 对于const的常函数中需要更改类的成员数据时(Debug) 定义时加上<code>mutable int m_DebugCount;</code>就可在常函数里修改<code>m_DebugCount</code> Lambda表达式中可用(?)  </p>
<p>尽量使用成员初始化列表 初始化const成员变量只能用初始化列表实现，因为不能赋值  </p>
<p>构造函数前加explicit则不能用隐式转换  </p>
<ul>
<li>智能指针<br>  智能指针本质就是一个类模板 对象会自动调用析构函数去释放该指针所指向的空间 不需要new和delete<br>  unique_ptr 不能进行拷贝和赋值 <code>std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();</code><br>  shared_ptr 允许多个智能指针可以指向同一块资源 维护着一份引用计数 计数为0则释放    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	std::shared_ptr&lt;Entity&gt; entity1;</span><br><span class="line">	&#123;</span><br><span class="line">		std::shared_ptr&lt;Entity&gt; entity2 = std::<span class="built_in">make_shared</span>&lt;Entity&gt;();</span><br><span class="line">		entity1 = entity2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  weak_ptr  通常情况下需要跟 shared_ptr 一起使用 构造和析构时引用计数不增加也不会减少 专门用来解决两个类中shared_ptr相互引用而导致的内存泄露问题  </li>
</ul>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，深拷贝和浅拷贝的区别是在对象状态中包含其它对象的引用的时候，当拷贝一个对象时，如果需要拷贝这个对象引用的对象，则是深拷贝，否则是浅拷贝。未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，对有引用的对象浅拷贝会释放同一块内存两次,导致程序崩溃。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深拷贝构造函数</span></span><br><span class="line"><span class="built_in">String</span>(<span class="type">const</span> String&amp; other)</span><br><span class="line">    :<span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">&#123;</span><br><span class="line">    m_String = <span class="keyword">new</span> <span class="type">char</span>[m_Size+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_String,other.m_String,m_Size+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">String</span>()&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总是通过const引用来传递对象  </p>
<ul>
<li><p>Vector</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">float</span> m_X, m_Y, m_Z;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> z) :<span class="built_in">m_X</span>(x), <span class="built_in">m_Y</span>(y), <span class="built_in">m_Z</span>(z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Vertex</span>(<span class="type">const</span> Vertex&amp; vertex) :<span class="built_in">m_X</span>(vertex.m_X), <span class="built_in">m_Y</span>(vertex.m_Y), <span class="built_in">m_Z</span>(vertex.m_Z) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">	vertices.<span class="built_in">push_back</span>(<span class="built_in">Vertex</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到六次输出 说明有六次复制</span></span><br></pre></td></tr></table></figure>
<p>  分别为 在main的栈中构造临时变量vertex然后调用拷贝复制到vector的栈中1+1+1 以及 vector每次输入后扩展空间要把原来的数据复制到新的内存空间中1+2<br>  优化:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;Vertex&gt; vertices;</span><br><span class="line">	vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);</span><br><span class="line">	vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	vertices.<span class="built_in">emplace_back</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">	vertices.<span class="built_in">emplace_back</span>(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无输出</span></span><br></pre></td></tr></table></figure>
<p>  reserve提前预定好vector的空间不用扩展 emplace_back则是传递参数化列表直接在vector中构建vertex  </p>
</li>
</ul>
<ul>
<li><p>库文件<br>  include中的.h文件 lib文件夹中的.lib .dll dll.lib<br>  静态链接<br>  gcc进行链接时会把静态库.lib中的代码打包到可执行文件中，<strong>编译时加载</strong>，所以在发布程序的时候无须提供静态库，移植方便，运行快<br>  属性-&gt;C++-&gt;常规-&gt;附加包含目录 填include文件夹路径<code>$(SolutionDir)Dependencies\include</code> 即可在程序中include&lt;.h&gt;<br>  属性-&gt;链接器-&gt;常规-&gt;附加库目录 填lib文件夹路径<code>$(SolutionDir)Dependencies\lib</code> 属性-&gt;链接器-&gt;输入-&gt;附加依赖项中填.lib文件名 即可引入库文件<br>  动态链接<br>  gcc进行链接时，动态库的代码不会被打包到可执行程序中，<strong>运行时加载</strong>，所以在发布程序的时候需要提供动态库<br>  include同上<br>  链接器输入中附加依赖项改为dll.lib(指向文件) 同时将dll文件放在和exe文件同一目录当中即可  </p>
<p>  同一个Solution中自定义库 对project的属性调成lib include路径改为自己创建的.h的路径 对主项目添加引用选择库项目即可(静态)  </p>
</li>
</ul>
<p>模板函数只有在被调用时才会被创建  </p>
<p>栈分配比堆分配更好 要很大的存储空间或者要持续很长作用域的才用堆分配  </p>
<p>函数指针<code>typedef void(*Function)(int);</code> <code>Function func = Helloworld//函数名;</code> 每一个函数名都是一个函数指针，函数名后加（）就是调用该函数  </p>
<p>lambda 更多看为一个变量而不是一个函数 有函数指针的地方可以用 <code>auto lambda = [](//参数)&#123;//函数主体&#125;;</code><br><code>[外层变量传入](参数变量传入) -&gt; 返回类型 &#123; 函数体 &#125; //(-&gt; 返回变量可以不写，因为很容易从return推断)</code><br>例子：<code>[](int value)&#123; std::cout &lt;&lt; &quot;value : &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;</code><br>[]用于捕获 要用到函数体外定义的变量时 [=]所有变量按值传递 [&amp;]所有变量按引用传递 [a]a按值传递 [&amp;a]a变量按引用传递<br>非捕获lambda可以隐式转换为函数指针，而有捕获lambda不可以。所以非捕获lambda可以作为原始函数指针<code>void(*func)(int)</code>的参数 捕获的参数要为<code>const std::function&lt;void(int)&gt;&amp; func</code>  </p>
<ul>
<li><p>计时  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;<span class="comment">//可以使用s,h,min等时间后缀</span></span><br><span class="line"><span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();<span class="comment">//记录时间</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);<span class="comment">//停1秒</span></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">std::chrono::duration&lt;<span class="type">float</span>&gt; duration = end - start;</span><br><span class="line">std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span> &#123;<span class="comment">//计时类 将类放在作用域中Timer timer;即可</span></span><br><span class="line">	std::chrono::time_point&lt;std::chrono::steady_clock&gt; start, end;</span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Timer</span>() &#123;</span><br><span class="line">		start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Timer</span>() &#123;</span><br><span class="line">		end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">		duration = end - start;</span><br><span class="line">		<span class="comment">//startTime = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(start).time_since_epoch().count();显式类型转换 不损失精度 以微秒输出</span></span><br><span class="line">		<span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">		std::cout &lt;&lt; ms &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Timer</span>(<span class="type">const</span> <span class="type">char</span>* name) : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Stopped</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">		m_StartTimepoint = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> endTimepoint = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::milliseconds&gt;(m_StartTimepoint).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::milliseconds&gt;(endTimepoint).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line">		std::cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; (end - start) &lt;&lt; <span class="string">&quot;ms\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">		m_Stopped = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Timer</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (!m_Stopped)</span><br><span class="line">			<span class="built_in">Stop</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>* m_Name;</span><br><span class="line">	std::chrono::time_point&lt;std::chrono::steady_clock&gt; m_StartTimepoint;</span><br><span class="line">	<span class="type">bool</span> m_Stopped;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>  <a href="https://gist.github.com/TheCherno/31f135eea6ee729ab5f26a6908eb3a5e">可视化计时头文件(生成的json放入edge://tracing/)</a></p>
</li>
</ul>
<p>类型双关 用不同的类型去解释同一段内存 <code>*(float*)&amp;x//x为int</code>  </p>
<p>union里的成员会共享内存，分配的大小是按最大成员的sizeof, union中要是有两个结构体，改变其中一个另外一个里面对应的也会改变. 如果是这两个成员是结构体struct{ int a,b}和int k,如果k=2;对应a=2，b不变 union用不同的结构表示同样的数据很好用  </p>
<ul>
<li><p>虚析构函数<br>  对派生类的会先调用基类构造函数再调用派生类构造函数 析构时先调用派生类析构函数再调用基类析构函数<br>  而多态时(用基类指针来引用派生类对象)则只会调用基类的析构函数而不会调用派生类的析构函数造成内存泄漏<br>  此时要用<strong>虚析构函数</strong>告诉编译器还有派生类的析构函数需要调用 基类析构函数前加virtual (不是覆写析构函数)<br>  当需要写一个有子类的类时一定要用虚析构函数  </p>
<p>  定义基类的虚析构并不是增加，而是：基类中只要定义了虚析构(且只能在基类中定义虚析构，子类析构才是虚析构，如果在二级子类中定义虚析构，编译器不认，且virtual失效）<br>  在编译器角度来讲，那么由此基类派生出的所有子类地析构均为对基类的虚析构的重写，当多态发生时，用父类引用，引用子类实例时，此时的虚指针保存的子类虚表的地址，该函数指针数组中的第一元素永远留给虚析构函数指针。所以当delete 父类引用时，即第一个调用子类虚表中的子类重写的虚析构函数此为第一阶段。<br>  然后进入第二阶段：(二阶段纯为内存释放而触发的逐级析构与虚析构无关)而当子类发生析构时，子类内存开始释放，因内存包涵关系，触发父类析构执行，层层向上递进，至到子类所包涵的所有内存释放完成。  </p>
<p>  编译器保证在继承体系中，构造由内到外（内指基类），析构有外到内，子类析构函数结束时，会沿着继承链往上析构  </p>
</li>
<li><p>C++的强制类型转换<br>  cast 分为 static_cast  dynamic_cast reinterpret_cast const_cast 相比c方便检查<br>  static_cast 用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换,不能用于指针类型的强制转换<code>static_cast&lt;double&gt;(n)//n为int型</code><br>  reinterpret_cast  用于进行各种不同类型的指针之间强制转换 类型双关<br>  const_cast 仅用于进行去除 const 属性的转换<br>  dynamic_cast 不检查转换安全性，仅运行时检查，如果不能转换，返回null 用于检查一个对象是否为给定类型 存储rtti(运行时内存信息)  </p>
</li>
</ul>
<p>条件与操作断点  </p>
<ul>
<li><p>预编译头文件<br>  C++ 编译器是单独、分别对每个cpp文件进行预编译（也就是对#include，#define 等进行文本替换），生成编译单元。编译单元是一个自包含文件，C++编译器对编译单元进行编译。考虑，头文件A.h被多个cpp文件（比如A1.cpp，A2.cpp）包含，每个cpp文件都要进行单独编译，其中的A.h部分就会被多次重复的编译，造成效率低。<br>  把A.h以及类似A.h这样的头文件，包含到stdafx.h中（当然也可以是其他文件），在stdafx.cpp中包含stdafx.h，打开stdafx.cpp文件的属性对话框，将属性对话框中的”预编译头”设置为 “/Yc”即创建预编译头。对于原先包含A.h的cpp文件，删除#include “A.h”，改成包含stdafx.h，同时打开这些cpp文件（A1.cpp，A2.cpp）的属性对话框(也可打开整个项目的属性)，将属性对话框中的  “预编译头” 设置为 “/Yu”即使用预编译头。这样的话，下次编译A1.cpp，A2.cpp的时候，对于A.h头文件中的那部分，就不需要编译了，节省时间。<br>  工程对预先编译的代码进行编译，会生成一个pch文件（precompiled header），该文件包含了编译的结果。注意，可以对任何代码生成到pch中，但是生成pch是个很耗时的操作，因此，只对那些稳定的代码(比如标准模板库)创建预编译头文件。  </p>
</li>
<li><p>结构化绑定 C++17<br>  结构化绑定允许声明多个变量，可以使用数组,结构体 ,pair等中的元素来初始化<br>  返回多个值可以用元组来实现替代用结构体了  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="type">int</span>&gt; <span class="title">CreatPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="string">&quot;Cherno&quot;</span>,<span class="number">19</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span>[name, age] = <span class="built_in">CreatPerson</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理OPTIONAL数据 C++17<br>  <code>#include &lt;optional&gt;</code><br>  <code>std::optional&lt;type&gt; function(param)&#123;statement; return type;&#125;//type返回值</code><br>  <code>auto result = function(param);</code><br>  result.has_value()或直接通过if (result)判断数据是否存在<br>  通过result.value()获取数据,或<code>type&amp; res = *result;</code><br>  result.value_or(xxx)其中xxx作为默认值，如果存在数据返回数据，不存在返回xxx<br>  使用场景—目标值可能存在也可能不存在，比如读取文件并返回内容，可能读取成功有数据，读取成功无数据，读取不成功。  </p>
</li>
<li><p>单一变量存放多种类型的数据variant C++17<br>  <code>#include &lt;variant&gt;</code><br>  <code>std::variant&lt;type1, type2&gt; data;</code><br>  <code>data = type1(xxx)</code><br>  <code>data.index()</code>打印第几个类型可以看出是什么类型<br>  <code>std::get&lt;type&gt;(data)</code><br>  <code>auto value = std::get_if(type)(&amp;data)</code>如果为type则返回指向其地址的指针否则返回空指针<br>  类似于union，type1与type2表示存储的数据类型。类型安全 所占空间为存储的数据的总和<br>  存储任意类型的数据any 不用确定具体类型的variant  </p>
</li>
<li><p>多线程并发基础 <a href="https://zhuanlan.zhihu.com/p/194198073">参考</a><br>  把一个任务拆分为多个子任务，然后交由不同线程处理不同子任务,使得这多个子任务同时执行<br>  <code>#include&lt;thread&gt;</code><br>  <code>std::thread th1(proc1);</code>创建了一个名为th1的线程，并且线程th1开始执行<br>  当线程启动后，一定要在和线程相关联的std::thread对象销毁前，对线程运用join()或者detach()方法。作用为等待调用线程运行结束后当前线程再继续运行.join()与detach()都是std::thread类的成员函数，是两种线程阻塞方法，两者的区别是是否等待子线程执行结束。都只能调用一次<br>  互斥量(锁)<br>  共享数据同一时间只能给一个人用 解决数据共享过程中可能存在的访问冲突 开始使用时lock则其他线程只能等待lock 使用完后unlock<br>  死锁 多个线程争夺共享资源导致每个线程都不能取得自己所需的全部资源，程序无法向下执行<br>  在互斥量锁定到互斥量解锁之间的代码叫做临界区 需要互斥访问共享资源的那段代码称为临界区<br>  互斥锁 互斥量mutex就是互斥锁，加锁的资源支持互斥访问<br>  读写锁<br>  shared_mutex读写锁把对共享资源的访问者划分成读者和写者，多个读线程能同时读取共享资源，但只有一个写线程能同时读取共享资源  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">shared_mutex s_m;</span><br><span class="line">std::string book;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s_m.<span class="built_in">lock_shared</span>();</span><br><span class="line">	cout &lt;&lt; book;</span><br><span class="line">	s_m.<span class="built_in">unlock_shared</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	s_m.<span class="built_in">lock</span>();</span><br><span class="line">	book = <span class="string">&quot;new context&quot;</span>;</span><br><span class="line">	s_m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  互斥锁流程<br>  <code>#include&lt;mutex&gt;</code><br>  <code>std::mutex m;//实例化m对象，不要理解为定义变量</code><br>  进入临界区之前对互斥量加锁m.lock();，退出临界区时对互斥量解锁m.unlock()<br>  用<code>std::lock_guard&lt;mutex&gt; g1(m);</code>lock_guard传入一个参数时，该参数为互斥量，此时调用了lock_guard的构造函数，申请锁定m 可替换lock与unlock 类似智能指针 退出作用域时析构即自动unlock<br>  异步线程<br>  <code>#include&lt;future&gt;</code><br>  std::async是函数模板，用来启动一个异步任务，返回一个std::future类模板对象，future对象起到了占位的作用 就是说该变量现在无值，但将来会有值 调用std::future对象的get()成员函数时，主线程会被阻塞直到异步线程执行结束，并把返回结果传递给std::future，即通过FutureObject.get()获取函数返回值 之后才不再阻塞  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">t1</span><span class="params">(<span class="type">const</span> <span class="type">double</span> a, <span class="type">const</span> <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> c = a + b;</span><br><span class="line">	<span class="built_in">Sleep</span>(<span class="number">3000</span>);<span class="comment">//假设t1函数是个复杂的计算过程，需要消耗3秒</span></span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span> a = <span class="number">2.3</span>;</span><br><span class="line">	<span class="type">double</span> b = <span class="number">6.7</span>;</span><br><span class="line">	future&lt;<span class="type">double</span>&gt; fu = <span class="built_in">async</span>(t1, a, b);<span class="comment">//创建异步线程线程，并将线程的执行结果用fu占位；</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;计算结果：&quot;</span> &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">//阻塞主线程，直至异步线程return</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  std::shard_future 也是占位 但std::future的get()成员函数是转移数据所有权;std::shared_future的get()成员函数是复制数据 future对象的get()只能调用一次 无法实现多个线程等待同一个异步线程，一旦其中一个线程获取了异步线程的返回值，其他线程就无法再次获取。 std::shared_future对象的get()可以调用多次；可以实现多个线程等待同一个异步线程，每个线程都可以获取异步线程的返回值。<br>  线程池<br>  程序启动后，预先创建一定数量的线程放入空闲队列中，这些线程都是处于阻塞状态 接收到任务后，任务被挂在任务队列，线程池选择一个空闲线程来执行此任务。任务执行完毕后，不销毁线程，线程继续保持在池中等待下一次的任务。<br>  std::thread 创建线程时需要传递函数名和函数的参数一并传入作为参数<br>  传入参数为基本数据类型(int，char,string等)时，会拷贝一份给创建的线程<br>  传入参数为指针时，会浅拷贝一份给创建的线程，(只会拷贝对象的指针)<br>  传入的参数为类对象时，会拷贝一份给创建的线程。会调用类对象的拷贝构造函数<br>  传入的参数为引用时，必须用<code>ref(实参)</code>(而不是&amp;)传递给形参，否则编译不通过，此时不存在“拷贝”行为。引用只是变量的别名，该对象始终只有一份  </p>
</li>
<li><p>单例<br>  C++中的单例只是一种组织全局变量和静态函数的方式 静态函数不一定对这些变量有作用 不能在外部被实例化(构造函数在private中) 和命名空间作用类似  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;<span class="comment">//防止复制</span></span><br><span class="line">	<span class="function"><span class="type">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="type">static</span> Singleton instance;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">		<span class="comment">//return s_Instance;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">Function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Num; &#125;</span><br><span class="line">	<span class="comment">//static int Function()&#123;return Get().IFunc();&#125;这样可直接调用Singleton::Function()而不用加Get()</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">	<span class="comment">//static Singleton s_Instance;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//int IFunc()&#123;return m_Num;&#125;</span></span><br><span class="line">	<span class="type">int</span> m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Singleton Singleton::s_Instance;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在release模式 c++标准库中的std::string在小于等于15个字符的时候不会导致堆分配 只分配一小块基于栈的缓冲区  </p>
<p>跟踪内存分配<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AllocationMetrics</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> TotalAllocated = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> TotalFreed = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="type">uint32_t</span> <span class="title">CurrentUsage</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TotalAllocated - TotalFreed; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> AllocationMetrics s_AllocationMetrics;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;<span class="comment">//关键就在重写new和delete 简单的直接在重写的函数中打印size 还可打断点看call stack</span></span><br><span class="line">	s_AllocationMetrics.TotalAllocated += size;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* memory, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">	s_AllocationMetrics.TotalFreed += size;</span><br><span class="line">	<span class="built_in">free</span>(memory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">PrintMemoryUsage</span><span class="params">()</span> </span>&#123;<span class="comment">//在main中调用即可查看共用了多少内存</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Memory Usage: &quot;</span> &lt;&lt; s_AllocationMetrics.<span class="built_in">CurrentUsage</span>() &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>移动语义 <a href="https://www.cnblogs.com/zhangyi1357/p/16018810.html">参考</a><br>  左值时有具体存储空间的变量 右值是临时值 左值引用<code>std::string&amp; str</code>只能接受左值 加上const<code>const std::string&amp; str</code>则也能接受右值 右值引用<code>std::string&amp;&amp; str</code>只能接受右值<br>  左值有地址和值，可以出现在赋值运算符左边或者右边 右值是数值字符串那些 也可以出现在赋值的左边，右值也有地址，只不过访问不到 如a+1这种右值只是将结果存储在一个临时对象中赋值完则析构<br>  左值对应于一个实实在在的内存位置，右值只是临时的对象，它的内存对程序来说只能读不能写  </p>
<p>  移动语义<br>  很多时候我们只是单纯创建一些右值，然后赋给某个对象用作构造函数。这时候会出现的情况是，我们首先需要在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。如果我们可以直接把这个右值变量移动到这个成员变量而不需要做一个额外的复制行为，程序性能就这样提高了。<br>  移动构造函数<br>  在赋值时不调用被复制的类的赋值构造函数,而是直接移动<br>  将复制其它类的类的原有的构造函数的参数改为右值引用  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Entity(const String&amp; name)</span></span><br><span class="line"><span class="comment">//     : m_Name(name) &#123;&#125;</span></span><br><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">	: <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  但仍调用了被复制的类的赋值构造函数,实际上接受右值的函数在参数传进来后其右值属性就退化了，所以给m_Name的参数仍然是左值，还是会调用复制构造函数。解决的办法是将name转型  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">	:<span class="built_in">m_Name</span>((String&amp;&amp;)name) &#123;&#125;</span><br><span class="line"><span class="comment">//或直接用库函数</span></span><br><span class="line"><span class="built_in">Entity</span>(String&amp;&amp; name)</span><br><span class="line">	:<span class="built_in">m_Name</span>(std::<span class="built_in">move</span>(name)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>  移动赋值运算符<br>  将一个已经存在的对象移动给另一个已经存在的对象 移动赋值运算符重载  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">	String&amp; <span class="keyword">operator</span>=(String&amp;&amp; other) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved\n&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;<span class="comment">//移动赋值相当于把别的对象的资源都偷走，不需要移动到自己</span></span><br><span class="line">			<span class="keyword">delete</span>[] m_Data;</span><br><span class="line"></span><br><span class="line">			m_Size = other.m_Size;</span><br><span class="line">			m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">			other.m_Data = <span class="literal">nullptr</span>;<span class="comment">//原来自己的资源一定要释放，否则指向自己原来内容内存的指针没了造成内存泄露</span></span><br><span class="line">			other.m_Size = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//使用时 str1 = std::move(str2);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>CPlusPlus</category>
      </categories>
  </entry>
  <entry>
    <title>something</title>
    <url>/CPlusPlus/something/</url>
    <content><![CDATA[<h1 id="something"><a href="#something" class="headerlink" title="something"></a>something</h1><h2 id="头文件的重复包含和变量的重复定义"><a href="#头文件的重复包含和变量的重复定义" class="headerlink" title="头文件的重复包含和变量的重复定义"></a>头文件的重复包含和变量的重复定义</h2><p><code>#pragma once</code> 解决的是重复包含 即一个cpp文件中包含了几个相同头文件的情况(头文件包含头文件) 导致多次编译  </p>
<p>重复定义指的是链接阶段时几个cpp文件中都包含了同一个头文件 而头文件中定义了变量使得每一个cpp都为其分配内存空间 导致链接时错误 最好的解决方法是不在头文件中定义只声明  </p>
]]></content>
      <categories>
        <category>CPlusPlus</category>
      </categories>
  </entry>
  <entry>
    <title>Git</title>
    <url>/Others/Git/</url>
    <content><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>(file为具体文件名)<br>git add file将工作区文件存入暂存区<br>git commit -m “” 将暂存区文件提交至分支并加注释<br>git status 掌握仓库当前的状态 看修改和增加的状况<br>git diff file 查看具体修改<br>git log 查看提交的历史日志 可以看到commit id<br>HEAD指向当前的版本 当前分支<br>git reset —hard HEAD^ 回到上一版本<br>git reset —hard (commit id 前几位) 回到对应的版本<br>git reflog 查看命令历史 可以确定版本的id<br>cat file 查看文件内容<br><strong>Git管理的是修改而不是文件</strong><br>git diff HEAD — file 查看工作区和版本库里面最新版本的区别<br>rm file 就是在工作区删文件<br>git rm file 就是删文件，并且把删文件的修改提交到暂存区 相当于rm删文件后，git add 提交 要撤回和上述相同  </p>
<h2 id="改错要撤回"><a href="#改错要撤回" class="headerlink" title="改错要撤回"></a>改错要撤回</h2><ol>
<li>改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，git restore file 回到最近一次git commit或git add时的状态  </li>
<li>不但改乱了工作区某个文件的内容，还添加到了暂存区时(add)，第一步git restore —staged file，把暂存区的修改撤销掉，重新放回工作区,就回到1，第二步按1操作。  </li>
<li>已经提交了不合适的修改到版本库时(commit)，想要撤销本次提交，版本回退git reset —hard HEAD^ 工作区，暂存区，版本库都是上次的内容  </li>
</ol>
<h2 id="远程仓库github"><a href="#远程仓库github" class="headerlink" title="远程仓库github"></a>远程仓库github</h2><ul>
<li>关联远程库:<br>在GitHub上新建仓库 git remote add origin git@github.com:vzerzz/gitest.git 把本地仓库和远程仓库关联 远程库的名字就是origin<br>git push -u origin master 把当前分支master推送到远程 第一次加-u直接把本地master和远程master关联<br>之后本地提交后可直接git push origin master 推送分支git push origin dev<br>git remote -v 查看远程库信息 显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。<br>git remote rm origin 解除了本地和远程的绑定关系 远程库未删除(在GitHub删)<br>好处:本地提交可无网络 有网了直接push到远程库  </li>
<li>克隆远程库:<br>git clone git@github.com:vzerzz/gitest.git<br>库内容会在gitest文件夹中 此时库已和远程库关联  </li>
<li>参与别人项目:<br>Fork 在自己的账号下克隆了一个别人的仓库<br>从自己的账号下clone仓库(一定要自己的 别人的没有权限推送修改)<br>修改完后推送给自己的仓库 希望别人能接受你的修改，那就在GitHub上发起一个pull request  </li>
</ul>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>分支可视作指针 master是指向提交 HEAD指向当前分支<br>git checkout -b dev 创建并切换到dev分支 git branch dev +git checkout dev<br>git branch 查看当前分支<br>git log —graph —pretty=oneline —abbrev-commit 查看分支历史  </p>
<ol>
<li><p>在dev上提交 切换回master后看不见修改<br>git merge dev 合并dev分支到当前分支(快速合并) 可以看见修改<br><img src="/Others/Git/0.png" alt><br>git branch -d dev 删除dev分支  </p>
</li>
<li><p>当master分支和dev分支各自都分别有新的提交 则无法快速合并 只能试图把各自的修改合并起来，但这种合并就可能会有冲突 只能修改后再合并<br><img src="/Others/Git/1.png" alt>  </p>
</li>
<li><p>禁用Fast forward Git就会在merge时生成一个新的commit 不删除分支<br>git merge —no-ff -m “merge with no-ff” dev 加上-m参数，把commit描述写进去 合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并<br><img src="/Others/Git/2.png" alt>  </p>
</li>
</ol>
<ul>
<li><p>分支策略:<br>master分支仅用来发布新版本，不能在上面干活 每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以<br>当dev分支工作没有完成时，去修别的分支的bug 先把git stash一下，工作现场“储藏”起来(此时status是干净的)然后换分支去修复bug，换回来后再git stash pop，恢复工作现场的同时把stash内容也删了(或git stash apply恢复 git stash drop删除)<br>在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick commit id(修复bug操作的commit id)，把bug提交的修改“复制”到当前分支 相当于把修改又提交了一次<br>要丢弃一个没有被合并过的分支，可以通过git branch -D dev强行删除<br>master分支是主分支 dev分支开发分支 bug分支修复bug feature分支实现新功能  </p>
</li>
<li><p>多人开发:<br>git clone下来只是一个本地的master<br>再git checkout -b dev origin/dev创建本地dev上修改 提交到本地master后<br>再远程提交到origin的dev分支 git push origin dev<br>如果另一个人早在你之前在远程提交更新了dev 那么可能会有冲突 此时git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送<br>如果失败则git branch —set-upstream-to=origin/dev dev 指定本地dev分支与远程origin/dev分支的链接 再pull 之后手动解决合并冲突之类的push即可<br>git pull 后 git rebase 把你的提交“放置”在远程拉取的提交之后 把分叉的提交历史“整理”成一条直线，看上去更直观  </p>
</li>
</ul>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签不能移动 相当于一个commit的引用别称之类<br>git tag v1.0 用于新建一个标签，默认为HEAD，也可以指定一个commit id<br>git tag 查看所有标签 git show v0.9 查看标签信息<br>标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签<br>git tag -d v0.1 删除标签 创建的标签都只存储在本地，不会自动推送到远程<br>推送某个标签到远程 git push origin tagname<br>一次性推送全部尚未推送到远程的本地标签 git push origin —tags<br>删除远程标签先删本地 git tag -d v0.9 再删远程 git push origin :refs/tags/v0.9  </p>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>在Git工作区的根目录下创建.gitignore文件，把要忽略的文件名填进去，Git就会自动忽略这些文件<br><a href="https://github.com/github/gitignore">.gitignore文件模板</a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*.exe # 排除所有.exe结尾的文件</span><br><span class="line">.* # 排除所有.开头的文件</span><br><span class="line">!.gitignore # 不排除.gitignore</span><br></pre></td></tr></table></figure><br>git add -f filename 强制添加到Git  </p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p><img src="/Others/Git/Git%20command.png" alt="Command">  </p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">参考教程</a><br><a href="https://learngitbranching.js.org/">练习网站</a></p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>vim</title>
    <url>/Others/vim/</url>
    <content><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="vscodevim"><a href="#vscodevim" class="headerlink" title="vscodevim"></a>vscodevim</h2><h3 id="VIM-模式"><a href="#VIM-模式" class="headerlink" title="VIM 模式"></a>VIM 模式</h3><h4 id="普通-gt-插入"><a href="#普通-gt-插入" class="headerlink" title="普通 -&gt; 插入"></a>普通 -&gt; 插入</h4><p>普通模式 —NORMAL— 转换为 插入模式 —INSERT— 的几种方法：  </p>
<p>i 在光标前插入<br>I 在行首插入<br>o 在下一行插入<br>O 在上一行插入<br>a 在光标后插入<br>A 在行尾插入  </p>
<h4 id="插入-gt-普通"><a href="#插入-gt-普通" class="headerlink" title="插入 -&gt; 普通"></a>插入 -&gt; 普通</h4><p>这个主要就是使用 ESC 键退出插入模式，在 VSCode 中，映射成了 jj 。  </p>
<h4 id="普通与可视"><a href="#普通与可视" class="headerlink" title="普通与可视"></a>普通与可视</h4><p>进入 —VISUAL— 模式：v在可视模式中再按一次 v 即可由可视模式退出到普通模式，或者直接 ESC。  </p>
<h4 id="普通与命令"><a href="#普通与命令" class="headerlink" title="普通与命令"></a>普通与命令</h4><p>进入命令模式：:<br>退出命令模式：ESC  </p>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>普通模式下：  </p>
<h4 id="上下左右移动"><a href="#上下左右移动" class="headerlink" title="上下左右移动"></a>上下左右移动</h4><p>h : 向左移动<br>j : 向下移动<br>k : 向上移动<br>l : 向下移动  </p>
<h4 id="单词间移动"><a href="#单词间移动" class="headerlink" title="单词间移动"></a>单词间移动</h4><p>w : 跳到下一个单词的开头<br>b : 跳到本单词或者上一个单词的开头（当光标在本单词的开头，则前往上一个单词的开头）<br>e : 跳到本单词或者下一个单词的结尾<br>ge : 跳到上一个单词的结尾  </p>
<h4 id="行首行尾移动"><a href="#行首行尾移动" class="headerlink" title="行首行尾移动"></a>行首行尾移动</h4><p>0 : 跳到行首<br>^ : 跳到从行首开始的第一个非空字符<br>$ : 跳到行尾<br>gg : 跳到第一行<br>G : 跳到最后一行<br>nG : 跳到第 n 行<br>:n : 跳到第 n 行  </p>
<h4 id="通过当前行字符跳转光标"><a href="#通过当前行字符跳转光标" class="headerlink" title="通过当前行字符跳转光标"></a>通过当前行字符跳转光标</h4><p>f{char} : 光标跳到下个 {char} 所在位置<br>F{char} : 反向移动到上一个 {char} 所在位置<br>t{char} : 光标跳到下一个 {char} 的前一个字符的位置<br>T{char} : 光标跳到下一个 {char} 的后一个字符的位置<br>; : 重复上次的字符查找命令<br>, : 反向查找上次的查找命令  </p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Ctrl + d : 向下滚动半屏<br>Ctrl + u : 向上滚动半屏  </p>
<p>zt 将当前行置于屏幕顶部附近<br>zz 将当前行置于屏幕中央<br>zb 将当前行置于屏幕底部  </p>
<p>H 跳转到屏幕的顶部<br>M 跳转到屏幕的中间<br>L 跳转到屏幕的底部  </p>
<p>( 跳转到上一个句子<br>) 跳转到下一个句子<br>{ 跳转到上一个段落<br>} 跳转到下一个段落  </p>
<h3 id="操作符（operator）"><a href="#操作符（operator）" class="headerlink" title="操作符（operator）"></a>操作符（operator）</h3><p>普通模式下：  </p>
<p>d : 删除（delete）<br>c : 修改（删除并进入插入模式）（change）<br>y : 复制（yank）<br>v : 选中并进入 VISUAL 模式<br>操作符的简单用法：<br>dd : 删除一整行。类似的还有 cc、yy。 Ndd : 其中 N 表示的是数字，例如 2dd 表示删除两行（向下执行），同样还有 Ncc、Nyy。  </p>
<p>小 tip： d 和 c 附带剪切效果，也就是可以用 p 复制删除的内容。  </p>
<h3 id="动作-motion"><a href="#动作-motion" class="headerlink" title="动作 motion"></a>动作 motion</h3><h4 id="i-inner-和-a-around-的区别"><a href="#i-inner-和-a-around-的区别" class="headerlink" title="i(inner) 和 a(around) 的区别"></a>i(inner) 和 a(around) 的区别</h4><p>i + object : 内部文本对象<br>a + object : 外部文本对象 简单的说就是，i 不包括包围文本对象的空白或者括号等，er a 包括了包围文本对象的空白或者括号等。  </p>
<h4 id="基本的使用"><a href="#基本的使用" class="headerlink" title="基本的使用"></a>基本的使用</h4><p>iw / aw<br>i( / a( 或 ib / ab<br>i{ / a{ 或 iB / aB<br>i” / a”<br>i’ / a’<br>i` / a`<br>i&lt; / a&lt;<br>i[ / a[  </p>
<h3 id="操作符跟动作的结合"><a href="#操作符跟动作的结合" class="headerlink" title="操作符跟动作的结合"></a>操作符跟动作的结合</h3><p>结合跳转的一些例子：  </p>
<p>y$ : 复制当前位置到行尾的所有内容<br>dw : 删除当前位置到下一个单词的开头<br>c} : 修改当前位置到这个段落的结尾<br>d( : 删除到句子的开头<br>结合数字的一些例子：  </p>
<p>y2h : 向左拷贝两个字符<br>d2w : 删除后两个单词<br>c2j : 修改后面两行<br>结合 i 和 a 的一些例子：  </p>
<p>di( : 删除括号内的内容  </p>
<p>di{ : 删除大括号内的内容  </p>
<p>diw : 删除光标所在的单词  </p>
<p>da( : 删除括号和括号内的内容  </p>
<p>da{ : 删除大括号和大括号内的内容  </p>
<p>daw : 删除光标所有的单词以及周围的空白  </p>
<p>df\<char\> : 删除到下一个 char 字符  </char\></p>
<h3 id="切换大小写"><a href="#切换大小写" class="headerlink" title="切换大小写"></a>切换大小写</h3><p>~ : 将光标下的字母改变大小写<br>3~ : 将光标位置开始的 3 个字母改变其大小写<br>g~~ : 改变当前行的大小写<br>gUU : 将当前行的字母改为大写<br>guu : 将当前行的字母改成小写<br>gUaw(gUiw) : 将光标下的单词改成大写<br>guaw(guiw) : 将光标下的单词改成小写  </p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p>u : 撤销<br>Ctrl + r : 恢复撤销<br>p : 粘贴<br>x : 删除当前光标所在的字符<br>r : 替换当前光标所在的字符  </p>
<h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>一些使用 VSCode 开发中常用的操作：  </p>
<p>函数定义之类：<br>gd : 进入函数定义<br>Ctrl+o : 从函数定义中返回<br>gh : 查看函数参数等信息<br>切换标签页：<br>gt : 切换到下一个标签页<br>gT : 切换到上一个标签页<br>4gt : 切换到第 4 个标签页<br>其他： 可以使用 Ctrl + 0 来将光标从编辑器跳转到文件栏，在文件栏可以使用 j 和 k 进行移动，可以使用 Space 展开或者关闭文件夹，使用 l 可以将光标选中的文件在编辑器中打开。<br>还有如果使用侧边栏打开文件，可以使用 Ctrl + 1 跟 Ctrl + 2 实现跳转。  </p>
<h3 id="值得记住的组合拳"><a href="#值得记住的组合拳" class="headerlink" title="值得记住的组合拳"></a>值得记住的组合拳</h3><p>xp : 调换相邻的两个字符<br>ddp : 调换相邻的两行 这种组合拳最好是形成肌肉记忆，而不是去试图理解它的意思。  </p>
<h2 id="easymotion"><a href="#easymotion" class="headerlink" title="easymotion"></a>easymotion</h2><p>VSCode 的 VIM 插件默认将 \<leader\> 设为 Space.  </leader\></p>
<p>\<leader\>\<leader\> s \<char\> : 搜索 char 字符<br>其他的一些操作可以查看 VSCode 的 VIM 插件的介绍页  </char\></leader\></leader\></p>
<h3 id="vim-surround"><a href="#vim-surround" class="headerlink" title="vim-surround"></a>vim-surround</h3><p>ds” : 删除两侧的 “<br>y s \<motion\> \<desired\> : 通过 motion 在指定内容两侧增加字符<br>cs”‘ : 把两侧的 “ 改为 ‘  </desired\></motion\></p>
<h3 id="更改匹配项"><a href="#更改匹配项" class="headerlink" title="更改匹配项"></a>更改匹配项</h3><p>:s/dog/cat/             替换当前行第一个dog为cat<br>:s/dog/cat/g            替换当前行所有dog<br>:n,$s/dog/cat/          替换从第n行到最后一行每行中的第一个dog为cat<br>:n,$s/dog/cat/g         替换从第n行到最后一行每行中的所有的dog为cat<br>:%s/dog/cat/            替换全文每行中的第一个dog为cat<br>:%s/dog/cat/g           替换全文每行中的所有的dog为cat  </p>
<h2 id="Vsvim"><a href="#Vsvim" class="headerlink" title="Vsvim"></a>Vsvim</h2><h3 id="自带命令"><a href="#自带命令" class="headerlink" title="自带命令"></a>自带命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.normal模式下</span><br><span class="line">    1.移动</span><br><span class="line">        .基本移动</span><br><span class="line">            hjkl</span><br><span class="line">        .单词移动</span><br><span class="line">            w:word  &quot;跳转到下一个单词的头&quot;</span><br><span class="line">            W:WORD  转到下个空格后单词的头</span><br><span class="line">            e:word&#x27;s end   &quot;跳转到这个单词的结尾&quot;</span><br><span class="line">            E:WORD&#x27;s end    下个空格前</span><br><span class="line">            ge:word&#x27;s end &quot;跳转到上一个单词的结尾&quot;</span><br><span class="line">            gE:WORD&#x27;s end</span><br><span class="line">            b:back &quot;跳转到单词的头&quot;</span><br><span class="line">            B:back &quot;跳转到WORD的头&quot;</span><br><span class="line">        .行移动</span><br><span class="line">            _ ^： 跳转到行的第一个字符</span><br><span class="line">            0:  跳转到行首</span><br><span class="line">            $:  跳转到行的最后一个字符</span><br><span class="line">        .缩进行</span><br><span class="line">            &gt;&gt; :向右缩进(原Tab)</span><br><span class="line">            &lt;&lt; :向左缩进</span><br><span class="line">        .段落移动：</span><br><span class="line">            &#123;: 向上移动一个段落</span><br><span class="line">            &#125;: 向下移动一个段落</span><br><span class="line">            [[:文件首部</span><br><span class="line">            ]]:文件尾部</span><br><span class="line">        .屏幕移动</span><br><span class="line">            gg: 跳转到文件首部</span><br><span class="line">            G:  跳转到文件结尾</span><br><span class="line">            12gg:   跳转到第12行</span><br><span class="line">            zz: 当前光标移动到屏幕最中央</span><br><span class="line">            zt: 当前光标移动到屏幕最上方（top）</span><br><span class="line">            zb: 当前光标移动到屏幕最下方（bottom）</span><br><span class="line">            c-f:    下翻半页</span><br><span class="line">            c-u:    上翻半页</span><br><span class="line">    2.进入插入模式</span><br><span class="line">        i:  插入到光标前</span><br><span class="line">        I:  插入到行的最前面</span><br><span class="line">        a:  插入到光标后</span><br><span class="line">        A:  插入到行的最后面</span><br><span class="line">        s:删除光标下的字符，并进入插入模式</span><br><span class="line">        S:删除当前行所有字符，并进入插入模式</span><br><span class="line">        ce/cw: 删除当前光标到word末尾处的字符，进入插入模式</span><br><span class="line">        C:删除当前光标后的所有字符，并进入插入模式</span><br><span class="line"></span><br><span class="line">        o:插入到下一行</span><br><span class="line">        O:插入到上一行</span><br><span class="line">    3.撤销和reDo</span><br><span class="line">        u:  撤销</span><br><span class="line">        c-r: redo</span><br><span class="line">    4.替换</span><br><span class="line">        r:  用输入替换光标下的字符</span><br><span class="line">        R:进入替换模式</span><br><span class="line">    5.查找：</span><br><span class="line">        .单行</span><br><span class="line">        f&#123;char&#125;:    从当前光标向后查找char。</span><br><span class="line">        F&#123;char&#125;:    从当前光标向前查找char</span><br><span class="line">        t&#123;char&#125;:    从当前光标向后查找char,光标落到char之前</span><br><span class="line">        T&#123;char&#125;:    从当前光标向前查找char,光标落到char之后</span><br><span class="line">            ; :下一个char</span><br><span class="line">            , :上一个char</span><br><span class="line">        .整个文件中查找</span><br><span class="line">        / : 从当前行向下查找</span><br><span class="line">        ? : 从当前行向上查找</span><br><span class="line">        * : 从当前向下，查找当前光标下的word </span><br><span class="line">        # : 从当前向上，查找当前光标下的word </span><br><span class="line">        n : 下一个查找结果</span><br><span class="line">        N : 上一个查找结果</span><br><span class="line">    6.删除</span><br><span class="line">        x:剪切当前光标下的字符</span><br><span class="line">        X:剪切当前光标前的一个字符</span><br><span class="line"></span><br><span class="line">        d&#123;motion&#125;:删除</span><br><span class="line">        dl: 删除当前光标下的一个字符</span><br><span class="line">        de/dw: 删除当前光标下到word end的字符 dw会删除后面的空格</span><br><span class="line">        db: 删除当前光标下，到word head的字符</span><br><span class="line">        D:  删除当前光标下到行尾的字符</span><br><span class="line">    7.复制</span><br><span class="line">        y&#123;motion&#125;:复制</span><br><span class="line">        yl: 复制当前光标下的一个字符</span><br><span class="line">        yy/Y：复制当前行</span><br><span class="line">        ye/yw: 复制当前光标到word end的字符</span><br><span class="line">        yb:复制当前光标前一字符到word head的字符</span><br><span class="line">    8.粘贴</span><br><span class="line">        p:粘贴到当前光标后</span><br><span class="line">        P:粘贴到当前光标前</span><br><span class="line"></span><br><span class="line">    9.点范式（.）</span><br><span class="line">        . :重复上次的修改(移动，删除，增加)</span><br><span class="line">    10.组合命令</span><br><span class="line">        yyp:复制当前行到下一行</span><br><span class="line">        ddp:和下一行交换（删除当前行，复制到下一行）</span><br><span class="line">        xp:交换两个chr的位置</span><br><span class="line"></span><br><span class="line">        yi(:复制括号()中的内容 yi&#123; yi[ yi&quot; yi&#x27;</span><br><span class="line">        di(:删除括号()中的内容 di&#123; di[ di&quot; di&#x27;</span><br><span class="line">        %:跳转匹配的&#123;&#125;、()、[]</span><br><span class="line">    11.修改文本</span><br><span class="line">       J:将光标所在的下一行和本行连接,并且中间隔一个空格</span><br><span class="line">       gJ:将光标所在的下一行和本行连接(下一行的空格也连接)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.insert模式下</span><br><span class="line">    c-o:暂时进入normal模式。一次命令后，回到插入模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3.visual模式(visual(可视行，可视块))）,select(选择))</span><br><span class="line">    normal模式进入可视模式：</span><br><span class="line">        v:字符可视模式</span><br><span class="line">        V:行visual</span><br><span class="line">        c-v:块visual</span><br><span class="line">    退出可视模式：</span><br><span class="line">        行/块visual  v-&gt; visual v-&gt; normal</span><br><span class="line">        字符可视模式  v -&gt;normal</span><br><span class="line">        &lt;esc&gt; or &lt;c-[&gt;</span><br><span class="line">    块模式下插入：</span><br><span class="line">        c-V：进入块模式，并选择好区域</span><br><span class="line">        I    在所选区域前，进入块插入模式(插入的内容会在所有列都插入)</span><br><span class="line">        A    在所选区域后，进入块插入模式(插入的内容会在所有列都插入)</span><br><span class="line">        c    删除所选区域内容，并进入块插入模式(插入的内容会在所有列都插入)</span><br><span class="line">        C    删除所选区域以及所选区域后的所有内容，并且进入块插入模式(插入的内容会在所有列都插入)</span><br><span class="line">        &lt;esc&gt; 退出到normal模式</span><br><span class="line"></span><br><span class="line">    c-g:切换可视模式和选择模式</span><br><span class="line"></span><br><span class="line">    可用命令：</span><br><span class="line">        移动：hjkl</span><br><span class="line">        查找：f&#123;char&#125; ; , n/N</span><br><span class="line">        删除：c C d x s</span><br><span class="line">    其他命令：</span><br><span class="line">        o: 切换选中区域的首和尾</span><br><span class="line">        U: 选中的字符全部大写 </span><br><span class="line">        u: 选中的字符全部小写</span><br><span class="line">        ~：选中的字符切换大小写</span><br><span class="line"></span><br><span class="line">    组合命令：</span><br><span class="line">    ve/vw/viw:选中一个单词</span><br><span class="line">    vu:光标下的字符小写</span><br><span class="line">    vU:光标下的字符大写</span><br><span class="line">    veu/U:选中一个单词小写/大写</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.command模式</span><br><span class="line">    在normal模式或者visual模式下输入冒号:,进入命令模式</span><br><span class="line">    normal模式下的命令，可以在命令模式下运行</span><br><span class="line">    command下也可以运行ex命令</span><br><span class="line">    :com[mand]  列出所有用户自定义的命令</span><br><span class="line">    基本命令：</span><br><span class="line">    :w[a]  [全部]写入（保存） </span><br><span class="line">    :q[a]  [全部]退出        </span><br><span class="line">    :c[a]  [全部]关闭buffer</span><br><span class="line">    :x[a]  [全部]和:wq类型，当文件有修改时候，会写入</span><br><span class="line"></span><br><span class="line">    :[range]copy/co/t &#123;address&#125;  将范围内的行复制到目标地址处  &#123;address&#125;使用符号</span><br><span class="line">    :[range]move &#123;address&#125;    将范围内的行移动到目标地址处</span><br><span class="line"></span><br><span class="line">    :normal 命令，在命令行中执行normal模式下的命令</span><br><span class="line">    如果是visual模式，会呈现</span><br><span class="line">    :&#x27;&lt;,&#x27;&gt;normal    会在每一行都执行命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.命令范围</span><br><span class="line">    .command模式下</span><br><span class="line">        vim中，在单个文件中，</span><br><span class="line">        1.以行号为地址</span><br><span class="line">        2.此外，还有一些特殊符号表示地址，例如：</span><br><span class="line">            %   整个文件（:1,$的简写形式）</span><br><span class="line">            .   光标所在位置。当前位置</span><br><span class="line">            1   文件第一行</span><br><span class="line">            $   文件最后一行</span><br><span class="line">            0   虚拟行，位于文件第一行上方</span><br><span class="line">            &#x27;m  包含标记m的行</span><br><span class="line">            &#x27;&lt;  高亮选区的起始行</span><br><span class="line">            &#x27;&gt;  高亮选区的结束行</span><br><span class="line"></span><br><span class="line">        范围的表示用逗号隔开，例如 add1,add2</span><br><span class="line">        :12,15d 表示删除12行到15行内容</span><br><span class="line">        :[range]d[elete] [x] &#123;count&#125;    &quot;x到代表寄存器x里&quot;</span><br><span class="line">    .normal模式下</span><br><span class="line">        normal中的一些命令，可以指定运行次数，例如：</span><br><span class="line">            2dd 运行两次dd-&gt;删除两行</span><br><span class="line">            2yy 运行两个yy-&gt;复制两行</span><br><span class="line"></span><br><span class="line">6.mark和跳转</span><br><span class="line">mx:添加本文件&quot;书签&quot;x</span><br><span class="line">mX:添加全局&quot;书签&quot;X</span><br><span class="line">`x:跳转到书签x所在的行和列</span><br><span class="line">&#x27;x:跳转到书签x所在行</span><br><span class="line">``:跳转到本文件上次离开的位置</span><br><span class="line">gi:跳转到上一次插入的位置</span><br><span class="line">gv:跳转到上一次进入visual的位置</span><br><span class="line"></span><br><span class="line">7.其他</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:help [   index帮助文档中，所有命令</span><br></pre></td></tr></table></figure>
<p><img src="/Others/vim/vim.png" alt="vim">  </p>
<h3 id="vsvimrc"><a href="#vsvimrc" class="headerlink" title="_vsvimrc"></a>_vsvimrc</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;重要配置</span><br><span class="line">:set backspace=indent,eol,start &quot;退格键设置&quot;</span><br><span class="line">:set clipboard=unnamed   &quot;默认的剪切寄存器 共享系统剪切板&quot;</span><br><span class="line">:set ignorecase  &quot;vim忽略大小写&quot;</span><br><span class="line">:set nohlsearch &quot;关闭高亮搜索的关键字&quot;</span><br><span class="line"></span><br><span class="line">&quot;单文件：</span><br><span class="line">:inoremap jk &lt;Esc&gt;</span><br><span class="line">:nnoremap &lt;space&gt; za &quot;折叠&quot;</span><br><span class="line"></span><br><span class="line">&quot; Navigation</span><br><span class="line">:nnoremap `. :vsc View.QuickActionsForPosition&lt;CR&gt;</span><br><span class="line">:nnoremap `` :vsc Edit.GoToAll&lt;CR&gt;</span><br><span class="line">:nnoremap `i :vsc Edit.GoToImplementation&lt;CR&gt;</span><br><span class="line">:nnoremap `d :vsc Edit.GoToDefinition&lt;CR&gt;</span><br><span class="line">:nnoremap `l :vsc Edit.GoToDeclaration&lt;CR&gt;</span><br><span class="line">:nnoremap `r :vsc Edit.FindAllReferences&lt;CR&gt;</span><br><span class="line">:nnoremap `q :vsc Edit.QuickInfo&lt;CR&gt;</span><br><span class="line">:nnoremap `p :vsc Edit.PeekDefinition&lt;CR&gt;</span><br><span class="line">:nnoremap `f :vsc Edit.FormatDocument&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">:nnoremap `s :vsc File.SaveAll&lt;CR&gt;</span><br><span class="line">:nnoremap `x :vsc File.Close&lt;CR&gt;</span><br><span class="line">:nnoremap `o :vsc File.OpenContainingFolder&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot; Errors - `eX</span><br><span class="line">:nnoremap `ee :vsc View.ErrorList&lt;CR&gt;</span><br><span class="line">:nnoremap `en :vsc View.NextError&lt;CR&gt;</span><br><span class="line">:nnoremap `ep :vsc View.PreviousError&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; comment</span><br><span class="line">:nnoremap `cc :vsc Edit.ToggleComment&lt;CR&gt;</span><br><span class="line">:nnoremap `cl :vsc Edit.ToggleLineComment&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Build - `bX</span><br><span class="line">:nnoremap `bb :vsc Build.BuildSolution&lt;CR&gt;</span><br><span class="line">:nnoremap `bc :vsc Build.CleanSolution&lt;CR&gt;</span><br><span class="line">:nnoremap `br :vsc Build.RebuildSolution&lt;CR&gt;</span><br><span class="line">:nnoremap `bs :vsc Debug.Start&lt;CR&gt;</span><br><span class="line">:nnoremap `bw :vsc Debug.StartWithoutDebugging&lt;CR&gt;</span><br><span class="line">:nnoremap `bq :vsc Debug.StopDebugging&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot; Tests - `tX</span><br><span class="line">:nnoremap `ta :vsc TestExplorer.RunAllTests&lt;CR&gt;</span><br><span class="line">:nnoremap `tt :vsc TestExplorer.RunAllTestsInContext&lt;CR&gt;</span><br><span class="line">:nnoremap `tc :vsc TestExplorer.RunAllTestsInContext&lt;CR&gt;</span><br><span class="line">:nnoremap `ts :vsc TestExplorer.RunSelectedTests&lt;CR&gt;</span><br><span class="line">:nnoremap `td :vsc TestExplorer.DebugAllTestsInContext&lt;CR&gt;</span><br><span class="line">:nnoremap `tf :vsc TestExplorer.RunFailedTests&lt;CR&gt;</span><br><span class="line"></span><br><span class="line">&quot;end</span><br><span class="line">&quot;source ~/vsvimrc     &quot;读取filefullPath的配置内容，并运行&quot;</span><br></pre></td></tr></table></figure>
<h3 id="vs自带快捷键"><a href="#vs自带快捷键" class="headerlink" title="vs自带快捷键"></a>vs自带快捷键</h3><p>F9 断点</p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>env</title>
    <url>/Others/env/</url>
    <content><![CDATA[<h1 id="env"><a href="#env" class="headerlink" title="env"></a>env</h1><h2 id="gcc-g"><a href="#gcc-g" class="headerlink" title="gcc/g++"></a>gcc/g++</h2><ul>
<li>区别:<br>  gcc 只要是 GCC 支持编译的程序代码，都可以使用 gcc 命令完成编译(根据后缀名)<br>  <code>gcc -xc++ xxx.cpp</code>  <code>-x</code>手动指定代表编译方式<br>  g++ 无论目标文件的后缀名是什么，该指令都一律按照编译 C++ 代码的方式编译<br>  C++ 标准和 C 语言标准的语法要求有区别 C++更严格<br>  单纯的 gcc 命令是无法自动链接标准库文件<br>  <code>gcc -xc++ demo.cpp -lstdc++ -shared-libgcc</code> 使得 gcc 在编译 C++ 程序时可以链接必要的 C++ 标准库<br>  可以认为 g++ 指令等同于<code>gcc -xc++ -lstdc++ -shared-libgcc</code>指令  </li>
<li>命令:  </li>
</ul>
<ol>
<li><p>无选项编译链接<br><code>gcc hello.c</code> 未指定输出文件，Linux上默认输出为a.out，window中默认为a.exe  </p>
</li>
<li><p>选项 -o(理解成output)<br><code>gcc -o hello hello.c</code> 对生成的目标进行重命名，linux下为hello.out，windows下为hello.exe  </p>
</li>
<li><p>选项 -E<br><code>gcc -E hello.c -o hello.i</code> 把源代码预处理输出为hello.i文件  </p>
</li>
<li><p>选项 -S<br><code>gcc -S hello.i</code> 把预处理输出的文件hello.i汇编成hello.s文件  </p>
</li>
<li><p>选项 -c<br><code>gcc -c hello.s</code> 把汇编成hello.s文件编译输出为hello.o文件，输出文件为二进制目标文件  </p>
</li>
<li><p>无选项链接<br><code>gcc hello.o -o hello1</code> 把hello.o目标文件链接成最终可执行文件hello1.exe,其实是调用ld命令进行链接  </p>
</li>
<li><p>选项 -O<br><code>gcc -O3 hello.c -o hello2</code> 使用编译优化级别，1~3，级别越大优化效果越好，但编译的时候会长  </p>
</li>
<li><p>选项 -M<br><code>gcc -M hello.c</code> 查看生成文件关联信息，包含目标文件所依赖的所有源代码，该命令会在预处理阶段中执行(选项 -MM，与-M相比，会忽略#include文件的依赖关系)  </p>
</li>
<li><p>多个文件一起编译/多个.o二进制目标文件编译后链接<br><code>gcc hello.c multi.c -o multi</code> <code>gcc multi.o hello.o -o multi1</code>  </p>
</li>
<li><p>选项 -include<br><code>gcc hello.c -include multi.c -o hello3</code> 相当于在文件中加入#include  </p>
</li>
<li><p>选项 -Idir<br>当你使用#include “file”的时候，会先到你定制的目录里面查找  </p>
</li>
<li><p>选项 -L<br><code>gcc -o hello hello.c -L/home/hello/lib</code> 定制编译的时候使用的库,/home/hello/lib作为第一个寻找库文件的目录  </p>
</li>
<li><p>选项 -l<br><code>gcc -o hello hello.c -ltest</code> 定制编译的时候使用的库，寻找动态链接库文件libtest.so，如果加上-static，表示寻找libtest.a静态链接库  </p>
</li>
<li><p>选项 -w<br><code>gcc -w multi.c hello.c -o multi</code> 表示不生成任何警告的信息 (-Wall：生成所有警告信息)  </p>
</li>
<li><p>选项 -g<br><code>gcc -g hello.c -o hello5</code> 在编译的时候加入debug调试信息，用于gdb调试，文件会比一般大一点  </p>
</li>
<li><p>选项 -share<br>尽量的使用动态库，所以生成文件比较小，但是必须是系统有动态库  </p>
</li>
<li><p>选项 -shared<br>生成共享目标文件，通常用在建立共享库  </p>
</li>
</ol>
<h2 id="vscode工程配置"><a href="#vscode工程配置" class="headerlink" title="vscode工程配置"></a>vscode工程配置</h2><h3 id="单一文件小工程"><a href="#单一文件小工程" class="headerlink" title="单一文件小工程"></a>单一文件小工程</h3><ul>
<li><p>c_cpp_properties.json<br>  配置编译器环境  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Linux&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/include&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/include/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/local/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/usr/lib/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;vcpkgRoot&#125;/x64-windows/include&quot;</span></span><br><span class="line">            ],<span class="comment">//头文件路径 指明了C/C++标准库、用户头文件以及vcpkg库所在位置</span></span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;compilerPath&quot;</span>: <span class="string">&quot;/usr/bin/gcc&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cStandard&quot;</span>: <span class="string">&quot;c11&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cppStandard&quot;</span>: <span class="string">&quot;c++17&quot;</span>,</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;clang-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>tasks.json<br>  添加构建(编译、链接等)任务 CMakeLists.txt可以替代  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>,<span class="comment">//选择什么编译器</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>:[<span class="string">&quot;-g&quot;</span>, <span class="string">&quot;$&#123;file&#125;&quot;</span>, <span class="string">&quot;-std=c++11&quot;</span>, <span class="string">&quot;-o&quot;</span>, <span class="string">&quot;$&#123;fileBasenameNoExtension&#125;.out&quot;</span>]<span class="comment">//编译的时候用到的参数</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>launch.json<br>  调试时的配置文件 单纯只是想生成可执行文件，其实这个文件没有也可以  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;gcc build and debug active file&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.out&quot;</span>,<span class="comment">//生成的可执行文件名 要与tasks.json文件中指定生成的文件名相同</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//要与tasks.json文件中的label一致</span></span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="大型项目-Cmake"><a href="#大型项目-Cmake" class="headerlink" title="大型项目(Cmake)"></a>大型项目(Cmake)</h3><p>项目结构:</p>
<ul>
<li>build</li>
<li>include</li>
<li>src</li>
<li>bin</li>
<li>lib  </li>
<li>CMakeLists.txt  </li>
</ul>
<p><code>cmake</code> 基于CMakeLists.txt生成makefile文件<br><code>make</code> 编译makefile文件，生成可执行文件  </p>
<blockquote>
<p>推荐编写c_cpp_properties.json，该文件中includePath参数可以很好指定头文件目录，这样就算没有CMakeLists.txt文件，我们在vscode编写程序的时候它也自动包含了头文件，这样就可以具有代码提示功能 。而且，有了CMakeLists.txt以后，即使写了c_cpp_properties.json文件，也并不影响项目脱离vscode单独在shell/cmd里编译运行</p>
</blockquote>
<ul>
<li><p>调试<br>  加入tasks.json 和 launch.json<br>  build后在build文件夹下生成了result可执行文件  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tasks.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-DCMAKE_BUILD_TYPE=Debug&quot;</span>,</span><br><span class="line">                <span class="string">&quot;..&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;make&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;make&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;CMake Build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;dependsOn&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;cmake&quot;</span>,</span><br><span class="line">                <span class="string">&quot;make&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;(gdb) Launch&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="comment">//&quot;program&quot;: &quot;enter program name, for example $&#123;workspaceFolder&#125;/a.out&quot;,</span></span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/build/result&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="string">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;Enable pretty-printing for gdb&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;CMake Build&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CMakeLists  </p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 指定最低版本</span><br><span class="line"><span class="built_in">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"></span><br><span class="line"># 指定项目名称</span><br><span class="line"><span class="built_in">project</span>(demo)</span><br><span class="line"></span><br><span class="line"># 为当前路径以及子目录的源文件加入由-D预编译定义</span><br><span class="line"># <span class="built_in">add_definitions</span>(-DFOO -DDEBUG ...)</span><br><span class="line"></span><br><span class="line"># 设置C++编译参数(CMAKE_CXX_FLAGS是全局变量)</span><br><span class="line"><span class="meta"># set(CMAKE_CXX_FLAGS <span class="string">&quot;-Wall std=c++11 -Wextra -fPIC -g&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"># 设置指定的C++编译器版本是必须的，如果不设置，或者为OFF，则指定版本不可用时，会使用上一版本。</span><br><span class="line"><span class="meta"># set(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span><br><span class="line"></span><br><span class="line"># 指定为C++<span class="number">11</span> 版本</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="meta"># set(CMAKE_CXX_STANDARD 14)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="meta"># <span class="keyword">warning</span> level 4 and all warnings as errors</span></span><br><span class="line">    <span class="built_in">add_compile_options</span>(/W4 /WX)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="meta"># lots of warnings and all warnings as errors</span></span><br><span class="line">    <span class="built_in">add_compile_options</span>(-Wall -Wextra -pedantic -Werror)</span><br><span class="line"><span class="built_in">endif</span>()</span><br><span class="line"></span><br><span class="line"># 设置变量</span><br><span class="line"><span class="built_in">set</span>(ROOT_DIR /home/tf)</span><br><span class="line"></span><br><span class="line"># 头文件查找目录</span><br><span class="line"><span class="built_in">include_directories</span>(</span><br><span class="line">    $&#123;ROOT_DIR&#125;/include</span><br><span class="line">    $&#123;ROOT_DIR&#125;/include/third_party</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 库文件查找目录</span><br><span class="line"><span class="built_in">link_directories</span>($&#123;ROOT_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line"># sub_dir指定包含CMakeLists.txt和源码文件的子目录位置</span><br><span class="line"># binary_dir是输出路径， 一般可以不指定</span><br><span class="line"><span class="built_in">add_subdirecroty</span>(sub_dir [binary_dir])</span><br><span class="line"></span><br><span class="line"># 把src目录下所有源文件写入变量DIR_SRCS</span><br><span class="line"><span class="built_in">aux_source_directory</span>(./src DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 以DIR_SRCS为源文件生成目标文件a.out</span><br><span class="line"><span class="built_in">add_executable</span>(a.out $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line"># 创建库文件</span><br><span class="line"># <span class="built_in">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN)</span><br><span class="line"></span><br><span class="line"># 目标文件链接的库</span><br><span class="line"><span class="built_in">target_link_libraries</span>(a.out</span><br><span class="line">    pthread</span><br><span class="line">    boost_thread</span><br><span class="line">    boost_system</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>PROJECT_SOURCE_DIR：包含PROJECT()命令的最近一个CMakeLists.txt文件所在的文件夹路径  </li>
<li>CMAKE_SOURCE_DIR：最外层CMakeLists.txt所在目录  </li>
<li>_SOURCE_DIR：CMakeLists中没有这个预定义的变量名  </li>
<li><p>CMAKE_CURRENT_SOURCE_DIR 当前处理的CMakeLists.txt所在的目录。</p>
</li>
<li><p>PROJECT_BINARY_DIR/CMAKE_BINARY_DIR/_BINARY_DIR： 运行cmake命令的目录，即工程编译发生的路径  </p>
</li>
<li><p>EXECUTABLE_OUTPUT_PATH： 指定最终的可执行文件的位置  </p>
</li>
<li><p>LIBRARY_OUTPUT_PATH： 设置库文件的输出目录  </p>
</li>
<li><p>set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG ${PROJECT_SOURCE_DIR}/../bin)  </p>
</li>
<li><p>set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE ${PROJECT_SOURCE_DIR}/../bin)<br>上面两条语句分别设置了Debug版本和Release版本可执行文件的输出目录  </p>
</li>
<li><p>set(CMAKE_EXPORT_COMPILE_COMMANDS ON) 开启后，其生成的文件compile_commands.json，包含所有编译单元所执行的指令  </p>
</li>
</ul>
<h2 id="visual-studio-MSVC-解决方案目录结构解析"><a href="#visual-studio-MSVC-解决方案目录结构解析" class="headerlink" title="visual studio (MSVC) 解决方案目录结构解析"></a>visual studio (MSVC) 解决方案目录结构解析</h2><h3 id="默认目录结构"><a href="#默认目录结构" class="headerlink" title="默认目录结构:"></a>默认目录结构:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Solution // $(SolutionDir) </span><br><span class="line">├─.vs //默认为隐藏 存储解决方案的配置和状态，包括窗口布局，选项卡，操作记录，文件文档，某些自定义配置，开发环境，调试断点等 .suo文件在其中  </span><br><span class="line">│</span><br><span class="line">├─Solution.sln //解决方案配置文件，解决方案指一个大型项目整体的工作环境。该文件用于组织多个工程和相关的元素到一个解决方案中，鼠标双击它就能用 VS 打开整个项目</span><br><span class="line">│  </span><br><span class="line">├─Project // 工程目录/工作目录 $(ProjectDir)，表示一个解决方案下的子工程。该目录包含该子工程所有的头文件，源代码等 </span><br><span class="line">│  │  Project.vcxproj // 工程的属性文件</span><br><span class="line">│  │  Project.vcxproj.filters // 工程中的目录组织结构</span><br><span class="line">│  │  Project.vcxproj.user // 用户相关工程配置</span><br><span class="line">│  │  source.cpp</span><br><span class="line">│  │  </span><br><span class="line">│  └─x64 // 根据项目的不同平台(Win32/x64)和不同配置(Debug/Releasae)对应该子工程的一些目标代码，程序调式数据库，运行日志等中间目录</span><br><span class="line">│      │</span><br><span class="line">│      ├─Release ...</span><br><span class="line">│      └─Debug // $(IntDir)中间目录=$(Configuration)</span><br><span class="line">│          │  Project.exe.recipe</span><br><span class="line">│          │  Project.ilk</span><br><span class="line">│          │  Project.log</span><br><span class="line">│          │  vc143.idb</span><br><span class="line">│          │  vc143.pdb</span><br><span class="line">│          │  vcpkg.applocal.log</span><br><span class="line">│          │  source.obj</span><br><span class="line">│          │  </span><br><span class="line">│          └─Project.tlog</span><br><span class="line">│                  CL.command.1.tlog</span><br><span class="line">│                  CL.read.1.tlog</span><br><span class="line">│                  CL.write.1.tlog</span><br><span class="line">│                  link.command.1.tlog</span><br><span class="line">│                  link.read.1.tlog</span><br><span class="line">│                  link.write.1.tlog</span><br><span class="line">│                  Project.lastbuildstate</span><br><span class="line">│                  </span><br><span class="line">└─x64 // 根据解决方案的不同平台和配置生成的最终解决方案输出目录</span><br><span class="line">    ├─Debug </span><br><span class="line">    │       Project.exe // $(OutDir)输出目录 = $(SolutionDir)$(Configuration)</span><br><span class="line">    │       Project.pdb //程序调试数据库，编译链接时生成，主要存储了 VS 调试时需要的代码中断点等基本信息</span><br><span class="line">    │       Project.ilk //增量链接文件，增量链接是相对于完整链接而言的，使每次源代码的更改只需要更新可执行文件中受影响的部分，不需重新构建整个可执行文件</span><br><span class="line">    └─Release</span><br><span class="line">        ├─ Project.exe</span><br><span class="line">	    ├─ Project.iobj // 中间目标程序</span><br><span class="line">	    ├─ Project.ipdb // 中间程序调试数据库</span><br><span class="line">	    └─ Project.pdb</span><br><span class="line"></span><br><span class="line">// vs下C++和C#目录结构不同  </span><br><span class="line">C#:  </span><br><span class="line">- sln</span><br><span class="line">- project</span><br><span class="line">    - bin 存放最终生成的结果</span><br><span class="line">        - Debug&amp;Release</span><br><span class="line">    - obj 存中间编译结果</span><br><span class="line">    - sourcecode</span><br><span class="line">    - Properties 属性文件夹</span><br><span class="line">    - proj 项目配置文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>stdafx.h &amp; stdafx.cpp &amp; .pch<br>.pch 用于保存预编译好的文件，一般会将工程中较稳定的不会经常修改的代码预编译好放在其中，以后不再编译这部分，直接使用预编译结果，从而提高编译的速度。.pch 通过编译 stdafx.cpp 生成，编译器通过 stdafx.h 使用 .pch，所有在指令 #include “stdafx.h” 前的代码都是预编译的，编译器将跳过跳过该编译指令，转而编译之后的代码。</p>
</blockquote>
<p>将解决方案和项目放在同一目录中则将上述Project文件夹释放, sourcecode和sln在一起, 两个x64-Debug合并<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Solution</span><br><span class="line">├─.vs</span><br><span class="line">│</span><br><span class="line">├─Project.sln</span><br><span class="line">├─Project.vcxproj</span><br><span class="line">├─Project.vcxproj.filters</span><br><span class="line">├─Project.vcxproj.user</span><br><span class="line">├─source.cpp</span><br><span class="line">│  </span><br><span class="line">└─x64</span><br><span class="line">    └─Debug</span><br><span class="line">        │  Project.exe</span><br><span class="line">        │  Project.exe.recipe</span><br><span class="line">        │  Project.ilk</span><br><span class="line">        │  Project.log</span><br><span class="line">        │  Project.pdb</span><br><span class="line">        │  Project.vcxproj.FileListAbsolute.txt</span><br><span class="line">        │  vc143.idb</span><br><span class="line">        │  vc143.pdb</span><br><span class="line">        │  vcpkg.applocal.log</span><br><span class="line">        │  source.obj</span><br><span class="line">        │  </span><br><span class="line">        └─Project.tlog</span><br><span class="line">                CL.command.1.tlog</span><br><span class="line">                CL.read.1.tlog</span><br><span class="line">                CL.write.1.tlog</span><br><span class="line">                link.command.1.tlog</span><br><span class="line">                link.read.1.tlog</span><br><span class="line">                link.write.1.tlog</span><br><span class="line">                Project.lastbuildstate</span><br></pre></td></tr></table></figure></p>
<h3 id="lib-amp-dll-动态链接静态链接"><a href="#lib-amp-dll-动态链接静态链接" class="headerlink" title="lib&amp;dll 动态链接静态链接:"></a>lib&amp;dll 动态链接静态链接:</h3><p>静态库：在链接中，连接器将从静态库文件取得所需的代码，复制到生成的可执行文件中，可执行文件中包含了库代码的一份完整拷贝；缺点是被多次使用就会有多份冗余拷贝。即静态库中的指令都全部被直接包含在最终生成的 EXE 文件中了。在vs中新建生成静态库的工程，编译生成成功后，只产生一个.lib文件</p>
<p>动态库：动态链接库是一个包含可由多个程序同时使用的代码和数据的库，DLL不是可执行文件。动态链接使进程可以调用不属于其可执行代码的函数。函数的可执行代码位于一个 DLL 中，该 DLL 包含一个或多个已被编译、链接并与使用它们的进程分开存储的函数。在vs中新建生成动态库的工程，编译成功后，产生一个.lib文件和一个.dll文件</p>
<p>静态库中的lib包含函数代码本身（包括函数的索引也包括实现），编译时直接将代码加入程序<br>动态库中的lib包含了函数所在的DLL文件和文件中函数位置的信息（索引），函数实现代码由运行时加载在进程空间中的DLL提供</p>
<p>lib是编译时用到的，dll是运行时用到的。如果要完成源代码的编译，只需要lib；如果要使动态链接的程序运行起来，只需要dll。</p>
<p>生成动态库:  </p>
<p>调用动态库:  </p>
<ul>
<li>隐式链接: <ol>
<li>将dll放到工程的工作目录</li>
<li>设置项目属性-&gt;vc++目录-&gt;库目录设为lib所在的路径</li>
<li>将lib添加到项目属性—链接器—输入—附加依赖项（或者直接在源代码中加入#pragma comment(lib, “**.lib”)）<blockquote>
<p><code>#pragma comment(lib,&quot;..\\debug\\TestLib.lib&quot;)</code>;其中的反斜杠要用双反斜杠，因为它是程序解释的双引号包括的字符串，需要转义一下，要区别include，#include “..\TestVideoApplication.h”中并不是由程序解释的字符串，所以不用转义  </p>
</blockquote>
</li>
<li>在源文件中添加.h头文件 (头文件包含lib中说明输出的类或符号原型或数据结构。应用程序调用lib时，需要将该文件包含入应用程序的源文件中)</li>
</ol>
</li>
<li>显示链接:<br>略</li>
</ul>
<p>生成静态库:<br>静态库项目没有main函数 创建项目后添加.h文件，添加相应的导出函数、变量或类  </p>
<p>使用静态库:  </p>
<ol>
<li>设置项目属性-&gt;vc++目录-&gt;库目录为lib所在的路径</li>
<li>将lib添加到项目属性—链接器—输入—附加依赖项（或者直接在源代码中加入#pragma comment(lib, “**.lib”)）</li>
<li>在源文件中添加.h头文件</li>
</ol>
<p>静态链接LIB的优点是免除挂接动态链接库，缺点是EXE大，版本控制麻烦<br>动态链接DLL的优点是文件小，版本更换时换DLL就行，缺点是多了点文件。动态链接若是被多个进程使用，会更加方便和节省内存  </p>
<p><a href="https://www.cnblogs.com/TenosDoIt/p/3203137.html">https://www.cnblogs.com/TenosDoIt/p/3203137.html</a></p>
<h3 id="vs-项目属性页中一些宏定义-选项解释"><a href="#vs-项目属性页中一些宏定义-选项解释" class="headerlink" title="vs 项目属性页中一些宏定义/选项解释:"></a>vs 项目属性页中一些宏定义/选项解释:</h3><ul>
<li><p>调试栏目下的所有选项都是为了调试服务的，如果不用调试按钮，这些选项就不起作用。VC++目录以及C/C++栏目是给编译器起作用的，如告诉编译器在哪里寻找头文件、库文件之类，或者设置其他一些编译器选项  </p>
</li>
<li><p>$(Configuration) / $(ConfigurationName)<br>配置名 release、debug、simulation等   </p>
</li>
<li><p>$(IntDir)<br>编译器使用的中间目录，产出obj文件</p>
</li>
<li><p>$(OutDir)<br>链接器使用的输出目录 产出中间生成的链接器如.ilk和.pdb文件等 值由VS项目的“输出目录”属性决定 “输出目录”是界面上的提示用于接收用户输入的配置信息，然后把这个具体的配置信息存入系统内容的变量$(OutDir)中</p>
</li>
<li><p>$(TargetDir)输出文件所在的目录<br>在生成exe文件后自动赋予值为exe文件所在位置 最终决定exe文件所在的位置  </p>
</li>
<li><p>TargetFileName 目标输出文件名，包括扩展名 TargetName 目标输出名，不包括扩展名  </p>
</li>
<li><p>TargetPath<br>目标输出文件的全路径名 $(TargetDir)和$(TargetPath)的值由VS项目的“输出文件”属性决定(.exe) 输出文件默认 = ​$(OutDir)$(TargetName)$(TargetExt) 默认情况下“输出目录”OutDir和TargetDir两个属性对应的目录是一样的，如果两个不一样，则中间生成的链接器如.ilk和.pdb文件等在输出目录，而最终生成的.exe文件在“输出文件”属性设置的目录中  </p>
</li>
</ul>
<ul>
<li><p>“调试”中的“工作目录”<br>  即工程目录项 这个属性默认情况下是空的，但默认就是工程配置文件.vcproj所在目录  “工作目录”属性作用是程序运行后唯一识别的默认目录，即工作后只认识这个目录 (可以将所依赖的lib和dll库文件所在目录设为工作目录，但一般是把lib放在解决方案下的Lib目录中，把dll放在解决方案下的Bin目录中）  </p>
<p>  程序运行时生成的未指定绝对路径的文件默认就是从工作目录开始的  </p>
<p>  工作目录也是程序运行过程中默认读取的目录。对于dll，如果是程序运行前就进入内存像静态链接，dll就可以放入exe所在的执行目录，如果dll是运行中动态加载的一般放在工作目录，比如插件。工作目录就是运行期间唯一能识别的默认目录，工作目录与执行目录可以不同 生成的exe文件和工作目录无关  </p>
<p>  vs中工作目录的设置是给调试(包括Debug和release)用的，启动调试后，启动一个新进程，自动把这个新进程的工作目录设置为vs项目属性中的工作目录，然后新进程启动对应的exe程序。但是如果不使用vs的调试启动exe，而是直接双击exe文件启动一个新进程时，会自动把这个新进程的工作目录设置为exe文件所在的目录。如果发布的时候不把工作目录内的东西拷到exe所在的目录内，就会运行出错.</p>
</li>
<li><p>“调试”栏目中的“命令（Command）”属性项:<br>  表示调试器要启动的exe文件的位置 $(TargetPath) 一般情况下它代表的值就等于“输出文件”属性代表的值 人为更改后若命令所在目录没找到命令所指则报错  </p>
</li>
<li><p>“链接器”栏目下的“输入”选项下的“附加依赖项”项:<br>  程序链接时使用的静态库。相当于链接已经编译好了的“代码” （这里只需要库名称即可，搜索路径在其他地方设置）<br>  “附加依赖性的设置”等同于在代码中写“#pragma comment(lib, “库名称.lib”) ”语句  </p>
</li>
</ul>
<p>总结:<br>常规-&gt;输出目录 决定outdir决定中间产生的链接器位置, 常规-&gt;中间目录决定indir决定编译的中间文件obj位置<br>调试-&gt;命令决定调试时该去哪找exe文件, 调试-&gt;工作目录决定程序调试运行时找/生成东西的默认路径(单点exe为exe本身路径)<br>VC++-&gt;库目录凡是有带lib就要加lib路径<br>链接器-&gt;常规-&gt;输出文件决定targetpath决定exe位置<br>链接器-&gt;输入-&gt;附加依赖项有lib则加(可代码替代)  </p>
<h3 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h3><p><img src="/Others/env/ex.jpg" alt="ex"><br>Solution: GMA  动态链接库: ChocolateMilk  应用程序: PureMilk  第三方库(动态): log4cxx  </p>
<ul>
<li>GMA解决方案目录  </li>
<li>PureMilk和ChocolateMilk是项目目录(头文件和源文件)  </li>
<li>Lib目录用于存放导入库或者静态库（包括第三方库和自己的项目） </li>
<li>Include用于存放第三方库的头文件（第三方库所有内容分布在Lib、Include和Bin中）  </li>
<li>Bin目录存放所有动态链接库和执行档，包括自己的产出和第三方库，区分Release和Debug两个版本。另外，程序运行过程中需要外部的数据文件和启动时需要的配置文件等等都可放于该目录  </li>
<li>Temp用于存放临时生成文件，其中Compile存放编译器编译时生成的obj文件，Link存放链接器的输出文件。</li>
</ul>
<p>pros:<br>制作安装包时我们只需将“/GMA/Bin/Release/”目录下的所有文件打包<br>发布和转移源码的时候我们可以打包除了Temp目录以外“/GMA/”下面的所有文件和目录（如果不需要执行档，也可不包括Bin）  </p>
<p>项目配置:(首先将配置改成All Configuration（全部配置），可以同时修改Debug和Release的部分)  </p>
<p>设置ChocolateMilk:  </p>
<ol>
<li>Output Directory（输出目录，链接器）栏位填入：<br><code>$(SolutionDir)\Temp\Link\$(ProjectName)\$(ConfigurationName)</code>  </li>
<li>Intermediate Directory（中间目录，编译器）栏位填入：<br><code>$(SolutionDir)\Temp\Compile\$(ProjectName)\$(ConfigurationName)</code>  </li>
<li>构建结束后拷贝动态链接库到“/GMA/Bin/Release/”和“/GMA/Bin/Debug/”，拷贝导入库到“/GMA/Lib/”(若不设置，此时生成的dll和lib都在上面设置的输出目录中)通常都会在Debug版本的输出库后面加上字母“d”以表示这是Debug版本<br> 链接器-&gt;高级-&gt;Import Library导入库填<code>$(TargetDir)$(TargetName)d.lib</code><br> 生成事件-&gt;生成后事件-&gt;命令行填脚本程序移动<br> Debug配置: <code>copy $(TargetPath)    $(SolutionDir)\Bin\$(ConfigurationName)\;</code><br> <code>copy $(TargetDir)$(TargetName)d.lib    $(SolutionDir)\Lib\;</code><br> Release配置: <code>copy $(TargetPath)    $(SolutionDir)\Bin\$(ConfigurationName)\;</code><br> <code>copy $(TargetDir)$(TargetName).lib    $(SolutionDir)\Lib\;</code></li>
</ol>
<p>设置应用程序项目PureMilk:<br>1,2同上  </p>
<ol>
<li>构建结束后拷贝执行文件到“/GMA/Bin/Release/”或“/GMA/Bin/Debug/”<br>在Command Line中填入，All配置下：<code>copy $(TargetPath)    $(SolutionDir)\Bin\$(ConfigurationName);</code>  </li>
<li>调试时运行“/GMA/Bin/Debug/”或“/GMA/Bin/Release/”下面的执行文件，并以“/GMA/Bin/Debug/”或“/GMA/Bin/Release/”为工作目录<br>Command 命令填: <code>$(SolutionDir)\Bin\$(ConfigurationName)\$(TargetFileName)</code><br>Working Directory 工作目录填: <code>$(SolutionDir)\Bin\$(ConfigurationName)\</code>  </li>
</ol>
<p>至此便可编译并调试  </p>
<h3 id="推荐链接lib及dll文件方式"><a href="#推荐链接lib及dll文件方式" class="headerlink" title="推荐链接lib及dll文件方式"></a>推荐链接lib及dll文件方式</h3><p>直接把 dll 所在目录加到 PATH 里，则会有潜在冲突的危险；<br>直接拷贝到 VS 目录下，测试工程太多且有新版本的动态链接库更新时，需要更新若干次，多次拷贝、粘贴  </p>
<ol>
<li><p>直接添加到系统的 PATH 变量里：<br>最简单直接，但会影响全局的 PATH 设置，尤其是包含着大量测试用的 dll 时</p>
</li>
<li><p>在 Visual Studio 全局设置里，把 dll 所在目录添加到 PATH 里：<br>通过 Visual Studio 菜单 ==&gt; 工具 ==&gt; 选项 ==&gt; 项目和解决方案 ==&gt; VC++目录，在下拉框里选择”可执行文件”，然后把 dll 所在路径添加进去 (? 存疑)</p>
</li>
<li><p>直接把所有 dll 拷贝到 Visual Studio 工程目录下，或是拷贝到生成可执行文件的文件夹（默认情况下是 Debug 或 Release 目录）下：<br>很简单，但是当你有若干个工程时，每次更新 SDK 及其 dll 文件，就要把所有的工程都更新，不符合文件唯一性的工程性准则。</p>
</li>
<li><p>在调试程序时，让 Visual Studio 帮你切换当前工作目录到 dll 相应的目录下：<br>在 Visual Studio ==&gt; Project ==&gt; Properties ==&gt; Select Configuration ==&gt; Configuration Properties ==&gt; Debugging ==&gt; Working directory 里填上 dll 所在目录，这样当在调试程序时，Visual Studio 会把当前工作目录切换到这个目录下，从而会自动读取本目录下的 dll 文件。</p>
<p> 简单！但在切换了当前工作目录后，可能会找不到程序的配置文件，在程序里写的诸如”./config.ini”全部都找不到了；另外，要把所有的 dll 都放到这个工作目录里，否则一样会提示说找不到 xxx.dll 的问题。</p>
</li>
<li><p>最后一个方法，认为最好, 在 Visual Studio 工程属性里把一个目录临时添加到 PATH 环境变量里：<br>MSDN 上也有类似的介绍：How to: Set Environment Variables for Projects，方法很简单，在 “工程属性” ==&gt; “调试” ==&gt; “环境”里，添加类似如下所示的内容：<br><code>PATH=%PATH%;$(TargetDir)\DLLS</code>就可以把 <code>$(TargetDir)\DLLS</code> 临时添加到该工程所属的系统 PATH 里。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/waitforfree/article/details/8622059">https://blog.csdn.net/waitforfree/article/details/8622059</a></p>
<p>项目开发的时候，相对路径是以project.vcproj为起点，但是项目在发布后，相对路径变成了以 exe 文件所在的目录为起点  </p>
]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
  <entry>
    <title>VZRenderer</title>
    <url>/Projects/VZRenderer/</url>
    <content><![CDATA[<h1 id="VZRenderer"><a href="#VZRenderer" class="headerlink" title="VZRenderer"></a>VZRenderer</h1><h2 id="tgaimage"><a href="#tgaimage" class="headerlink" title="tgaimage"></a>tgaimage</h2><p>图像相关操作 所有图片均以tga格式存储 用于读取和存储图片(纹理) 其中TGAColor是以BGRA的顺序存储的 范围[0,255] TGAImage主要用set()来写 get()来读  </p>
<h2 id="geometry"><a href="#geometry" class="headerlink" title="geometry"></a>geometry</h2><p>几何 模板实现向量以及矩阵相关的操作 主要注意的点为成员函数与非成员函数的区分  </p>
<h2 id="camera"><a href="#camera" class="headerlink" title="camera"></a>camera</h2><p>摄像机类 存有世界坐标里的相机和目标位置坐标以及 目标的camera坐标系(z为目标指向相机)<br>handle_events() 根据window所存的鼠标以及键盘相关变量来更改camera中所存的坐标 updata_camera_pos() 更新坐标<br>其中还存有ViewMatrix 矩阵以及PerspectiveMatrix矩阵函数  </p>
<ul>
<li><p>ViewMatrix:<br>  将整个场景从相机位置反向平移到原点 （MT），然后以反向方向 （MR） 旋转场景，因此相机位于原点并面向 -Z 轴<br>  MT即camera的位置的负值平移<br>  MR的目的是让目标的camera坐标系和世界坐标系中XYZ重合 旋转矩阵均为正交矩阵 即逆变换=转置 所以先让世界坐标的XYZ和camera坐标系重合再转置即得MR<br>  <img src="/Projects/VZRenderer/viewm.png" alt="viewm"><br>  (l,u,v)即为camera坐标系中xyz  </p>
</li>
<li><p>PerspectiveMatrix:<br>  <img src="/Projects/VZRenderer/perspm.png" alt="perspm"><br>  代码中r为半宽长 = (r-l)/2 t同理 r+l=t+b=0  </p>
<blockquote>
<p>透视投影:<br>个人所见三种透视投影矩阵:  </p>
<ol>
<li>-<br><img src="/Projects/VZRenderer/perspective1.png" alt="perspective1"><br>和正交投影直接去掉z具有相似的问题 不可逆，丢失了 z，没有考虑多个点的重合情况  </li>
<li>-<br><img src="/Projects/VZRenderer/perspective2.png" alt="perspective2"><br> 以上为tinyrenderer中做法 对1进行了改良 增加了一个平移 使得变换后的z仍具有变换之前的单调性和大小关系    </li>
<li>项目中所用 可以剔除自定义近平面远平面以外的  </li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><p>用于模型文件.obj文件的导入与转化 转化为顶点数组verts_ 面数组faces_ 法线数组norms_ uv数组uvs_<br>同时提供相应查找方法查找具体数值<br>存储一个纹理的指针指向模型所要应用的纹理<br>兼容天空盒的读取<br>读取的模型应均为三角面 否则后续裁剪会出问题  </p>
<h2 id="texture"><a href="#texture" class="headerlink" title="texture"></a>texture</h2><p>构造时即可读取模型文件同目录下的所有纹理图片 同时储存 提供纹理对应的采样函数(输入uv返回对应值) 以及为ibl准备的非类成员函数的纹理以及正方形贴图的采样函数<br>相关性质: diffuse normal specualr roughness metalness occlusion emission cubemap  </p>
<ul>
<li><p>纹理采样: <a href="https://zhuanlan.zhihu.com/p/143377682">https://zhuanlan.zhihu.com/p/143377682</a><br>纹理过滤 Texture Filtering (项目中仅采用邻近点  </p>
<ul>
<li>邻近点(Nearest)<br>选取与纹理坐标最接近的像素点颜色  </li>
<li><p>双线性过滤(Bilinear)  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function">vec4 <span class="title">Sample2D</span><span class="params">(vec2 texCoord)</span> </span>&#123;</span><br><span class="line">            texCoord = texCoord * <span class="built_in">vec2</span>(width,height) - <span class="built_in">vec2</span>(<span class="number">0.5f</span>);</span><br><span class="line">            <span class="type">float</span> f = <span class="built_in">fract</span>(texCoord);</span><br><span class="line">            <span class="type">int</span> x = (<span class="type">int</span>)(texCoord.x) % width;</span><br><span class="line">            <span class="type">int</span> y = (<span class="type">int</span>)(texCoord.y) % height;</span><br><span class="line">            x = x &lt; <span class="number">0</span> ? width + x : x;</span><br><span class="line">            y = y &lt; <span class="number">0</span> ? height + y : y;</span><br><span class="line">      vec4 s1 = <span class="built_in">GetColor</span>(x,y);</span><br><span class="line">      vec4 s2 = <span class="built_in">GetColor</span>(x+<span class="number">1</span>,y);</span><br><span class="line">      vec4 s3 = <span class="built_in">GetColor</span>(x,y+<span class="number">1</span>);</span><br><span class="line">      vec4 s4 = <span class="built_in">GetColor</span>(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">lerp</span>(<span class="built_in">lerp</span>(s1, s2, f.x), <span class="built_in">lerp</span>(s3, s4, f.x), f.y);</span><br><span class="line">    &#125;</span><br><span class="line">    ```  </span><br><span class="line"></span><br><span class="line">  - 邻近点/双线性+mipmap  </span><br><span class="line">    预先生成一系列以<span class="number">2</span>为倍数缩小的纹理序列，在采样纹理时根据图形的大小自动选择相近等级的Mipmap进行采样  </span><br><span class="line">    通过计算出纹理坐标在纵向和横向的偏导数（并取最大值）来计算Mipmap级别  </span><br><span class="line">    假设有一个<span class="number">512</span>x512的图片，贴在屏幕空间上呈<span class="number">300</span>x300大小的正方形上。可知相邻像素的UV坐标差值为<span class="number">1</span>/<span class="number">300</span>，乘上纹理尺寸后偏导数约为<span class="number">1.706</span>，delta为<span class="number">2.91271</span>，计算得到MipmapLevel为<span class="number">0.7712</span>，因此最接近的级别为<span class="number">1</span>，也就是<span class="number">256</span>x256这一级  </span><br><span class="line">    ```C++  </span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">MipmapLevel</span><span class="params">(vec2 uv, vec2 texSize)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vec2 s = <span class="built_in">dFdx</span>(uv) * texSize;</span><br><span class="line">        vec2 t = <span class="built_in">dFdy</span>(uv) * texSize;</span><br><span class="line">        <span class="type">float</span> delta = <span class="built_in">max</span>(<span class="built_in">dot</span>(s, s), <span class="built_in">dot</span>(t, t));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">log2</span>(delta);</span><br><span class="line">    &#125;</span><br><span class="line">    ```  </span><br><span class="line">  - 三线性过滤(Trilinear)  </span><br><span class="line">    Mipmap跳变 对于浮点值MipmapLevel，分别在其前后两个整数级别的Mipmap上进行双线性过滤，然后将两个结果再根据MipmapLevel到两个级别的距离进行平均  </span><br><span class="line">  - 各向异性过滤(Anisotropic filtering)  </span><br><span class="line">    原因MipmapLevel是取纹理坐标在xy方向上较大的那个变化率计算得到的 而对于倾斜或者长条状的图形xy方向上的纹理坐标变化率差距很大 会被贴上更低一级的Mipmap，导致模糊  </span><br><span class="line">  - 其他纹理过滤方法  </span><br><span class="line">    pcf  </span><br><span class="line"></span><br><span class="line">* cubemap采样:  </span><br><span class="line">  <span class="built_in">cal_cubemap_uv</span>():  </span><br><span class="line">  <span class="number">1.</span> 设视线与立方体的交点为(x,y,z) 取x,y,z坐标中绝对值最大的为主轴 根据它的符号来判定在哪个面上采样  判定正负轴。例如(<span class="number">0.5</span>, <span class="number">-0.8</span>, <span class="number">0.4</span>)，对应-Y轴。  </span><br><span class="line">  <span class="number">2.</span> 坐标除以主轴的绝对值，映射到[<span class="number">-1</span>,<span class="number">1</span>]区间即换算到立方体上。(<span class="number">0.5</span>, <span class="number">-0.8</span>, <span class="number">0.4</span>) -&gt; (<span class="number">0.625</span>, <span class="number">-1</span>, <span class="number">0.5</span>)。  </span><br><span class="line">  <span class="number">3.</span> 根据对应轴的UV坐标换算关系，求得UV。(<span class="number">0.625</span>, <span class="number">-1</span>, <span class="number">0.5</span>) -&gt; u = x = <span class="number">0.625</span>, v = -z = <span class="number">-0.5</span>  </span><br><span class="line">    ![cubemap](VZRenderer/cubemap.jpg)  </span><br><span class="line">  <span class="number">4.</span> 从[<span class="number">-1</span>, <span class="number">1</span>]缩放到[<span class="number">0</span>, <span class="number">1</span>] (+<span class="number">1</span>/<span class="number">2</span>)  (<span class="number">0.625</span>, <span class="number">-0.5</span>) -&gt; (<span class="number">0.8125</span>, <span class="number">0.25</span>)  </span><br><span class="line">  <span class="number">5.</span> 从-Y轴的贴图上以UV坐标采样  </span><br><span class="line">  https:<span class="comment">//blog.csdn.net/yjr3426619/article/details/81224101  </span></span><br><span class="line">  https:<span class="comment">//zhuanlan.zhihu.com/p/463309766  </span></span><br><span class="line"></span><br><span class="line">  其他可用于environmentmap的贴图:  </span><br><span class="line">  hdr的环境光照图: 类似世界地图的经纬度展开 只需要存储一张  </span><br><span class="line">  ![hdr](VZRenderer/hdr.png)  </span><br><span class="line">  球形贴图(sphere mapping): 计算非常简单，缺点就是只能在一个方向起作用。虽然贴图中包括了整个环境中所有方向的光照，但是如果从其他角度观察，因为在边缘处像素很少，所以会导致严重的失真。因此球形贴图一般只会用于一些观察方向不会改变的场合 实时渲染中，一般很少会直接使用球形贴图来表示环境光照，更多地是用来做Matcap着色  </span><br><span class="line"></span><br><span class="line">#<span class="meta"># shader</span></span><br><span class="line">用于顶点数据的处理vertex_shader以及着色时的计算fragment_shader fragment_shader其实就是在求解渲染方程  </span><br><span class="line">定义<span class="type">payload_t</span>类用于存储shader中所需要与外部交流的数据 成为shader与外界 vertex_shader与fragment_shader间数据交互的桥梁  </span><br><span class="line"></span><br><span class="line">### vertex_shader:</span><br><span class="line">将model中的数据传至payload的中  </span><br><span class="line">主要是进行mvp变换  </span><br><span class="line"></span><br><span class="line">### fragment_shader:</span><br><span class="line">#### PhongShader:  </span><br><span class="line">传入重心坐标的值 根据重心坐标得到插值的世界坐标 法线向量 uv坐标  </span><br><span class="line">透视插值矫正: (使用屏幕空间的重心坐标) https:<span class="comment">//zhuanlan.zhihu.com/p/144331875  </span></span><br><span class="line">![Correct Interpolation](VZRenderer/Correct%<span class="number">20</span>Interpolation.png)  </span><br><span class="line">Z为clip坐标的z分量(mvp变换后) I为任意属性  </span><br><span class="line"></span><br><span class="line">切线空间法线贴图代替模型中存储的法线向量 计算函数<span class="built_in">TBN_normal</span>()  </span><br><span class="line">  求法向量方法:  </span><br><span class="line">  <span class="number">1.</span> 三条边叉乘得面的法向量(Flat Shading) 法向量再得光强  </span><br><span class="line">  <span class="number">2.</span> obj中的vn为顶点法向量 得到顶点的光强后再插值(Gouraud Shading 能够表现的细节不够 插值不能做到三角面内部添加凹陷 开销大)  </span><br><span class="line">  <span class="number">3.</span> 法线贴图 把模型表面的法向量都存储 (Phong Shading 有更多细节，在同一个三角面也能表现出凹凸感) 插值计算uv坐标再访问法线贴图得法向量 这种法线贴图存的是[<span class="number">0</span>,<span class="number">255</span>]的rgb表示 打开图片为彩色的  </span><br><span class="line">  <span class="number">4.</span> 切线空间中法线贴图 可适用于模型只有部分变换时 各部分法向量分开计算 贴图里存储相对法向量(相对于单个三角面而不是模型空间) 图片基本为蓝色(大部分情况下垂直于平面) 蓝色<span class="built_in">RGB</span>(<span class="number">127</span>,<span class="number">127</span>,<span class="number">255</span>)时相对三角面(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>) 贴图存储的x,y,z分量对应的方向是法线贴图的横轴，法线贴图的竖轴，垂直于平面的方向  </span><br><span class="line">  &gt; TBN坐标系 切线空间  </span><br><span class="line">  &gt; 切线空间是针对三角面的每个顶点而言的  </span><br><span class="line">  &gt; 计算方法:  </span><br><span class="line">  &gt; <span class="number">1.</span>计算出TBN坐标系中的t, b  </span><br><span class="line">  &gt; 先由世界坐标取AB,AC uv坐标取uAB vAB uAC vAC 由定义可得  </span><br><span class="line">  &gt; ![TBN](VZRenderer/TBN.jpg)    </span><br><span class="line">  &gt; 求出后还需要通过正交化(schmidt orthogonalization)  </span><br><span class="line">  &gt; ![schmidt](VZRenderer/schmidt.jpg)   </span><br><span class="line">  &gt; <span class="number">2.</span>通过插值得到点在法线贴图中的uv坐标读取相应<span class="built_in">xyz</span>(切线空间) 用TBN和它左乘归一化得出世界坐标中的法向量  </span><br><span class="line"></span><br><span class="line">Blinn-Phong  </span><br><span class="line">自定义light属性  </span><br><span class="line">kd由diffuse纹理读出 计算l,v,h,n向量 分别求出ambient diffuse specular 再输出(输出*<span class="number">255</span>)即可  </span><br><span class="line"></span><br><span class="line">#### SkyboxShader:  </span><br><span class="line">同上插值得世界坐标 在用cubemap采样得color  </span><br><span class="line"></span><br><span class="line">#### PbrShader</span><br><span class="line">https:<span class="comment">//learnopengl-cn.github.io/07%20PBR/01%20Theory/  </span></span><br><span class="line"></span><br><span class="line">- 独立光源情况:  </span><br><span class="line">    自定义光源属性 同上插值得世界坐标 uv坐标 法线贴图得法线向量 用uv对model中所存贴图采样得roughness metalness ao albedo emission  </span><br><span class="line">    求解渲染方程:  </span><br><span class="line">    对独立的光源 渲染方程不需要对角度积分 每个射过来的光源角度都已知 直接累加即可  </span><br><span class="line">    遍历每个光源求总Lo:  </span><br><span class="line">    brdf中每项均采用一种近似方法求得 D使用Trowbridge-Reitz GGX，F使用Fresnel-Schlick近似，G使用Smith’s Schlick-GGX  </span><br><span class="line">    ![directbrdf](VZRenderer/directbrdf.png)  </span><br><span class="line">    c为表面颜色即diffusemap采样所得 alpha为roughness或其平方 ks即为F kd为(<span class="number">1</span>-ks)*(<span class="number">1</span>-metalness)金属不会折射  </span><br><span class="line">    得到Lo后再加上环境光(ka\*albedo\*<span class="built_in">ao</span>(albedo为表面颜色 ao为ao贴图))  </span><br><span class="line"></span><br><span class="line">- ibl情况:  </span><br><span class="line">    同上得世界坐标 uv坐标 法线向量 roughness metalness ao albedo emission   </span><br><span class="line">    同上求F项(不同处为加上了roughness) 进而求出ks kd  </span><br><span class="line">    diffuse part: 通过法线n对payload中存储的irradiance_map采样得irradiance  diffuse = irradiance * Kd * albedo  </span><br><span class="line">    specular part: 通过(ndotv, roughness)对payload中存储的lut采样得scale和bias 配合上述的F0求得brdf项 由payload中存的最大miplevel和roughness算出所需的mipmaplevel 在对payload中存有的对应level的prefiltermap用l采样得L  specular = L*<span class="built_in">brdf</span> (此处可用插值优化)  </span><br><span class="line">    最终color = diffuse + specular + emission  </span><br><span class="line"></span><br><span class="line">- 最后得到的color要经过ACES ToneMapping 以及 Gamma Correction处理  </span><br><span class="line">    Tone Mapping和Gamma Correction:  </span><br><span class="line">    二者都是为了更好的在LDR设备上显示图片， 将图片的颜色值从一个范围分布变换到另一个范围分布。 而不同的是，Tone Mapping是根据相应的算法将颜色值从一个大的范围映射到了较小的范围， 而Gamma Correction则是从[<span class="number">0</span>,<span class="number">1</span>]映射到[<span class="number">0</span>,<span class="number">1</span>], 映射范围并没有改变，只是改变了不同亮度值颜色的分布情况(人眼对暗色变化敏感 暗色区域应该大)  </span><br><span class="line">    https:<span class="comment">//zhuanlan.zhihu.com/p/66558476  </span></span><br><span class="line">    https:<span class="comment">//moontree.github.io/2020/08/30/tone-mapping/  </span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#<span class="meta"># ibl</span></span><br><span class="line">把对角度的积分(即对图的采样)改为预计算 (在半球内均匀间隔或随机取方向可以获得一个相当精确的辐照度近似值但仍需要大量样本)  </span><br><span class="line"></span><br><span class="line">##<span class="meta"># diffuse part</span></span><br><span class="line">![diffusebrdf](VZRenderer/diffusebrdf.png)  </span><br><span class="line"></span><br><span class="line">漫反射的计算结果仅与表面基础反射率Albedo/c和辐射照度Irradiance有关  </span><br><span class="line">&gt; 假设位置p位于辐照度图的中心 意味着所有着色点都被认为处在坐标原点的位置 所有漫反射间接光只能来自同一个环境贴图 反射探针可解决 每个反射探针单独预计算其周围环境的辐照度图 位置p处的辐照度取离其最近的反射探针之间的辐照度插值  </span><br><span class="line"></span><br><span class="line">由于位置不变(中心) Irradiance可被表示为以法线方向为变量的函数 预计算一个新的立方体贴图  </span><br><span class="line"></span><br><span class="line">IrradianceMap每一个像素点对应的采样向量即为表面法线，像素颜色为表面Irradiance  </span><br><span class="line"></span><br><span class="line">Irradiance求解方法:  </span><br><span class="line"><span class="number">1.</span> 均匀采样 黎曼和(项目中所用)  </span><br><span class="line">    ![Riemann sum](VZRenderer/Riemann%<span class="number">20</span>sum.png)  </span><br><span class="line">    &gt; 为保证均匀采样 系数 <span class="built_in">sin</span>(θ) 用于权衡较高半球区域的较小采样区域的贡献度  </span><br><span class="line"></span><br><span class="line">    <span class="number">1.</span> 遍历定义的irradiancemap中每个像素(x,y) <span class="built_in">set_normal_coord</span>()求过该像素的法线 从而求出TBN  </span><br><span class="line">    <span class="number">2.</span> 对以该像素为中心朝法线方向的半球 对半球Ω上以sampleDelta的增量对<span class="number">2</span>pi和<span class="number">0.5</span>pi的半球面两层循环进行离散采样 均匀地在积分半球Ω产生采样向量sampleVec sampleVec即为入射光线l  </span><br><span class="line">    <span class="number">3.</span> 将得到的采样方向从球面坐标转切线空间<span class="number">3</span>D直角坐标 再由之前的TBN求得世界坐标中的采样方向  </span><br><span class="line">    <span class="number">4.</span> 用l在cubemap上进行texture查询得<span class="built_in">color</span>(即式中L) 乘以系数后将所有平均得到(x,y)处的 irradiance 存入map中  </span><br><span class="line">    <span class="number">5.</span> 遍历六个面得到六个irradiancemap  </span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 蒙特卡洛积分  </span><br><span class="line">    ![monte](VZRenderer/monte.png)  </span><br><span class="line">    关键在于N个随机采样点的生成 由于球面性质 随机均匀分布的theta和phi在球面上并不均匀  </span><br><span class="line">    $d\omega = rd\theta * r\sin\theta d\phi$  </span><br><span class="line">    &gt; 逆变换采样(Inverse Transform Sampling) 用<span class="number">0</span>~<span class="number">1</span>间均匀分布的随机变量来获得符合其他任何分布的随机变量  </span><br><span class="line">    &gt; ![Inverse Transform Sampling](VZRenderer/Inverse%<span class="number">20</span>Transform%<span class="number">20</span>Sampling.png)  </span><br><span class="line"></span><br><span class="line">    利用逆变换采样得到的N对采样点去采样平均即得  </span><br><span class="line"></span><br><span class="line">可用球谐函数替代Irradiance <span class="built_in">Map</span>(略) https:<span class="comment">//zhuanlan.zhihu.com/p/144910975  </span></span><br><span class="line"></span><br><span class="line">参考: https:<span class="comment">//zhuanlan.zhihu.com/p/463309766  </span></span><br><span class="line">      https:<span class="comment">//zhuanlan.zhihu.com/p/49746076  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##<span class="meta"># specular part</span></span><br><span class="line">分割求和近似法（split sum approximation）将方程的镜面部分分割成两个独立的部分，单独求卷积，然后在 PBR 着色器中求和  </span><br><span class="line"></span><br><span class="line">##<span class="meta"># prefiltermap</span></span><br><span class="line">第一部分预滤波环境贴图prefiltermap 类似辐照度图 考虑粗糙度 按粗糙度级别把模糊后的结果存储在预滤波贴图的 mipmap 中  </span><br><span class="line">![prefiltermap](VZRenderer/prefiltermap.png)  </span><br><span class="line"></span><br><span class="line">已知N与V 通过GGX重要性采样获取半程向量H 则可计算采样方向L  </span><br><span class="line"></span><br><span class="line">&gt; 重要性采样:  </span><br><span class="line">&gt; 有偏(样本并不完全随机 集中于特定方向)的蒙特卡洛估算具有更快的收敛速度  </span><br><span class="line">&gt; 拟蒙特卡洛积分: 使用低差异序列生成蒙特卡洛随机样本向量 样本分布更均匀 具有更快的收敛速度  </span><br><span class="line"></span><br><span class="line">大多数光线最终会反射到一个基于半向量的镜面波瓣内 波瓣的大小取决于表面的粗糙度 因此将样本集中在镜面波瓣内 因此将拟蒙特卡洛采样与低差异序列(Hammersley序列)相结合，并使用GGX重要性采样使用NDF定向和偏移采样向量，可以获得很高的收敛速度  </span><br><span class="line"></span><br><span class="line">由h向量的<span class="built_in">pdf</span>(NDF所得)逆变换采样(见上文)得h向量的采样点 和 wo向量的pdf求取方法:  </span><br><span class="line">![pdf](VZRenderer/pdf.png)  </span><br><span class="line">h的pdf转wo的pdf: https:<span class="comment">//www.graphics.cornell.edu/~bjw/wardnotes.pdf  </span></span><br><span class="line"></span><br><span class="line">generate_prefilter_map:  </span><br><span class="line"><span class="number">1.</span> 首先根据roughness的不同决定mipmap的level进而决定mipmap大小</span><br><span class="line"><span class="number">2.</span> 遍历prefiltermap的中每个像素(x,y) <span class="built_in">set_normal_coord</span>()求过该像素的法线 从而求出TBN以及r与<span class="built_in">v</span>(先前假设v=r=n)  </span><br><span class="line"><span class="number">3.</span> 开始一个大循环，生成一个随机序列值(相当于diffuse中两个均匀分布的随机值$\xi_1 \xi_2$)，用该序列值在ImportanceSampleGGX中由上述求出的公式得到符合NDF的pdf分布的$\theta 和\phi$ 即得球面坐标中h的样本向量  </span><br><span class="line"><span class="number">4.</span> 将得到的样本向量从球面坐标转切线空间<span class="number">3</span>D直角坐标 再由之前的TBN求得世界坐标中的样本向量(注意此时的样本向量为h)  </span><br><span class="line"><span class="number">5.</span> 用v和样本向量h得到样本向量l 对场景的cubemap采样 查询后的color乘系数累加后(同时也要对$n\cdot l$累加(公式中的分母)) 分母分子相除存入map中</span><br><span class="line"><span class="number">6.</span> 对十个mipmaplevel对应<span class="built_in">roughnes</span>(<span class="number">0</span>~<span class="number">9</span>)/<span class="number">9</span>分别制作六个面的<span class="built_in">prefiltermap</span>(<span class="number">60</span>张)</span><br><span class="line"></span><br><span class="line">Reference:  </span><br><span class="line">https:<span class="comment">//www.blurredcode.com/2021/05/dec701b2/#fn:wardnotes  </span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/66518450  </span></span><br><span class="line">https:<span class="comment">//learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/  </span></span><br><span class="line">各项异性GGX分布坐标推导: https:<span class="comment">//blog.csdn.net/air_liang1212/article/details/106215259  </span></span><br><span class="line"></span><br><span class="line">#### BRDF 积分贴图 lut</span><br><span class="line">![brdflut](VZRenderer/brdflut.png)  </span><br><span class="line">通过重要性采样获取H，已知V可以算出L  </span><br><span class="line">scale 和 bias可以打表，只与$n \cdot v$和$\alpha$有关,因此可以打表为二维纹理 scale 放在红色通道， bias 放在绿色通道  </span><br><span class="line"></span><br><span class="line">![ibl](VZRenderer/ibl.png)  </span><br><span class="line"></span><br><span class="line">PBR&amp;IBL Reference:  </span><br><span class="line">https:<span class="comment">//www.blurredcode.com/2021/05/dec701b2/#fn:wardnotes  </span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/66518450  </span></span><br><span class="line">https:<span class="comment">//learnopengl-cn.github.io/07%20PBR/01%20Theory/  </span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/61962884  </span></span><br><span class="line">https:<span class="comment">//zhuanlan.zhihu.com/p/162793239  </span></span><br><span class="line">https:<span class="comment">//juejin.cn/post/6994946774641147941  </span></span><br><span class="line"></span><br><span class="line">#<span class="meta"># pipeline</span></span><br><span class="line"></span><br><span class="line">### drawLine&amp;Triangle</span><br><span class="line"></span><br><span class="line">drawLine:  </span><br><span class="line"></span><br><span class="line">Bresenham’s line algorithm  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>循环中采用真实长度的步长比例: 效率低  </span><br><span class="line"></span><br><span class="line">用x做循环控制变量: 不能处理x1&lt;x0情况 k&gt;<span class="number">1</span>情况不连续 swap解决  </span><br><span class="line"></span><br><span class="line">优化: 增量算法 且对增量d*<span class="number">2</span>摆脱浮点数  </span><br></pre></td></tr></table></figure>
<p>d += std::abs(y1-y0/float(x1-x0));<br>if (d&gt;0.5) { </p>
<pre><code>y += (y1&gt;y0?1:-1); 
d -= 1; 
</code></pre><p>} </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">画线框 遍历obj的每个面以及面中的顶点 画线  </span><br><span class="line"></span><br><span class="line">drawTriangle:  </span><br><span class="line">- 方法一 用线扫描  </span><br></pre></td></tr></table></figure>
<p>void drawTriangle(Vec2i v0, Vec2i v1, Vec2i v2, TGAImage&amp; image, TGAColor color) {</p>
<pre><code>if (v0.y == v1.y &amp;&amp; v0.y == v2.y) return;
if (v0.y &gt; v1.y) std::swap(v0, v1);
if (v0.y &gt; v2.y) std::swap(v0, v2);
if (v1.y &gt; v2.y) std::swap(v1, v2);
int height = v2.y - v0.y;
for (int i = v0.y; i &lt; v2.y; i++) &#123;
    bool isPassHalf = (i &gt;= v1.y);
    float alpha = (float)(i - v0.y) / (v2.y - v0.y);
    Vec2i p1 = v0 + (v2 - v0) * alpha;
    float beta = isPassHalf ? (float(i - v1.y) / (v2.y - v1.y)) : (float(i - v0.y) / (v1.y - v0.y));
    Vec2i p2 = isPassHalf ? (v1 + (v2 - v1) * beta) : (v0 + (v1 - v0) * beta);
    if (p1.x &gt; p2.x) std::swap(p1, p2);
    for (int j = p1.x; j &lt;= p2.x; j++)
        image.set(j, i, color);
&#125;
</code></pre><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 方法二 包围盒扫描  </span><br></pre></td></tr></table></figure>
<p>Vec3f barycentric(Vec2i* pts, Vec2i p) {</p>
<pre><code>Vec3f b = Vec3f(pts[1].x - pts[0].x, pts[2].x - pts[0].x, pts[0].x - p.x) ^ Vec3f(pts[1].y - pts[0].y, pts[2].y- pts[0].y, pts[0].y - p.y);
if (std::abs(b.z) &lt; 1) return Vec3f(-1, 1, 1);// 点在边上
return Vec3f(1.f - (b.x + b.y) / b.z, b.x / b.z, b.y / b.z);
</code></pre><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ![barycentric](VZRenderer/barycentric.png)  </span><br><span class="line"></span><br><span class="line">  求出重心坐标  </span><br><span class="line">  在求出的包围盒内枚举每个像素 根据重心坐标(x,y,z均&gt;0) 判断在三角形内 再着色  </span><br><span class="line"></span><br><span class="line">### 渲染管线</span><br><span class="line">![coordinate](VZRenderer/coordinate.jpg)  </span><br><span class="line"></span><br><span class="line">对一个三角面:  </span><br><span class="line">World Space =&gt; (Vertex Shader 进行MVP变换) =&gt; Clip Space =&gt; (透视除法 剪裁空间中做了剔除再除法) =&gt; NDC =&gt; (视口变换) =&gt; Screen Space =&gt; (Fragment Shader着色) =&gt; 屏幕/FrameBuffer  </span><br><span class="line"></span><br><span class="line">渲染管线:</span><br><span class="line">- 应用阶段（Application Stage）:  </span><br><span class="line">  `CPU负责 可见性判断(和后面齐次空间裁剪区别在于粒度的不同, 此时是物体层面的剔除包括视锥体剔除（Frustum Culling）和遮挡剔除（ Occlusion Culling）, 后面为三角面层面的剔除)、控制着色器参数和渲染状态、提交图元至GPU硬件以供渲染(提交Draw Call 可批处理)`</span><br><span class="line"></span><br><span class="line">- 几何阶段（Geometry Stage）:  </span><br><span class="line">  顶点着色器（Vertex Shaders）  </span><br><span class="line">  `顶点坐标变换 MVP 顶点的着色计算 平面着色 (Flat Shading)和高洛德着色 (Gouraud Shading)`</span><br><span class="line"></span><br><span class="line">  曲面细分着色器（Tessellation Stage）  </span><br><span class="line">  `加入更多的顶点 贴图置换（Displacement Mapping）`</span><br><span class="line"></span><br><span class="line">  几何着色器（Geometry Shader）</span><br><span class="line">  `控制GPU对顶点进行增删改操作`</span><br><span class="line"></span><br><span class="line">  齐次空间裁剪  </span><br><span class="line">  视椎体裁剪 `把完全不在视椎内的图元全部干掉`  </span><br><span class="line">  视口剔除 `把刚好在坐落于视椎体边上的图元进行裁剪，将多边形分成三角形继续`  </span><br><span class="line">  面剔除 `放到屏幕映射之后做`  </span><br><span class="line"></span><br><span class="line">  透视除法  </span><br><span class="line">  `裁剪空间至NDC (NDC时z分量已无)`</span><br><span class="line"></span><br><span class="line">  屏幕映射（Screen Mapping）  </span><br><span class="line"></span><br><span class="line">  背面剔除  </span><br><span class="line"></span><br><span class="line">- 光栅化阶段（Rasterization Stage）  </span><br><span class="line">  图元组装（Primitive Assembly）  </span><br><span class="line">  `把顶点连线(画线框) 计算三角形的重要数据(三条边的方程、深度值)供三角形遍历阶段使用，同样可用于各种着色数据的插值`  </span><br><span class="line">  三角形遍历（Triangle Traversal）  </span><br><span class="line">  `遍历包围盒中所有像素判断是否在三角面内 并对这些像素的属性值进行插值`  </span><br><span class="line">  `抗锯齿（Anti-aliasing）就在此时 项目中中心点被覆盖即被划入片元 无抗锯齿`  </span><br><span class="line"></span><br><span class="line">- 像素处理阶段(Pixel Processing Stage)  </span><br><span class="line">  深度测试提前（Early-Z）)   </span><br><span class="line">  `与透明度测试冲突`  </span><br><span class="line">  片元着色器（Fragment Shader）  </span><br><span class="line">  `计算像素颜色 结合texture`  </span><br><span class="line">  裁剪测试（Scissor Test）  </span><br><span class="line">  透明度测试（Alpha Test）  </span><br><span class="line">  模板测试（Stencil Test）  </span><br><span class="line">  深度测试（Depth Test）  </span><br><span class="line">  混合（Blend）  </span><br><span class="line">  `根据色彩 不透明度`  </span><br><span class="line"></span><br><span class="line">- 片元颜色送到颜色缓冲区   </span><br><span class="line">  双缓冲  </span><br><span class="line">  `屏幕上显示前置缓冲（Front Buffer），而渲染好的颜色先被送入后置缓冲（Back Buffer），再替换前置缓冲，以此避免在屏幕上显示正在光栅化的图元`</span><br><span class="line"></span><br><span class="line">#### Vertex Shader</span><br><span class="line">主要进行mvp变换 Clip Space是一个顶点乘以MVP矩阵之后所在的空间，Vertex Shader的输出就是在Clip Space上 以及将相关数据存入shader的payload中  </span><br><span class="line"></span><br><span class="line">透视变换矩阵把顶点从视锥体中变换到裁剪空间中 裁剪完成后进行透视除法  </span><br><span class="line"></span><br><span class="line">#### 齐次空间裁剪</span><br><span class="line">齐次空间裁剪是一个流程，其中主要包括视椎体裁剪，视口剔除，面剔除  </span><br><span class="line">homo_clipping()对七个面(包括w 裁剪掉w小于等于0的)进行plane_clipping()  </span><br><span class="line">判断顶点和平面的位置关系:  </span><br><span class="line">    1. 当前顶点和上一个顶点不在平面的一边 则与平面有交点 求出边与平面的交点，即插值系数t 将新的顶点存入</span><br><span class="line">    ![clip](VZRenderer/clip.png)  </span><br><span class="line">    2. 顶点在裁剪空间内部的则保留  </span><br><span class="line">    3. 顶点不在空间内部的则舍弃  </span><br><span class="line">最终返回该三角面经裁剪后的顶点数(一般为0, 3或4)  </span><br><span class="line">若为4个则分成将4个顶点分成两个三角面分别进行后续光栅化rasterize() 3个则照常  </span><br><span class="line"></span><br><span class="line">#### 透视除法</span><br><span class="line">将Clip Space顶点的4个分量都除以w分量，就从Clip Space转换到了NDC NDC是一个长宽高取值范围为[-1,1]的立方体，超过这个范围的顶点，会被GPU剪裁 透视除法只对顶点的position属性 其他属性就是线性插值   </span><br><span class="line"></span><br><span class="line">#### viewport</span><br><span class="line">将screen_coords进行视图变换 (screen_coords的z项存取-clip_coords[i].w clip space中坐标w存的是View Space(摄像机的视角)的Z (由投影矩阵可知) 按理来说做完透视除法后w坐标无用了 相当于screen中存的是-z 天空盒存一正大值)  </span><br><span class="line"></span><br><span class="line">#### Back-face culling 背面剔除</span><br><span class="line">点乘结果为负说明光线来自多边形后面 简单丢弃该三角形  </span><br><span class="line">背面剔除 (视口变换后 用ndc坐标)  </span><br><span class="line">对所有多边形进行顺时针编号, 即v1 v2 v3 ….. vz  </span><br><span class="line">计算法线向量, 即N1 N1 =（v2-v1）*（v3-v2）   </span><br><span class="line">考虑投影仪P, 它是任何顶点的投影计算点积Dot = N.P  </span><br><span class="line">测试并绘制表面是否可见。如果Dot≥0, 则表面可见, 否则不可见  </span><br><span class="line"></span><br><span class="line">#### bounding box</span><br><span class="line">根据screen_coords的x,y设计一个三角面的包围盒 着色时仅在包围盒中进行  </span><br><span class="line"></span><br><span class="line">#### shading</span><br><span class="line">对包围盒中所有x,y 根据screencoords求出在三角面中的重心坐标$(\alpha, \beta, \gamma)$ 根据重心坐标是否均大于等于0判断在三角面内  </span><br><span class="line">在则求出z值(根据screen的z坐标)且透视矫正 和zbuffer比较 较小则覆盖  </span><br><span class="line">将重心坐标传入fragmentshader得到(x,y)处的color 存入framebuffer即可  </span><br><span class="line"></span><br><span class="line">光栅化中值得注意的几种情况:  </span><br><span class="line">1. transformation时的法向量变换: transformation中非等比缩放时的法线变换矩阵(求逆再转置)(其实都是求逆再转置 只不过旋转平移等变换的逆矩阵等于转置矩阵 而等比缩放对法向量乘上一个缩放系数的倒数即可(归一化)) 只需要求Model和View的逆转置即可</span><br><span class="line">2. screen space下插值与view space下插值的误差矫正 任何需要插值的属性经过透视投影后都要矫正 不同类型的插值如线性插值和重心坐标插值利用相似的公式 https://zhuanlan.zhihu.com/p/144331875</span><br><span class="line">3. 齐次空间透视裁剪 见代码 https://zhuanlan.zhihu.com/p/162190576</span><br><span class="line"></span><br><span class="line">## scene</span><br></pre></td></tr></table></figure>
<p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存<br>指针参数p的副本是 _p _p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变<br>非得要用指针参数去申请内存，那么应该改用“指向指针的指针”<br>做形参时传入二级指针的地址 如果改变该二级指针地址（<em>*p），对该指针的操作也将无效，但是改变二级指针的内容（例如</em>p），则该二级指针可以正常返回<br>```</p>
</li>
</ul>
</li>
</ul>
<p>用于场景的搭建<br>model以及shader都是在函数中分配的内存<br>载入ibl相关的预计算map至shader中  </p>
<h2 id="win"><a href="#win" class="headerlink" title="win"></a>win</h2><p>利用win32 api 创建窗口且提供将framebuffer画至窗口功能 实现简单ui 同时提供获取鼠标位置的输入为camera使用<br>msg_dispatch()  提供更新传递信息功能 即传递鼠标键盘等操作 调用它才能更新window中所存属性<br>window-&gt;is_close 整个进程的开关 window-&gt;is_start 渲染的开关  </p>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>创建窗口,camera以及相关buffer<br>进入窗口循环 不断检查scene是否选择<br>若scene已赋值则加载scene start进入render循环<br>循环中更新相机参数 计算mvp矩阵赋给shader 对model中存有的每个面调用draw()<br>将framebuffer中的数据画在窗口<br>stop后返回窗口循环  </p>
<ul>
<li>未解决Bug:<br>cerberus 模型变换缩小模型时镜头拉近会变黑<br>helmet 镜面ibl中有黑线  </li>
</ul>
]]></content>
      <categories>
        <category>Projects</category>
      </categories>
  </entry>
  <entry>
    <title>Algorithm</title>
    <url>/Q&amp;A/Algorithm/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><p>排序 Leetcode31</p>
<p>两个栈实现队列</p>
<p>TopK问题</p>
<p>1000个小球装箱子问题</p>
<p>判断是否为完全二叉树</p>
<p>有一个圆，随机取n个点，求这n个点位于同一半圆的概率</p>
<p>区间合并。（LeetCode中等水平）</p>
<p>一个数组里面取前k个最小的元素，有哪些方案？</p>
<p>如何判断一个满二叉树？</p>
<p>线段树</p>
<p>重建满二叉树</p>
<p>LRU 力扣146题</p>
<p>奇数放前面，偶数放后面 剑指offer21题</p>
<p>贪心发糖问题 力扣135题</p>
<p>排序二维数组高效查找，要求用二分和Z字查找都写一遍 </p>
<p>剑指offer04题</p>
<p>力扣热题 岛屿数量问题 力扣200题</p>
<p>岛屿问题进阶，如果要搭桥把所有岛屿连接起来，求出岛屿占据的最少像素数（bfs+连通域间最短距离+图论最短路径）</p>
<p>编辑距离 力扣72题</p>
<p>带括号的加减乘除</p>
<p>带去重的归并排序</p>
<p>三个点落在同一个半圆的概率</p>
<p>0-4随机数生成0-6随机数</p>
<p>找到二叉树中的最大子搜索二叉树</p>
<p>A*寻路</p>
]]></content>
      <categories>
        <category>Q&amp;A</category>
      </categories>
  </entry>
  <entry>
    <title>C++</title>
    <url>/Q&amp;A/C++/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="数组、链表、哈希表的区别-哈希表的扩容方法"><a href="#数组、链表、哈希表的区别-哈希表的扩容方法" class="headerlink" title="数组、链表、哈希表的区别 哈希表的扩容方法"></a>数组、链表、哈希表的区别 哈希表的扩容方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组 元素在内存中连续存放，存储区间是连续的 必须事先定义固定的长度，不能适应数据动态的增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费 数组从栈中分配空间 自由度小 数据查询时，可以直接通过下标迅速访问数组中的元素 增加或删除元素时，在数组中增加一个元素，需要移动大量元素，在内存中空出一个元素的空间，然后将要增加的元素放在其中。同样，如果想删除一个元素，需要移动大量去填掉被移动的元素</span><br><span class="line"></span><br><span class="line">链表 存储区间离散，占用内存比较宽松。通过存在元素中的指针联系到一起 链表动态地进行存储分配，可以适应数据动态地增减的情况。链表从堆中分配空间，自由度大但是申请管理比较麻烦 ​数据查询时，需要从第一个元素开始一直找到需要的元素位置 增加或删除元素时，链表只需改动元素中的指针即可实现增加或删除元素。</span><br><span class="line"></span><br><span class="line">哈希表 散列法​​​​​​​，是数组和链表的结合体 既能具备数组的快速查询的优点，又能融合链表方便快捷的增加删除元素的优势 不相同的数据通过hash函数得到相同的key值。这时候，就产生了hash冲突。解决hash冲突的方式有两种。一种是挂链式，也叫拉链法。挂链式的思想在产生冲突的hash地址指向一个链表，将具有相同的key值的数据存放到链表中。另一种是建立一个公共溢出区。将所有产生冲突的数据都存放到公共溢出区，也可以使问题解决。</span><br></pre></td></tr></table></figure>
<p>链表能否进行二叉搜索？  </p>
<p>vector的扩容，哈希表扩容  </p>
<p>vector里加入10万数据，游戏中有对象的指针指向这些数据，这可能有什么问题</p>
<p>vector如何快速删除内部对象。（要求O(1)时间复杂度）</p>
<p>给定一个链表的头节点和要删除的节点，如何O(1)复杂度搞定删除？</p>
<p>刚刚我们聊过vector的扩容，那vector怎么减容？pop_back之后，vector会自动减容嘛？如果不会减容，那我们怎么释放不必要的内存呢？C++是否提供了我们什么接口呢？<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不会自动减容</span><br><span class="line"></span><br><span class="line">减容:</span><br><span class="line">vector&lt;int&gt; v1;//经过大起大落、删删减减之后，原先有上万条内容，现在只剩下寥寥数十条 它的size不大，但是capcity由于只是删除元素，仍然保持者上万条的规模</span><br><span class="line">vector&lt;int&gt;v2(v1);//v2中保存的是v1中的副本，但是v2是按需构建的，也就是说v2的size和它的capcity是比较相配的。</span><br><span class="line">v1.swap(v2)//这样一来v1和v2不仅交换了内容（其实两者的内容是完全一模一样的），而且把capcity都交换了</span><br><span class="line"></span><br><span class="line">reserve()只修改capacity大小，不修改size大小</span><br><span class="line">resize()既修改capacity大小，也修改size大小</span><br></pre></td></tr></table></figure></p>
<p>从cpu和内存来理解为什么数组比链表查询快<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU缓存会把一片连续的内存空间读入， 因为数组结构是连续的内存地址 链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存 程序中尽量使用连续的数据结构，这样可以充分发挥CPU缓存的威力。 这种对缓存友好的算法称为 Cache-oblivious algorithm</span><br><span class="line"></span><br><span class="line">数组按行读比按列读快: 因为数组是按照一行一行的方式连续存放在内存中的，按照行列的方式去遍历数组，会大大提高cache命中率，从而提高读写速度</span><br></pre></td></tr></table></figure></p>
<h2 id="介绍c-stl，介绍vector和list的底层实现，介绍map的底层实现"><a href="#介绍c-stl，介绍vector和list的底层实现，介绍map的底层实现" class="headerlink" title="介绍c++stl，介绍vector和list的底层实现，介绍map的底层实现"></a>介绍c++stl，介绍vector和list的底层实现，介绍map的底层实现</h2><h2 id="list-vector-deque实现"><a href="#list-vector-deque实现" class="headerlink" title="list/vector/deque实现"></a>list/vector/deque实现</h2><h2 id="map-unordered-map实现"><a href="#map-unordered-map实现" class="headerlink" title="map/unordered_map实现"></a>map/unordered_map实现</h2><p>常见容器都说一遍，插入查找算法复杂度</p>
<h2 id="AVL树-红黑树"><a href="#AVL树-红黑树" class="headerlink" title="AVL树/红黑树"></a>AVL树/红黑树</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两者均为平衡二叉搜索树</span><br><span class="line">AVL树是高度平衡二叉搜索树。AVL树检查左侧和右侧子树的高度，并确保差异不大于1</span><br><span class="line">如果左子树和右子树的高度差异大于1，则使用一些旋转技术来平衡。为了平衡自身，AVL树可以执行一下四种旋转：左旋 右旋 左右旋 右左旋</span><br><span class="line"></span><br><span class="line">红黑树是一种特殊的二叉搜索树，其中每个树的节点存储一种颜色，红色或黑色。红黑树是一种自平衡二叉搜索树，其中插入或删除操作是智能完成的，以确保树始终是平衡的。红黑树中任何操作（例如搜索、插入或删除）的时间复杂度都是O(log n)，其中n是红黑树中的节点数</span><br><span class="line"></span><br><span class="line">1. 节点要么是红色，要么是黑色。</span><br><span class="line">2. 根节点是黑色。</span><br><span class="line">3. 每个叶子节点（NIL节点，空节点）是黑色的。</span><br><span class="line">4. 每个红色节点的两个子节点都是黑色（即从每个叶子到根的所有路径上不能有两个连续的红色节点）。</span><br><span class="line">5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</span><br><span class="line">=&gt; 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</span><br><span class="line"></span><br><span class="line">VS:</span><br><span class="line">AVL树要通过旋转来保持平衡，而旋转是非常耗时 AVL树合适用于插入与删除次数比较少，但搜索多的情况  Windows NT内核</span><br><span class="line">红黑树相同的节点情况下，AVL树的高度低于红黑树，相对于要求严格的AVL树来说，红黑树的旋转次数少，所以对于插入与删除较多的情况用红黑树 STL</span><br></pre></td></tr></table></figure>
<p><img src="/Q&A/C++/O.jpg" alt="O"></p>
<h2 id="匿名函数相较于普通函数的优点"><a href="#匿名函数相较于普通函数的优点" class="headerlink" title="匿名函数相较于普通函数的优点"></a>匿名函数相较于普通函数的优点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匿名函数即lambda表达式</span><br><span class="line">        捕获列表 参数列表   返回值 函数主体 调用</span><br><span class="line">int res = [](int a, int b) -&gt; int &#123;&#125;(1,2);</span><br><span class="line">内部嵌套</span><br><span class="line">int res = [](int n)&#123;</span><br><span class="line">    return [n](int x)&#123;</span><br><span class="line">        return n*x;</span><br><span class="line">    &#125;(1);</span><br><span class="line">&#125;(2);</span><br><span class="line"></span><br><span class="line">auto f = [](int n)&#123;</span><br><span class="line">    return [n](int x)&#123;</span><br><span class="line">        return n*x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(1)(2);</span><br><span class="line"></span><br><span class="line">内部使用外部的变量时 需要在[]中写入外部变量n去捕获</span><br><span class="line">[n]按值捕获 捕获的是声明匿名函数时捕获列表参数的值</span><br><span class="line">[&amp;n]按引用捕获 捕获后内外修改的是同一个值</span><br><span class="line">捕获列表 [=]按值捕获外界所有变量 [&amp;]按引用捕获外界所有变量 [a,b,&amp;c,&amp;d]</span><br><span class="line"></span><br><span class="line">要更改值捕获时加上muteable</span><br><span class="line"></span><br><span class="line">应用:</span><br><span class="line">for_each(v.beign(), v.end(), [](int n)&#123;</span><br><span class="line">    if(n%2==0) printf(&quot;偶&quot;);</span><br><span class="line">    else printf(&quot;奇&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">优点:</span><br><span class="line">对于普通函数的实现方式来说，其优点具有最小的语法开销，缺点是不能限定作用域（即函数必须在使用作用域外进行定义)</span><br><span class="line">对于函数对象(仿函数)的实现方式来说，其优点可以在作用域内进行定义，但缺点是需要有类定义的语法开销</span><br><span class="line">而匿名函数既保持了二者的优点，又摒弃了二者的缺点</span><br><span class="line">匿名函数，仅在调用时，才临时创建函数对象和作用域链对象；调用完，立即释放，所以匿名函数比非匿名函数更节省内存空间</span><br></pre></td></tr></table></figure>
<h2 id="const-static"><a href="#const-static" class="headerlink" title="const/static"></a>const/static</h2><p><a href="https://zhuanlan.zhihu.com/p/141113043">https://zhuanlan.zhihu.com/p/141113043</a></p>
<h2 id="C-内存排布"><a href="#C-内存排布" class="headerlink" title="C++内存排布"></a>C++内存排布</h2><p><img src="/Q&A/C++/memory.png" alt="memory"><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数名，局部变量的名等。其操作方式类似于数据结构中的栈。</span><br><span class="line">2. 堆区（heap）— 由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</span><br><span class="line">3. 全局/静态存储区 —全局变量和局部静态变量的存储是放在一块的（在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分）。程序结束后由系统释放。</span><br><span class="line">4. 常量存储区 — 常量字符串就是放在这里的，正常情况不允许修改，程序结束后由系统释放 。</span><br><span class="line">5. 程序代码区 — 存放函数体的二进制代码。</span><br><span class="line"></span><br><span class="line">关于自由存储区:</span><br><span class="line">堆是操作系统所维护的一块特殊内存 是C语言和操作系统的术语</span><br><span class="line">自由存储是C++中通过new和delete动态分配和释放对象的 抽象概念</span><br><span class="line">堆与自由存储区并不等价</span><br><span class="line">new/delete所申请销毁的区域也在堆上 这句话也不能算错</span><br><span class="line">基本上所有的C++编译器默认使用堆来实现自由存储(可以通过重载操作符，改用其他内存来实现自由存储)</span><br></pre></td></tr></table></figure><br><a href="https://www.cnblogs.com/ruanraun/p/Heap.html">https://www.cnblogs.com/ruanraun/p/Heap.html</a></p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用于类继承层次间的指针或引用转换 主要用于执行 安全的向下转型 即基类对象的指针或引用转换为同一继承层次的其他指针或引用 会检查转换的source对象是否真的可以转换成target类型</span><br><span class="line"></span><br><span class="line">向上转型（即派生类指针或引用类型转换为其基类类型），本身就是安全的，尽管可以使用dynamic_cast进行转换，但这是没必要的， 普通的转换已经可以达到目的，毕竟使用dynamic_cast是需要开销的</span><br><span class="line">    Base *base</span><br><span class="line">    Derived *der = new Derived;</span><br><span class="line">    //base = dynamic_cast&lt;Base*&gt;(der); //正确，但不必要</span><br><span class="line">    base = der;</span><br><span class="line"></span><br><span class="line">向下转型:</span><br><span class="line">1. 基类指针所指对象是派生类类型的，转换安全；</span><br><span class="line">2. 基类指针所指对象为基类类型，此时dynamic_cast在运行时做检查，转换失败，返回结果为0；</span><br><span class="line">    Base* base = new Derived;</span><br><span class="line">    Derived *der= dynamic_cast&lt;Derived*&gt;(base);</span><br><span class="line"></span><br><span class="line">    Base * base1 = new Base;</span><br><span class="line">    //Derived *der1 = dynamic_cast&lt;Derived*&gt;(base1); 失败</span><br><span class="line"></span><br><span class="line">引用同理 但引用的dynamic_cast检测失败时会抛出一个bad_cast异常</span><br><span class="line"></span><br><span class="line">使用dynamic_cast转换的Base类至少带有一个虚函数 虚表是dynamic_cast操作符转换能够进行的前提条件</span><br></pre></td></tr></table></figure>
<h2 id="RTTI机制"><a href="#RTTI机制" class="headerlink" title="RTTI机制"></a>RTTI机制</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型</span><br><span class="line">C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改</span><br><span class="line">由于多态性，C++中的指针或引用本身的类型，可能与它实际代表的类型不一致。有时需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求</span><br><span class="line"></span><br><span class="line">C++通过以下的两个操作提供RTTI：</span><br><span class="line">typeid操作符，返回指针和引用所指的实际类型 typeid(a).name()就能知道变量a是什么类型的。typeid()函数的返回类型为typeinfo类型的引用</span><br><span class="line">dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用</span><br></pre></td></tr></table></figure>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中</span><br></pre></td></tr></table></figure>
<h2 id="移动构造，右值引用"><a href="#移动构造，右值引用" class="headerlink" title="移动构造，右值引用"></a>移动构造，右值引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">能出现在赋值号左边的表达式称为左值，不能出现在赋值号左边的表达式称为右值。一般来说，左值是可以取地址的，右值则不可以 非 const 的变量都是左值。函数调用的返回值若不是引用，则该函数调用就是右值。一般的引用都是引用变量的，而变量是左值，因此它们都是“左值引用”。C++11 新增了一种引用，可以引用右值，因而称为右值引用。无名的临时变量不能出现在赋值号左边，因而是右值。右值引用就可以引用无名的临时变量。定义右值引用的格式如下：</span><br><span class="line">类型 &amp;&amp; 引用名 = 右值表达式</span><br><span class="line">引入右值引用的主要目的是提高程序运行的效率,避免没有必要的深拷贝操作</span><br><span class="line"></span><br><span class="line">移动语义（Move语义），指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象</span><br><span class="line">	// 移动构造函数 和复制构造函数的区别在于，其参数是右值引用</span><br><span class="line">	String(String &amp;&amp; s) : str(s.str)&#123;</span><br><span class="line">		s.str = new char[1];</span><br><span class="line">		s.str[0] = 0;&#125;</span><br><span class="line">	// 移动赋值运算符 和复制赋值运算符的区别在于，其参数是右值引用</span><br><span class="line">	String &amp; operator = (String &amp;&amp; s)&#123;</span><br><span class="line">		if (str != s.str)&#123;</span><br><span class="line">			// 在移动赋值运算符函数中没有执行深复制操作 而是直接将对象的 str 指向了参数 s 的成员变量 str 指向的地方 然后修改 s.str 让它指向别处，以免 s.str 原来指向的空间被释放两次。</span><br><span class="line">			str = s.str;</span><br><span class="line">			s.str = new char[1];</span><br><span class="line">			s.str[0] = 0;&#125;</span><br><span class="line">		return *this;&#125;</span><br><span class="line">    T tmp = std::move(a);  //std::move(a) 为右值，这里会调用移动构造函数</span><br><span class="line">	a = std::move(b);  //move(b) 为右值，因此这里会调用移动赋值运算符</span><br><span class="line">	</span><br><span class="line">std::move 是获得右值的方式，通过 move 可以将左值转为右值</span><br><span class="line">std::vector 的 &quot;move 构造函数&quot; 对某个 vector 的右值引用，可以单纯地从右值复制其内部 C-style 数组的指针到新的 vector，然后留下空的右值</span><br><span class="line">    pb = std::move(pa);// pa现在为空</span><br></pre></td></tr></table></figure>
<p>完美转发<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实现如果传进来的参数是一个左值，则将它作为左值转发给下一个函数；如果它是右值，则将其作为右值转发给下一个函数</span><br><span class="line">std::forward&lt;T&gt;()。与std::move()相区别的是，move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左右值类型</span><br></pre></td></tr></table></figure><br><a href="https://blog.csdn.net/summerhust/article/details/110677472">https://blog.csdn.net/summerhust/article/details/110677472</a></p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++11 增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收 智能指针和普通指针的用法是相似的，不同在智能指针可以在适当时机自动释放分配的内存。使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现</span><br><span class="line"></span><br><span class="line">利用了RAII（资源获取即初始化）的技术对普通的指针进行封装，使得智能指针实质是一个对象，行为表现的却像一个指针</span><br><span class="line"></span><br><span class="line">智能指针底层采用引用计数方式实现 申请堆内存空间的同时，为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉</span><br><span class="line"></span><br><span class="line">#include &lt;memory&gt; 并位于 std 命名空间中</span><br><span class="line"></span><br><span class="line">shared_ptr</span><br><span class="line">多个 shared_ptr 智能指针可以共同使用同一块堆内存 引用计数机制(空的 shared_ptr 指针，其初始引用计数为 0) 成员函数get()获取原始指针</span><br><span class="line">    std::shared_ptr&lt;int&gt; p3(new int(10));</span><br><span class="line">    std::shared_ptr&lt;int&gt; p3 = std::make_shared&lt;int&gt;(10);// 同上</span><br><span class="line">    std::shared_ptr&lt;int&gt; p4(p3); //或std::shared_ptr&lt;int&gt; p4 = p3;//调用拷贝构造函数</span><br><span class="line">    std::shared_ptr&lt;int&gt; p5(std::move(p4)); //或std::shared_ptr&lt;int&gt; p5 = std::move(p4);//调用移动构造函数</span><br><span class="line"></span><br><span class="line">unique_ptr </span><br><span class="line">同一时刻只能有一个unique_ptr指向给定对象（禁止拷贝语义、可用移动语义转移所有权）</span><br><span class="line">离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete</span><br><span class="line">可以改变智能指针所指对象</span><br><span class="line">    std::unique_ptr&lt;int&gt; uptr2 = std::move(uptr); //轉換所有權</span><br><span class="line">    uptr2.release(); //释放所有权</span><br><span class="line"></span><br><span class="line">weak_ptr</span><br><span class="line">不具有普通指针的行为 没有重载operator*和-&gt;,它的最大作用在于协助shared_ptr工作，像旁观者那样观测资源的使用情况 它的构造不会引起指针引用计数的增加 </span><br><span class="line">成员函数use_count()观测资源的引用计数 expired()表示被观测的资源(也就是shared_ptr的管理的资源)已不存在 lock()从被观测的shared_ptr获得一个可用的shared_ptr对象</span><br><span class="line">    std::shared_ptr&lt;int&gt; sh_ptr = std::make_shared&lt;int&gt;(10);</span><br><span class="line">    std::weak_ptr&lt;int&gt; wp(sh_ptr);</span><br><span class="line">    if(!wp.expired()) std::shared_ptr&lt;int&gt; sh_ptr2 = wp.lock(); //get another shared_ptr</span><br><span class="line"></span><br><span class="line">循环引用</span><br><span class="line">两个对象互相使用一个 shared_ptr 成员变量指向对方。这样会引发一个问题，其中任何一个对象的引用计数都为2。析构时两个资源引⽤计数会减⼀，于是两者引⽤计数还是大于0，导致跳出函数时资源没有被释放（离开作用域时两个对象的析构函数没有被调⽤） </span><br><span class="line">当想要parent对象释放时，children对象中仍保留了该parent对象的shared_ptr，导致其无法被正常释放。那就先释放children对象，parent对象中保留了该children对象的shared_ptr。就陷入了一个死循环：循环引用  </span><br><span class="line"></span><br><span class="line">解决办法:</span><br><span class="line">使用weak_ptr 来打破循环引用代替类中原来的shared_ptr，它与一个 shared_ptr 绑定，但却不参与引用计数的计算，不论是否有 weak_ptr 指向，一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。</span><br><span class="line"></span><br><span class="line">不用weak_ptr: Mark and Sweep Algorithm(标记清除算法)</span><br><span class="line">在对象创建时，设置它的标记位为0 将每个对象看作图的一个结点 标记阶段通过图遍历算法遍历图标记可达对象 清除没有被标记不可达的对象</span><br><span class="line">缺点: 执行算法多次后，堆内存可能被划分为多个不连续的区域</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/wxquare/p/4759020.html">https://www.cnblogs.com/wxquare/p/4759020.html</a></p>
<h2 id="virtual底层实现-介绍一下虚函数"><a href="#virtual底层实现-介绍一下虚函数" class="headerlink" title="virtual底层实现 介绍一下虚函数"></a>virtual底层实现 介绍一下虚函数</h2><p>虚函数表存放在哪里<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">虚函数表是全局共享的元素 虚函数表类似一个数组,类对象中存储vptr指针,指向虚函数表.即虚函数表不是函数,不是程序代码,不肯能存储在代码段 虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定,即虚函数表的大小可以确定,即大小是在编译时期确定的,不必动态分配内存空间存储虚函数表,所以不再堆中</span><br><span class="line">=&gt;虚函数表和静态成员变量一样,存放在全局数据区</span><br></pre></td></tr></table></figure></p>
<p>虚函数表数量<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先不考虑继承的情况。如果一个类中有虚函数，那么该类就有一个虚函数表。</span><br><span class="line">这个虚函数表是属于类的，所有该类的实例化对象中都会有一个虚函数表指针去指向该类的虚函数表</span><br><span class="line">有继承情况下，只要基类有虚函数，子类不论实现或没实现，都有虚函数表</span><br><span class="line">基类的虚函数表和子类的虚函数表不是同一个表</span><br><span class="line">如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在内容上是一致的</span><br><span class="line">多重继承会有多个虚函数表，几重继承，就会有几个虚函数表。这些表按照派生的顺序依次排列，如果子类改写了父类的虚函数，那么就会用子类自己的虚函数覆盖虚函数表的相应的位置，如果子类有新的虚函数，那么就添加到第一个虚函数表的末尾。</span><br></pre></td></tr></table></figure></p>
<p>不能声明为虚函数<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通函数 非成员函数，不能被继承</span><br><span class="line">友元函数 不属于类的成员函数，不能被继承</span><br><span class="line">构造函数 多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性</span><br><span class="line">内联成员函数 编译时展开</span><br><span class="line">静态成员函数 编译时确定</span><br></pre></td></tr></table></figure></p>
<h2 id="内存泄漏及如何检测"><a href="#内存泄漏及如何检测" class="headerlink" title="内存泄漏及如何检测"></a>内存泄漏及如何检测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内存泄漏:</span><br><span class="line">动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束</span><br><span class="line">(一部分内存空间已经使用了，却没有引用指向这部分空间。造成这片已经使用的空间无法处理的情况)</span><br><span class="line"></span><br><span class="line">危害: 长时间运行，程序变卡，性能严重下降 程序莫名其妙挂掉 OutOfMemoryError错误</span><br><span class="line"></span><br><span class="line">检测:</span><br><span class="line">小工程简单去检查代码中new和delete的匹配对数</span><br><span class="line">使用专业工具Valgrind</span><br><span class="line">Windows下使用CRT库</span><br><span class="line">        #define _CRTDBG_MAP_ALLOC</span><br><span class="line">        #include &lt;stdlib.h&gt;</span><br><span class="line">        #include &lt;crtdbg.h&gt;</span><br><span class="line"></span><br><span class="line">        _CrtDumpMemoryLeaks();// 放在程序退出位置之前 调试器下运行程序时_CrtDumpMemoryLeaks 将在“输出”窗口中显示内存泄漏信息</span><br><span class="line"></span><br><span class="line">    定位内存泄漏 在关键点对应用程序的内存状态拍快照</span><br><span class="line">        _CrtMemState s1, s2, s3;//存储内存状态的快照</span><br><span class="line">        _CrtMemCheckpoint( &amp;s1 );//用当前内存状态的快照填充_CrtMemState</span><br><span class="line">        char *str = NULL;</span><br><span class="line">        GetMemory(str, 100);</span><br><span class="line">        _CrtMemCheckpoint( &amp;s2 );</span><br><span class="line">        if ( _CrtMemDifference( &amp;s3, &amp;s1, &amp;s2) )// 比较两个内存状态（s1 和 s2），生成这两个状态之间差异的结果（s3)</span><br><span class="line">            _CrtMemDumpStatistics( &amp;s3 );// 在任意点转储该结构的内容</span><br><span class="line">        cout&lt;&lt;&quot;Memory leak test!&quot;&lt;&lt;endl;</span><br><span class="line">        _CrtDumpMemoryLeaks();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">内存溢出:</span><br><span class="line">内存越界 如调用栈溢出（即stackoverflow）没有足够的内存空间供其使用</span><br><span class="line">原因: 内存中加载的数据量过于庞大 存在死循环或循环产生过多重复的对象实体 启动参数内存值设定的过小</span><br></pre></td></tr></table></figure>
<h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><p>对象生命周期结束自动释放资源 ——-RAII</p>
<p>std::lock_guard<std::mutex> lock(mut); 实现自动化解锁</std::mutex></p>
<p>智能指针</p>
<p>RAII的作用是帮助处理发生异常时的资源释放问题以及避免程序员忘记释放资源</p>
<p>在某些资源需要非常精细控制的情况下，依然需要手动管理。必须提早（对象生命周期结束前）释放的东西就别用raii</p>
<p><a href="https://blog.csdn.net/bandaoyu/article/details/105461203">https://blog.csdn.net/bandaoyu/article/details/105461203</a></p>
<h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p>手写一个对象池，实现对象的标记，删除，获取等等给定的功能。然后在根据面试官的要求对底层的数据结构进行优化。<br>RAII+对象池 <a href="https://www.jianshu.com/p/e4023a41d810">https://www.jianshu.com/p/e4023a41d810</a></p>
<h2 id="介绍自己游戏常用的设计模式"><a href="#介绍自己游戏常用的设计模式" class="headerlink" title="介绍自己游戏常用的设计模式"></a>介绍自己游戏常用的设计模式</h2><p>手写工厂模式？工厂模式和抽象工厂的区别<br><a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/88792594">https://blog.csdn.net/QIANGWEIYUAN/article/details/88792594</a></p>
<h2 id="c中null和c-中的null有啥区别"><a href="#c中null和c-中的null有啥区别" class="headerlink" title="c中null和c++中的null有啥区别"></a>c中null和c++中的null有啥区别</h2><p>为什么c++中的null定义为0，c中的不能<br>为什么int<em> a = null 等价于 int </em>a = 0 能通过编译<br><a href="https://www.cnblogs.com/xiehongfeng100/p/4010802.html">https://www.cnblogs.com/xiehongfeng100/p/4010802.html</a></p>
<h2 id="一个类的指针为空那么一定访问失败吗"><a href="#一个类的指针为空那么一定访问失败吗" class="headerlink" title="一个类的指针为空那么一定访问失败吗"></a>一个类的指针为空那么一定访问失败吗</h2><p>调用空指针的成员函数不会崩溃，而调用空指针的成员变量就会崩溃  </p>
<p>是因为成员函数和普通函数没有本质什么区别，只是比普通函数多了一个 this 指针而已。  </p>
<p>但是成员变量是属于对象的。如果一个对象没有分配内存，那调用对象中的变量自然也无从说起<br><a href="https://www.cnblogs.com/Tanc-ANT/p/13448197.html">https://www.cnblogs.com/Tanc-ANT/p/13448197.html</a></p>
<h2 id="哪些代码会在main之前执行"><a href="#哪些代码会在main之前执行" class="headerlink" title="哪些代码会在main之前执行"></a>哪些代码会在main之前执行</h2><ol>
<li>全局对象的构造函数会在main 函数之前执行。</li>
<li>一些全局变量、对象和静态变量、对象的空间分配和赋初值就是在执行main函数之前，而main函数执行完后，还要去执行一些诸如释放空间、释放资源使用权等操作</li>
<li>进程启动后，要执行一些初始化代码（如设置环境变量等），然后跳转到main执行。全局对象的构造也在main之前。</li>
<li>通过关键字<strong>attribute</strong>，让一个函数在主函数之前运行，进行一些数据初始化、模块加载验证等。<br>访问空指针对象所指向类的函数一定报错吗</li>
</ol>
<h2 id="操作系统当中堆和栈的区别是什么？数据结构当中堆和栈的区别是什么？"><a href="#操作系统当中堆和栈的区别是什么？数据结构当中堆和栈的区别是什么？" class="headerlink" title="操作系统当中堆和栈的区别是什么？数据结构当中堆和栈的区别是什么？"></a>操作系统当中堆和栈的区别是什么？数据结构当中堆和栈的区别是什么？</h2><p><a href="https://blog.csdn.net/Zilong0128/article/details/119899392">https://blog.csdn.net/Zilong0128/article/details/119899392</a></p>
<h2 id="静态链接库、动态链接库、导入库的区别"><a href="#静态链接库、动态链接库、导入库的区别" class="headerlink" title="静态链接库、动态链接库、导入库的区别"></a>静态链接库、动态链接库、导入库的区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态库: libxxx.a</span><br><span class="line">通常情况下，对函数库的链接是放在编译时期（compile time）完成 所有需要的函数拷贝到自己门下 运行 时，与函数库再无瓜葛</span><br><span class="line">静态函数库改变 程序必须重新编译</span><br><span class="line"></span><br><span class="line">动态链接库: libxxx.so</span><br><span class="line">把对一些库函数的链接载入推迟到程序运行的时期 直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址 使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</span><br><span class="line">多个应用程序可以使用同一个动态库 动态函数库的改变并不影响你的程序</span><br><span class="line"></span><br><span class="line">#pragma comment ( lib,&quot;wpcap.lib&quot; )是导入库文件，以使程序可以调用相应的动态链接库 程序运行时需要加载这个 .dll 文件。和在工程设置里写上链入wpcap.lib的效果一样，不过这种方法别人在使用你的代码的时候就不用再设置工程settings</span><br><span class="line"></span><br><span class="line">静态链接库中不能再包含其他动态链接库或者静态库，而动态链接库还可以再包含其他的动态或静态链接库。</span><br><span class="line">动态库在需要调用其中的函数时，根据函数映射表找到该函数然后调入堆栈执行。如果当前工程有多处对dll文件中同一个函数的调用，执行时这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，执行时该函数将在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝</span><br></pre></td></tr></table></figure>
<h2 id="new与malloc有什么区别"><a href="#new与malloc有什么区别" class="headerlink" title="new与malloc有什么区别"></a>new与malloc有什么区别</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 分配内存的位置</span><br><span class="line">new操作符从自由存储区上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</span><br><span class="line"></span><br><span class="line">那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</span><br><span class="line"></span><br><span class="line">2. 返回类型</span><br><span class="line">内存分配成功时 new返回对象类型的指针，类型严格与对象匹配</span><br><span class="line">malloc内存分配成功则是返回void* ，需要通过强制类型转换将void*指针转换成我们需要的类型</span><br><span class="line"></span><br><span class="line">3. 内存分配失败</span><br><span class="line">new内存分配失败抛出bac_alloc异常</span><br><span class="line">malloc分配内存失败时返回NULL</span><br><span class="line"></span><br><span class="line">4. 分配内存的大小</span><br><span class="line">new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算</span><br><span class="line">malloc则需要显式地指出所需内存的尺寸</span><br><span class="line"></span><br><span class="line">5. 调用构造/析构</span><br><span class="line">new:</span><br><span class="line">1. 调用operator new分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</span><br><span class="line">2. 编译器运行相应的构造函数以构造对象，并为其传入初值。</span><br><span class="line">3. 对象构造完成后，强制类型转换返回一个指向该对象的指针</span><br><span class="line"></span><br><span class="line">malloc不会调用对象的构造函数/析构函数</span><br><span class="line"></span><br><span class="line">6. 处理数组</span><br><span class="line">new有处理数组的new版本new[] 会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会数组对象部分释放的现象，造成内存泄漏</span><br><span class="line"></span><br><span class="line">malloc需要用户计算数组的大小后进行内存分配</span><br><span class="line"></span><br><span class="line">7. 已分配内存的扩充</span><br><span class="line">new无法直观地处理</span><br><span class="line">malloc使用realloc进行内存重新分配实现内存的扩充</span><br><span class="line"></span><br><span class="line">8. 重载</span><br><span class="line">opeartor new /operator delete可以被重载,以决定我们的new与delete如何为对象分配内存，如何回收对象</span><br><span class="line">malloc/free并不允许</span><br><span class="line"></span><br><span class="line">free是C的库函数，delete是C++的关键字</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/linux_ever/article/details/50533149">https://blog.csdn.net/linux_ever/article/details/50533149</a></p>
<h2 id="struct-class内存大小"><a href="#struct-class内存大小" class="headerlink" title="struct class内存大小"></a>struct class内存大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内存按最大对齐</span><br><span class="line">指针64位8 32位4</span><br><span class="line">静态成员未初始化或者未调用不占内存 静态成员不占类或结构体的内存</span><br><span class="line">有虚函数则加一个虚指针</span><br></pre></td></tr></table></figure>
<h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>CPU的缓存设计思想</p>
<p>CPU的指令流水线结构，为啥跳转指令执行速度很快(其实这题题意我有点没明白)</p>
<p>各类排序的复杂度，稳定性</p>
<p>进程间通信方式</p>
<p>生产者消费者</p>
<p>了解内存连续吗</p>
<p>逻辑地址，物理地址，虚拟地址分别是什么？</p>
<p>线程和进程的区别？</p>
<p>多线程的锁有哪些？分别有什么区别呢？</p>
<p>进程间通讯的方式？</p>
<p>烟花随机绽放的游戏，内存上存在什么问题</p>
<p>OSI 七层协议模型</p>
<p>TCP与UDP的区别</p>
]]></content>
      <categories>
        <category>Q&amp;A</category>
      </categories>
  </entry>
  <entry>
    <title>CG</title>
    <url>/Q&amp;A/CG/</url>
    <content><![CDATA[<h1 id="CG"><a href="#CG" class="headerlink" title="CG"></a>CG</h1><h2 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h2><p><a href="https://blog.csdn.net/qq_43406822/article/details/116768947">https://blog.csdn.net/qq_43406822/article/details/116768947</a><br><a href="https://zhuanlan.zhihu.com/p/467470018">https://zhuanlan.zhihu.com/p/467470018</a><br>顶点数据的输入、顶点着色器、曲面细分过程、几何着色器、图元组装、裁剪剔除、光栅化、片段着色器、混合测试  </p>
<p>顶点渲染器有哪些功能 介绍一下顶点着色器的输入<br>顶点着色器作用: 进行坐标变换 将输入的局部坐标变换到世界坐标、观察坐标、裁剪坐标</p>
<p>介绍MVP变换 view变换如何推倒变换矩阵 透视投影和正交投影</p>
<p>三角形如何绘制到屏幕上</p>
<p>光栅化用的什么算法</p>
<p>布林冯模型 还有别的渲染模型吗？冯和布林冯的区别</p>
<p>了解深一点的渲染管线吗？延迟渲染？优劣？<br>tiled渲染 tiled渲染有哪些算法?<br><a href="https://www.jianshu.com/p/6b5c9035b361">https://www.jianshu.com/p/6b5c9035b361</a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前向渲染: 一个一个的渲染，简单易懂，但是每一个都会进行光照计算；</span><br><span class="line">延迟渲染是将法线，光照信息等存入GBuffer，即保存最后会渲染到屏幕上的点的信息，然后在最后进行GBuffer的遍历进行渲染，这样的好处就是光照只进行一次计算。当然也有缺点，比如抗锯齿问题等</span><br></pre></td></tr></table></figure></p>
<h2 id="3D数学"><a href="#3D数学" class="headerlink" title="3D数学"></a>3D数学</h2><p>欧拉角</p>
<p>欧拉角定义的旋转矩有什么问题，怎么处理？</p>
<p>讲一下四元数原理，四元数怎么实现旋转</p>
<p>介绍点积和叉积的几何意义和代数形式 具体怎么向量叉乘判断在三角形内</p>
<p>如何计算半程向量</p>
<h2 id="ShadowMap及细节：slope-bias，PCF核，级联阴影"><a href="#ShadowMap及细节：slope-bias，PCF核，级联阴影" class="headerlink" title="ShadowMap及细节：slope-bias，PCF核，级联阴影"></a>ShadowMap及细节：slope-bias，PCF核，级联阴影</h2><p>Shadowmap的了解嘛，介绍一下。除此之外还有有哪些阴影处理算法？<br>软阴影可以怎么做？<br>CSM是怎么做的？</p>
<h2 id="场景图，BVH，八叉树-手写一个BVH树"><a href="#场景图，BVH，八叉树-手写一个BVH树" class="headerlink" title="场景图，BVH，八叉树 手写一个BVH树"></a>场景图，BVH，八叉树 手写一个BVH树</h2><h2 id="SSAO的实现"><a href="#SSAO的实现" class="headerlink" title="SSAO的实现"></a>SSAO的实现</h2><h2 id="高斯模糊的实现"><a href="#高斯模糊的实现" class="headerlink" title="高斯模糊的实现"></a>高斯模糊的实现</h2><p><a href="https://blog.csdn.net/markl22222/article/details/10313565">https://blog.csdn.net/markl22222/article/details/10313565</a></p>
<h2 id="Frustum-Culling的代码实现"><a href="#Frustum-Culling的代码实现" class="headerlink" title="Frustum Culling的代码实现"></a>Frustum Culling的代码实现</h2><h2 id="early-z概念-early-z是什么，为什么要有early-z"><a href="#early-z概念-early-z是什么，为什么要有early-z" class="headerlink" title="early-z概念 early-z是什么，为什么要有early-z"></a>early-z概念 early-z是什么，为什么要有early-z</h2><p><a href="https://blog.csdn.net/whitebreeze/article/details/118688150">https://blog.csdn.net/whitebreeze/article/details/118688150</a></p>
<h2 id="如果要渲染一个场景，有海水有天空还有各种特效，采用怎样渲染顺序"><a href="#如果要渲染一个场景，有海水有天空还有各种特效，采用怎样渲染顺序" class="headerlink" title="如果要渲染一个场景，有海水有天空还有各种特效，采用怎样渲染顺序"></a>如果要渲染一个场景，有海水有天空还有各种特效，采用怎样渲染顺序</h2><h2 id="天空盒什么时候渲染"><a href="#天空盒什么时候渲染" class="headerlink" title="天空盒什么时候渲染"></a>天空盒什么时候渲染</h2><p>场景渲染后渲染天空盒更好，因为大部分片元将由于深度测试而被丢弃。 也就是说，那些被场景元素遮挡的不可见的天空盒片元将被丢弃</p>
<h2 id="光追有对最后噪点怎么处理"><a href="#光追有对最后噪点怎么处理" class="headerlink" title="光追有对最后噪点怎么处理"></a>光追有对最后噪点怎么处理</h2><h2 id="写过什么shader效果"><a href="#写过什么shader效果" class="headerlink" title="写过什么shader效果"></a>写过什么shader效果</h2><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>对优化了解吗</p>
<p>减少if else为什么能优化</p>
<p>SIMD/CUDA</p>
<h2 id="用过什么引擎吗"><a href="#用过什么引擎吗" class="headerlink" title="用过什么引擎吗"></a>用过什么引擎吗</h2><h2 id="了解合批吗"><a href="#了解合批吗" class="headerlink" title="了解合批吗"></a>了解合批吗</h2><p><a href="https://www.cnblogs.com/cancantrbl/p/16048341.html">https://www.cnblogs.com/cancantrbl/p/16048341.html</a><br><a href="https://www.cnblogs.com/skandya/p/4905145.html">https://www.cnblogs.com/skandya/p/4905145.html</a>  </p>
<h2 id="了解compute-shader吗"><a href="#了解compute-shader吗" class="headerlink" title="了解compute shader吗"></a>了解compute shader吗</h2><h2 id="pbr，ibl"><a href="#pbr，ibl" class="headerlink" title="pbr，ibl"></a>pbr，ibl</h2><p>说一说PBR的原理？具体的法线分布函数有哪些？</p>
<p>实现过pbr相关的光照吗</p>
<p>说一下pbr的高光部分</p>
<p>G里面用到的是什么向量</p>
<p>间接光部分？ibl</p>
<p>你实现的ibl是diffuse还是镜面反射的</p>
<p>你的ibl贴图是自己生成的还是用别的代码生成的（我说用工具生成的）</p>
<p>除了用ibl还有什么办法实现类似的功能（我说了球谐函数，不知道对不对，还好她没让我介绍球谐函数，不然我鲨了我自己也说不出来）</p>
<p>IBL的实现细节，diffuse和specular部分分别是怎么做的？</p>
<p>反射探针是否了解 多个光照探针之间如何进行blend</p>
<p>IBL的specular部分的卷积，做了什么假设？这样假设会出现什么问题</p>
<p>IBL一般会把图像存储在cubemap中，如果在一些移动端设备上，没有提供cubemap的相关api，这个时候该怎么处理？</p>
<p>如果使用柱状投影图，会有什么问题？</p>
<p>如果需要实时进行卷积操作，diffuse部分怎么做可以更快，更高效？</p>
<p>屏幕后处理LUT加滤镜是怎么做的？</p>
<p>讲一讲渲染方程的物理意义</p>
<p>怎么理解重要性采样？</p>
<h2 id="渲染透明物体应该怎么控制状态机"><a href="#渲染透明物体应该怎么控制状态机" class="headerlink" title="渲染透明物体应该怎么控制状态机"></a>渲染透明物体应该怎么控制状态机</h2><p>这个问题我只是一知半解吧。渲染透明物体应该先渲染不透明的物体，这时需要开启深度写入，然后渲染透明或半透明物体，关闭深度写入。注意，这里需要进行深度检测。渲染多个半透明物体需要从远到近进行渲染，同时不能写入深度</p>
<h2 id="移动端架构是否了解？是否有了解过TBR和TBDR？你怎么理解TBDR中的D？在TBDR上处理半透明物体怎么处理？"><a href="#移动端架构是否了解？是否有了解过TBR和TBDR？你怎么理解TBDR中的D？在TBDR上处理半透明物体怎么处理？" class="headerlink" title="移动端架构是否了解？是否有了解过TBR和TBDR？你怎么理解TBDR中的D？在TBDR上处理半透明物体怎么处理？"></a>移动端架构是否了解？是否有了解过TBR和TBDR？你怎么理解TBDR中的D？在TBDR上处理半透明物体怎么处理？</h2><p><a href="https://zhuanlan.zhihu.com/p/390625258">https://zhuanlan.zhihu.com/p/390625258</a></p>
<p>OpenGL抖动阶段做了什么处理？</p>
<p>说一说蒙特卡洛的原理？不用蒙特卡洛怎么表示积分？</p>
<p>大世界场景需要注意哪些问题？</p>
<p>城市场景有什么优化思路？</p>
<p>除了BVH以外还有哪些空间划分方式？BVH和八叉树各有什么适用范围？BVH划分节点有哪些手段，各有什么优缺点？</p>
<p>射线和三角形求交，射线与球求交，怎么快速判断？</p>
<p>如果我们要生成成千上万相同的对象，该怎么做？</p>
<p>碰撞检测是怎么做的，高速物体碰撞检测出现子弹的隧穿怎么办？</p>
<p>双重缓冲和垂直同步是否了解？</p>
<p>纹理压缩有了解吗？移动端的纹理压缩呢？</p>
<p>常规性能问题应该如何分析？有哪些优化方向和手段？</p>
<p>GPU Driven了解吗？</p>
<p>帧同步和状态同步了解吗？</p>
<p>z-fighting怎么处理？ 动<em>*</em>面和远平面哪一个比较好？</p>
<p>抗锯齿算法知道哪些？</p>
<p>8倍的MSAA，缓冲区大小也要8倍吗？MSAA和延迟渲染不能共存只是带宽和显存的问题吗？</p>
<p>TAA存在哪些问题？如何解决拖影？</p>
<p>全局光照算法了解哪些？</p>
<p>RSM, LPV ,VXGI怎么处理的？</p>
<p>SSR怎么做的，ray marching是如何进行的？</p>
<p>如果要用在移动端 你觉得哪些GI算法优化之后是可行的？LPV，SSGI如果要用在移动端，需要进行哪些方面的优化？</p>
<p>手写blinn-phong shader</p>
<p>手写旋转，平移，缩放矩阵</p>
<p>HLSL/GLSL写采样</p>
]]></content>
      <categories>
        <category>Q&amp;A</category>
      </categories>
  </entry>
  <entry>
    <title>Others</title>
    <url>/Q&amp;A/Others/</url>
    <content><![CDATA[<p>ACM模式和力扣核心模式</p>
<p>反问环节<br>问面试官青睐什么样的项目</p>
<p>C++实际解决过哪些问题？</p>
<p>项目难点，如何解决，做多线程的时候遇到过哪些麻烦，怎么解决的？</p>
<p>对图形引擎/技术美术岗位的理解和看法？</p>
<p>图形学学习过程？</p>
<p>OpenGL学了多长时间？</p>
<p>怎么在游戏中优化cache访问？</p>
<p>unity了解程度，用过哪些功能？</p>
<p>你平时怎么debug的？</p>
<p>C#的了解嘛？</p>
<p>blender的了解嘛？是否会使用blender的脚本系统</p>
<p>懂不懂粒子系统和效果？</p>
<p>骨骼动画是否有了解？</p>
<p>用过哪些debug或者性能分析工具？</p>
<p>平时玩什么游戏？最近玩了什么游戏？喜欢什么类型的游戏？</p>
<p>原神的全局光照和屏幕后处理有了解吗？（不是米哈游问的，而且不止一家公司问了，我说玩过原神。。就会开始问）</p>
<p>战神4你觉得哪里好，你觉得奎爷那把斧子的技术难点在哪里？（因为我说最近一年玩过刚上pc的战神）</p>
<p>编译型语言和解释型语言有什么区别？</p>
<p>看过哪些印象深刻的技术博客吗？</p>
<p>说一件在技术上让你比较有成就感的事情，或者说是什么让你有成就感。</p>
<p>为什么想做游戏引擎？</p>
<p>什么const在常量区，什么const在栈区，什么const放入符号表优化<br>虚函数表既然希望类的所有对象共享为什么不放在全局区<br>type_info信息存在虚函数表的哪里<br>怎样让对象只能创建在栈/堆/内存池中<br>具体如何重载operator new<br>dynamic_cast和虚函数的区别（dynamic_cast是为了使用子类的非虚方法或成员变量）<br>shader中为什么要避免使用if语句<br>游戏中物体从不透明变成透明，对渲染有什么难度<br>水的着色应该写在vertex shader还是fragment shader<br>irradiance 和 radiance 的区别；量纲分别是什么；积分表达；<br>写出渲染方程；解释下每项的含义<br>漫反射型；兰伯特项为什么要除以 PI<br>菲涅尔项是什么决定的；解释 f0 和 f90；单位；取值范围<br>数学角度解释重要性采样；收敛速度和什么成正比；什么是有偏无偏，估计一致性<br>左值右值是什么；move 和 forward 的原理和实现；引用折叠是什么<br>讲一下 unique 指针；可以传自定义的析构函数吗；占用额外空间吗；<br>讲讲 malloc 和 new；如何不申请内存空间只调用构造函数（placement new）（写代码）；<br>static_cast 和 dynamic_cast 的适用范围；转换失败；二者的开销；实现原理</p>
<p>口述：判断扇形攻击命中（2D空间判断点在扇形内）<br>口述：2D空间中，在三角形/圆内如何随机并且均匀采样点，均匀是指点各自占的面积尽量均匀<br>口述：判断点在三角形内（比较基础，但经常被问。重心坐标、叉乘法、面积求和）<br>口述：层次遍历二叉树<br>口述：快速排序<br>口述：绳子分成3段，要求三段长度乘积最大<br>口述：两个鸡蛋判断最少从哪层楼扔下来会碎，怎么弄比较好<br>口述：如何检测链表相交的所有情况，包括有环、在环上相交、入环点不一样等等<br>手撕：1、2、3、4、5、6、7、8的链表变成1、8、2、7、3、6、4、5，不使用额外存储空间<br>手撕：合并n个有序链表<br>手撕：有重复元素的顺序数组，查找新来的元素最前面的插入位置<br>手撕：DFS解数独<br>手撕：数组的最长递增连续子序列长度<br>手撕：两个字符串的最长不连续公共子串（逆天，看一眼直接放弃）<br>手撕：链表的倒数第k个元素<br>手撕：顺时针90度旋转矩阵<br>手撕：数组的第k大元素<br>手撕：判断汉字的unicode编码是否合法（题很长，记不清了）<br>手撕：判断回文链表，不使用额外存储空间<br>1.一个二维平面内，有多个矩形，如何根据矩形的重叠情况分组？（所有有重叠的为一组）<br>问：让你来设计一个英雄，你用C++写一下英雄的类<br>4.k个一组反转链表<br>5.3个数得到24点的算法，4个数的？<br>6.牛顿法求平方根<br>7.排行榜设计，要求能显示top100和自身排名<br>8.数据流实时中位数<br>9.红黑树和AVL区别？<br>10.哈希冲突如何处理，无序数组如何设计哈希函数<br>11.哈希表如何实现O（1）哈希值<br>12.各排序算法复杂度<br>1.快速排序的最坏情况是什么样？<br>2.两个栈实现队列？一个栈怎么实现？<br>3.有序数组合并（倒序插入）<br>4.一组有序数，删除其中一个数，打乱，如何找到这位数？如果是删除两个数，怎么找？如果删除三个数？<br>5.怪兽和陷阱都是圆，相交则表示怪兽在圆里，如何求所有在圆里的怪兽。<br>6.括号匹配<br>7.环形链表 II<br>8.实现一个定时器功能，要求实现定时器的注册，更新，注销三个函数。<br>9.给定一个数组a[n]，要求求出接近m的k个数。分析思路，时间复杂度。<br>10.删除链表中倒数第N个节点<br>11.如何确定黑盒函数foo(int)的时间复杂度？<br>12.快速幂 16<br>13.快速幂求余 14<br>14.判断平衡二叉树<br>15.LRU<br>16.用vector实现queue<br>17.数组模拟哈希找数组重复次数最多的小写字母<br>18.二维数组查找目标值<br>19.交换两个数字得到最大数字<br>20.和为目标值的数组对<br>21.约瑟夫环<br>22.cv中值滤波的实现？<br>23.二叉树每个节点有0/1两种值可能，同时有&amp;/|两种操作可能，除叶节点外每个节点的值由两个子节点的值与父节点的操作决定，现在确定根节点的值和所有非叶节点的操作，怎么确定叶节点的值，如果给定整棵二叉树的节点值和非叶节点的操作，怎样翻转最少的叶节点的值使得根节点的值也翻转<br>最大子序和leetcode53<br>10个砝码，称3次找出一个有异样的<br>如何判断两个多边形是否相交。我的思路是判断是否有顶点在另一个多边形内部。分为全部都在内部，2.全部都不在内部，3.有个别在内部。第一种情况就肯定不相交。第二种的得加一个判断是否有边相交（我没考虑到，面试官后来指出来的）。第三种肯定相交。后来面试官说是用分离轴算法</p>
<p>NPR中的一种描边实现方式（不太会，支支吾吾说了一点基于法线和视角的描边）<br>野指针，内存泄露<br>红黑树原理<br>有什么和一般渲染管线流程不同的流程（没太理解问题，我就介绍了Early-Z和延迟着色的原理以及具体的实现）<br>半透明物体的渲染（我分了半透和不透物体，半透明物体间相互交叠问题）<br>菱形继承地问题，如何解决，虚继承的原理是什么（不知道啥原理，就把虚继承的内存模型说了一遍）<br>虚函数表的大小怎么算（我提了有RTTI信息）<br>RTTI信息，怎么使用（我提了dynamic_cast）</p>
<ol>
<li><p>dynamic_cast原理，如何实现安全，觉得它的效率怎么样</p>
</li>
<li><p>static_cast和dynamic_cast的差别，什么时候用，把一个类型转换成另一个类型会发生什么（我说是因为做单纯地使用位截断进行处理，会损失精度，不知道对不对）</p>
</li>
</ol>
<p>A类和B类是组合关系，B中有A，A中有个int，其他啥都没有，创建B对象b，sizeof(b)为多少？为什么？（4，我回答的会调用默认构造函数啥的，有点不确定）</p>
<p>渲染器项目介绍。为啥做这个项目，有什么难点，不同点，有什么待优化的地方</p>
<p>多益网络、完美世界、字节跳动、网易互娱, 鹰角、友塔, 吉比特、三七互娱、4399、竞技世界,搜狐畅游,巨人网络,祖龙娱乐,莉莉丝,心动,哔哩哔哩,酷家乐,Garena,雷火,紫龙</p>
]]></content>
      <categories>
        <category>Q&amp;A</category>
      </categories>
  </entry>
  <entry>
    <title>AdvancedTopics</title>
    <url>/Graphics/Fundamental/AdvancedTopics/</url>
    <content><![CDATA[<h1 id="Advanced-Topics-in-Rendering"><a href="#Advanced-Topics-in-Rendering" class="headerlink" title="Advanced Topics in Rendering"></a>Advanced Topics in Rendering</h1><h2 id="高级光线传播方式"><a href="#高级光线传播方式" class="headerlink" title="高级光线传播方式"></a>高级光线传播方式</h2><ul>
<li>有偏和无偏<br>样本得到的期望值与总体的期望值相等，那么这种估计就被称为无偏的，反之则有偏<br>有偏估计存在系统差,但是方差较小;无偏估计不存在系统差,但是在某些情况下方差较大<br>有效性和一致性<br>样本统计量的期望收敛于总体统计量的期望，则称这种估计是一致的  </li>
</ul>
<h3 id="无偏光线传播方法"><a href="#无偏光线传播方法" class="headerlink" title="无偏光线传播方法"></a>无偏光线传播方法</h3><h4 id="双向路径追踪（BDPT"><a href="#双向路径追踪（BDPT" class="headerlink" title="双向路径追踪（BDPT)"></a>双向路径追踪（BDPT)</h4><p>路径追踪利用了光路可逆性，通过形成相机到光源的单向路径来计算光照结果<br>双向路径追踪，就是从光源和相机分别打出一些半路径，最后连接两条半路径的端点，形成整条路径<br>BDPT的原理看起来简单，但实现起来非常困难 适用于光线传播在光源一侧比较好计算的情况 在光源由漫反射形成的场景中效果较好<br><img src="/Graphics/Fundamental/AdvancedTopics/BDPT.jpg" alt="BDPT">  </p>
<blockquote>
<p>整个场景的光源只有左上角的聚光灯和右侧打向左侧的聚光灯，其余部分都由环境光照照亮，意味着使用传统路径追踪打出的路径的第一个弹射点大概率是漫反射表面，反射路径弹向光源的概率小，没弹几次就被俄罗斯轮盘终止了，很难计算到光源的信息，从而形成大量噪点。为了解决这个问题，从光源采样是一个优化方法，而BDPT则是另一个更高级的解决方案，从图中可以看出，双向路径追踪的效果是非常好  </p>
</blockquote>
<h4 id="Metropolis-Light-Transport-MLT"><a href="#Metropolis-Light-Transport-MLT" class="headerlink" title="Metropolis Light Transport (MLT)"></a>Metropolis Light Transport (MLT)</h4><p>利用马尔科夫链做蒙特卡洛估计 主要区别在于采样方式 在对像素多重采样的时候，之前的蒙特卡洛估计都是均匀采样，而马尔科夫链通俗来讲就是在已采样样本附近生成一个新样本继续做后续估计，每个样本之间不再独立，每次对当前像素的采样都基于上次对该像素的采样，这种采样方法得到的pdf可以与被积函数形状保持基本一致，采样的效果也就比均匀采样更好<br><img src="/Graphics/Fundamental/AdvancedTopics/MLT.jpg" alt="MLT">  </p>
<blockquote>
<p>如上在已有路径（蓝）基础上加以扰动，得到新光路（橙）注意这里是对像素采样，而不是在解渲染方程  </p>
</blockquote>
<p>pros: 适用于复杂的光线传播情况，如半掩着门的房间，或者发生焦散的水体（SDS路径，specular→diffuse→specular）等，因为这些复杂的光线传播一旦找到一条路径，就可以不断在周围找到更多的路径，从而达到以更快速度获得更高质量渲染结果的目的  </p>
<p>cons: 对于每个像素来说，其渲染时间是很难从理论上计算出来的，也就很难用来去渲染动画，并且因为所有的操作过程都是局部的，每个像素渲染时收敛所需的时间都不一样，这就导致图片看上去比较脏  </p>
<h3 id="有偏光线传播方法"><a href="#有偏光线传播方法" class="headerlink" title="有偏光线传播方法"></a>有偏光线传播方法</h3><h4 id="Photon-Mapping-光子映射"><a href="#Photon-Mapping-光子映射" class="headerlink" title="Photon Mapping 光子映射"></a>Photon Mapping 光子映射</h4><p>PM利用光源打出光线的过程可以被理解为不断打出光子的过程的想法<br>特别适合渲染水中焦散Caustics的现象  </p>
<ol>
<li>先从光源出发打出光子，让其在空间内传播散射，直到打到漫反射表面为止</li>
<li>然后再从摄像机打出路径，进行着色计算，着色点的亮度取决于光子的密度</li>
<li>着色计算:  对每个着色点，取其附近的N个光子，做密度估计（树状结构实现算法），$\rho = \frac{N}{A}$  (A可以由球形包围盒与表面求交得到（方法不唯一  </li>
</ol>
<p>cons: 在做密度估计的时候，N小了噪声会非常大，N大了图像又会变得模糊<br>光子映射本身就是一个有偏的方法，算密度应该用$\frac{N}{dA}$ ，而我们的密度估计时用的是 $\Delta A$, 只有$\Delta A$ 足够小才能做到正确估计，否则多少会有点糊<br>sol: 在一开始发射光子的时候就多发射点，提高采样数，那么同样多的N对应的 就会相对小，这种方法虽然有偏但一致(只要有一点模糊就是有偏的 一致性==对于无限多个样本不模糊)  </p>
<h4 id="Vertex-connection-and-merging-VCM-顶点连接-合并"><a href="#Vertex-connection-and-merging-VCM-顶点连接-合并" class="headerlink" title="Vertex connection and merging (VCM) 顶点连接/合并"></a>Vertex connection and merging (VCM) 顶点连接/合并</h4><p>把双向路径追踪和光子映射结合<br>双向路径追踪会发生两条子路径端点非常接近的情况（在同一个局部面积内），这时候BDPT就认为这种路径无效，就是一种浪费<br>对于这种情况，VCM就认为其中一条路径打过来的不是光线而是光子，用光子映射的方法把两条路径的贡献结合起来，避免了这种浪费  </p>
<h4 id="Instant-Radiosity-VPL-many-light-method-实时辐射度-IR"><a href="#Instant-Radiosity-VPL-many-light-method-实时辐射度-IR" class="headerlink" title="Instant Radiosity/ VPL / many light method 实时辐射度(IR)"></a>Instant Radiosity/ VPL / many light method 实时辐射度(IR)</h4><p>将每个被照亮的表面都作为虚拟的点光源来看待，把光源打出的光线所打到的地方作为二级光源，计算着色时遍历这些二级光源叠加计算<br>pros：速度快，在漫反射场景中效果很好<br>cons：当虚拟光源离着色点特别近的时候，会出现反常亮点，类似漏光的现象，这和之前路径追踪对光源采样的距离平方项有关；另外，这种方法无法处理光泽材质  </p>
<h2 id="高级外观建模方法"><a href="#高级外观建模方法" class="headerlink" title="高级外观建模方法"></a>高级外观建模方法</h2><h3 id="非表面模型"><a href="#非表面模型" class="headerlink" title="非表面模型"></a>非表面模型</h3><h4 id="散射介质"><a href="#散射介质" class="headerlink" title="散射介质"></a>散射介质</h4><p>光线进入散射介质(雾、云)会发生两件事——被吸收或者散射<br>光线走多远被吸收，由介质的吸收能力决定；光线以何种方式散射，由介质的相位函数决定<br>渲染方法：直线传播 -&gt; 散射 -&gt; 直线传播 -&gt; 散射 -&gt; 直线传播 -&gt; … -&gt; 吸收<br>对每个发生散射的着色点，与光源连接，计算路径的贡献  </p>
<h4 id="头发-毛发"><a href="#头发-毛发" class="headerlink" title="头发/毛发"></a>头发/毛发</h4><ul>
<li><p>人类毛发:<br>  <img src="/Graphics/Fundamental/AdvancedTopics/Kajiya-Kay.jpg" alt="Kajiya-Kay"><br>  将头发丝看做一个可弯曲的圆柱 光线打到头发上会呈圆锥状散射（类似specular），同时又会被散射到四面八方（类似diffuse）diffuse+specular的模拟效果并不尽如人意  </p>
<p>  <img src="/Graphics/Fundamental/AdvancedTopics/Marschner.jpg" alt="Marschner"><br>  将头发丝进一步认为“圆柱”由“角质层”和“皮质层”组成 光线的作用过程也更加复杂，总共分为三类：T：直接反射 TT：穿进“皮质层”，再从“角质层”穿出 TRT：穿进“皮质层”，在内部反射，再从“角质层”穿出  </p>
</li>
<li><p>动物毛发:<br>  除了角质和皮质，毛发还具有髓质结构，并且动物毛发的髓质明显比人类毛发的髓质粗<br>  <img src="/Graphics/Fundamental/AdvancedTopics/DoubleCylinder.jpg" alt="DoubleCylinder"><br>  在Marschner模型的T，TT，TRT基础上又加了两个计算项：TTs和TRTs<br>  TTs：TT传进“皮质层”时打到髓质发生散射，再从“角质层”穿出<br>  TRTs：TRT进入“皮质层”时发生发射，来回打到两次髓质，最后从“角质层”穿出  </p>
</li>
</ul>
<p>详情: <a href="https://zhuanlan.zhihu.com/p/330259306">https://zhuanlan.zhihu.com/p/330259306</a></p>
<h4 id="颗粒材质"><a href="#颗粒材质" class="headerlink" title="颗粒材质"></a>颗粒材质</h4><p>砂砾，谷物，粉末这些材质都属于颗粒材质，这些材质渲染的计算量非常大，但可以做一些简化，用百分比来表示单个渲染单元的组成成分，不过即使如此，颗粒材质至今仍然没有得到有效的优化  </p>
<h3 id="表面模型"><a href="#表面模型" class="headerlink" title="表面模型"></a>表面模型</h3><h4 id="导体-金属-与绝缘体-塑料-BRDF"><a href="#导体-金属-与绝缘体-塑料-BRDF" class="headerlink" title="导体(金属)与绝缘体(塑料)BRDF"></a>导体(金属)与绝缘体(塑料)BRDF</h4><p><a href="https://zhuanlan.zhihu.com/p/21961722">https://zhuanlan.zhihu.com/p/21961722</a>  </p>
<h4 id="半透明材质-Translucent"><a href="#半透明材质-Translucent" class="headerlink" title="半透明材质 Translucent"></a>半透明材质 Translucent</h4><p>Translucent: 不仅仅是半透明，光线在内部还会有折射，比如玉石，水母<br>半透明是光线在材质内发生散射，最后从另一个点出来，对应到物理，这种现象被称为次表面散射<br>通常使用BSSRDF方程来描述次表面散射，它可以被认为是BSDF的拓展，BSDF计算贡献时只会计算当前着色点，而BSSRDF还需要考虑其他渲染单元射入的光线，因为这些光线在材质内发生散射后，同样有可能对当前着色点的能量造成影响<br><img src="/Graphics/Fundamental/AdvancedTopics/BSSRDF.jpg" alt="BSSRDF"><br>也可以用Dipole方法做近似，即在表面上下各假设一个虚拟光源，来模拟次表面散射的光照效果  </p>
<h4 id="布料模拟"><a href="#布料模拟" class="headerlink" title="布料模拟"></a>布料模拟</h4><p>布料的微观组成：纤维 -&gt; 纱线 -&gt; 布料 (其中编制方法还分woven和knitted两种  </p>
<ul>
<li>直接根据不同布料给出BRDF，Render as Surface, 简单粗暴 但无法渲染天鹅绒等材质(天鹅绒本身就不能归为表面模型)  </li>
<li>把布料看做是空间中的微小体积的集合，当做散射介质就像渲染云雾那样去渲染布料, Render as Participating Media, 计算量大  </li>
<li>Render as Actual Fibers 将每一根纤维为单位进行渲染，计算量巨大  </li>
</ul>
<h3 id="细节模型"><a href="#细节模型" class="headerlink" title="细节模型"></a>细节模型</h3><p>带有瑕疵(划痕, 老化, 磨损…)<br>微表面模型使用法线分布来描述微观表面的起伏，但法线分布大部分是正态分布之类的简单分布<br>在计算镜面反射时，如果法线分布比较复杂，就很难建立有效的，从光源到微表面再到摄像机的光线通路<br>让每个像素打出路径时都对应一个范围，把整块范围内的法线分布整合起来得到P-NDF，从而简化计算<br>考虑微表面上光的波粒二象性  </p>
<h3 id="程序化生成材质"><a href="#程序化生成材质" class="headerlink" title="程序化生成材质"></a>程序化生成材质</h3><p>程序化生成并没有真正的生成材质，而是将这个材质信息定义为空间中的一些噪声函数，在后续生成时动态的查询它（存储三维的纹理会耗费很多内存）<br>噪声函数的应用非常广泛，比如可以二值化定义车锈 现在应用最广泛的噪声函数是柏林噪声（Perlin Noise），有了这些噪声函数，不仅可以程序化生成材质，还可以程序化生成地形，程序化生成水面等，另外，由于这个噪声函数是定义在空间中的，所以如果我们在空间里切割一块木头（或其他材质），是能看到里面的纹理的，这是二维材质做不到的<br>Houdini是目前工业上用来程序化生成材质的工具，它并非如上所述定义了函数供后续查询，而是直接生成了材质拿去用 这个工具也渐渐的成为了目前游戏TA必备的工具技能之一  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Camera</title>
    <url>/Graphics/Fundamental/Camera/</url>
    <content><![CDATA[<h1 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h1><h2 id="Camera-相机"><a href="#Camera-相机" class="headerlink" title="Camera 相机"></a>Camera 相机</h2><ul>
<li>透镜(小孔) 成像的关键  </li>
<li>快门 一般一直处于关闭状态，直到按下拍照的瞬间才会打开，允许光线信息进入到透镜  </li>
<li>传感器 存储光线信息，传感器的每一点记录了来自物体所有方向的光，因此每一点存储的也就是irradiance  <h2 id="Pinhole-Image-Formation-小孔成像与视场-FOV"><a href="#Pinhole-Image-Formation-小孔成像与视场-FOV" class="headerlink" title="Pinhole Image Formation 小孔成像与视场(FOV)"></a>Pinhole Image Formation 小孔成像与视场(FOV)</h2></li>
</ul>
<p><img src="/Graphics/Fundamental/Camera/fov.png" alt="fov"><br>焦距f越小的时候FOV的角度也就越大，自然可以成像出更大的范围 底片长度越大，自然FOV也就越大<br>手机相机说的焦距都是相对而言 经过一定比例缩放的  </p>
<h2 id="Exposure-曝光"><a href="#Exposure-曝光" class="headerlink" title="Exposure 曝光"></a>Exposure 曝光</h2><p>传感器上接受到的是irradiance(每单位面积所接受到的光线功率) 曝光就是用时间乘上了这个irradiance 即真正的所接受到的能量(Energy)<br>Exposure = time x irradiance $\qquad$ H = E x T  </p>
<p>曝光受参数的影响  </p>
<ol>
<li>快门速度(Shutter speed)，快门打开时间越长，进光时间越长，进光量自然越多  </li>
<li>光圈大小(Aperture size)，描述此项的数值称为f-stop，直观理解如果光圈越大，被遮挡的光越少，进光量越多，那么曝光的程度就会越高  </li>
<li>感光度(ISO gain)，对于感光度可以简单理解为对最终的图像值乘上了一个倍数  </li>
</ol>
<p><img src="/Graphics/Fundamental/Camera/factor.png" alt="factor"><br>ISO的值显著增大之后，虽然画面整体亮度会提升，但同时也会观察到画面有很多的噪点<br>快门速度值越大代表速度越慢，快门打开时间越长，透镜的进光量越大，图片也就会越亮，但同时运动的物体也会变的模糊起来 (动态模糊) 无论快门打开的速度有多快，它一定有一个打开关闭的过程<br>游戏内每一帧都是静止画面并不存在动态模糊 所以往往需要60FPS以上<br>光圈大小 F-stop 或者F-Number值(该行中的逗号代表小数点)，该值大小与光圈直径的倒数成正比，因此FN值越小，代表光圈越大，进光量越大，画面亮度越高，但同时也会带来景深模糊的影响<br>应用: 高速摄影(补偿进光时间不够 小的快门速度 大光圈或提高ISO)和低速摄影</p>
<p>详情: <a href="https://zhuanlan.zhihu.com/p/134166476">https://zhuanlan.zhihu.com/p/134166476</a></p>
<h2 id="Depth-of-Field-景深"><a href="#Depth-of-Field-景深" class="headerlink" title="Depth of Field 景深"></a>Depth of Field 景深</h2><ul>
<li><p>透镜  </p>
<ol>
<li>所有平行射入透镜的光都会集中于一点，称该点为焦点  </li>
<li>所有从焦点射入透镜的光都会平行射出(光路可逆性)  </li>
<li>焦距可以被随意改变(单个透镜当然不行，但在现实中大部分的照相机都是一个透镜组，可以做到焦距随意改变)  </li>
</ol>
<p>成像规律 $\frac{1}{f} = \frac{1}{z_i} + \frac{1}{z_o}\qquad z_o和z_i为物距像距$  </p>
</li>
<li><p>景深模糊 Defocus Blur<br>  <img src="/Graphics/Fundamental/Camera/coc.png" alt="coc"><br>  当一个传感器平面不在一个物体真正精确的成像平面之上时(即之前所提到到像距zi的平面)，便会出现模糊 点变成了圆 长度C称为 Circle of Confusion<br>  C与透镜长度A成正比，而透镜长度也与光圈的直径成正比，因此当光圈越大，C也就越大，此时出现的景深模糊也就越明显<br>  光圈大小F-Number具体来说N = f/D 焦距比上直径<br>  <img src="/Graphics/Fundamental/Camera/fstop.png" alt="fstop"><br>  光线追踪当中实现景深模糊 简单的模拟透镜的光线传播<br>  <img src="/Graphics/Fundamental/Camera/raytracingblur.png" alt="raytracingblur"><br>  确定薄透镜的大小和位置，由此确定光圈和焦距，然后在透镜和传感器（像素屏幕）上分别采样，并连接成一条线<br>  这条光线经过折射后偏转，打到物体的x’’’处，计算x’’’到x’’的radiance并记录在x’处，这就是一条光追路径的薄透镜近似流程  </p>
</li>
</ul>
<ul>
<li>Depth of Field 景深<br>  景深模糊是一种情形，而景深则是一个具体的数值<br>  当我们固定一个可以接受的Circle of Confusion C值之后，可以逆向推导出小于该C值的对应的一段距离是多少，这个距离就是景深<br>  <img src="/Graphics/Fundamental/Camera/fyi.png" alt="fyi">  </li>
</ul>
<h2 id="Light-Field-Lumigraph-光场"><a href="#Light-Field-Lumigraph-光场" class="headerlink" title="Light Field / Lumigraph 光场"></a>Light Field / Lumigraph 光场</h2><ul>
<li><p>The Plenoptic Function 全光函数<br>  记录光线特征信息的函数，一般来说这些特征被分为四类：位置，角度，波长，时间<br>  <img src="/Graphics/Fundamental/Camera/The%20Plenoptic%20Function.png" alt="The Plenoptic Function">  </p>
</li>
<li><p>Sampling Plenoptic Function<br>  光场，就是对全光函数的采样，可以理解为全光函数的一个子集 现实中光线的颜色特征通常由RGB通道记录，而时间信息通常由动画帧来记录<br>  对于光场来说只需要关注方向和位置 七维的信息就被降至为了五维<br>  后来发现只需要四维的信息（二维位置信息uv + 二维方向信息θφ）就可以定义光线的方向和位置<br>  再后来，直接定义两个平面，两平面上任意两点连线就可以表示空间中任意一条光线<br>  光场其实就是不同时间，不同地点处的描述光的物理量<br>  而这些物理量需要根据你的着重点的不同而适当做出调整<br>  <img src="/Graphics/Fundamental/Camera/Lumigraph%20Organization.png" alt="Lumigraph Organization"><br>  对相机来说，uv可以理解为传感器/成像平面，st可以理解为镜头/光圈平面<br>  用采样来理解:<br>  <img src="/Graphics/Fundamental/Camera/Lumigraph%20Lightfield.png" alt="Lumigraph Lightfield">  </p>
<ol>
<li>固定(u,v)，对st平面采样，此时的采样结果可以理解为从uv上某点沿各个方向观察世界的结果  </li>
<li><p>固定(s,t)，对uv平面采样，此时的采样结果可以理解为从uv上各个不同的点以不同角度观察世界中某一点的结果  </p>
<p>自然界中苍蝇的复眼也是用类似的方式来感知外界信息的，也就是说苍蝇所接受到的信息不是Irradiance，而是经过复眼分光的Radiance信息  </p>
</li>
</ol>
</li>
<li><p>Light Field Camera 光场相机<br>  能记录光场的相机，它最重要的功能在于它支持先拍照，然后在后期重新对焦<br>  将原本的成像面的每个像素都换成微透镜（相当于st），再在成像面后面真正的去使用传感器记录信息（相当于uv）<br>  <img src="/Graphics/Fundamental/Camera/lightfieldcamera.png" alt="lightfieldcamera"><br>  普通相机的传感器像素记录的是irradiance，但是对于光场相机来说，它们记录的分光之后的分量，也就是记录的是Radiance<br>  对于每个微透镜，在经过它的光线中只选择一条，这样每个微透镜就都对应了一个值，然后把这个值作为当前传感器像素的值<br>  可以统一选择最下面的光线，也可以选择中间那根，这样就可以实现虚拟的移动相机的位置，并且这种方式得到的光照信息也是正确的（并不是简简单单的平移图像)<br>  局限:<br>  分辨率不足，光场相机的每个像素都相当于要记录一个像素组，在同样的胶片尺寸下，光场相机的分辨率往往会很低<br>  成本高、难设计，对仪器的精密程度大大提高，就比如微透镜组  </p>
</li>
</ul>
<h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><p>人类视网膜上有三种感知色彩的视锥细胞，所以理论上我们用三种颜色的光就可以混合出自然界中任何一种颜色来<br>色匹配函数<br>CIE-RGB空间 红色曲线部分地方出现的负值<br>CIE-XYZ空间 CIE-RGB线性变换都为正 完全等价  </p>
<p>色域&amp;屏幕色彩空间<br>三维参数降至二维，通过归一化使三个参数的和为1，这时候就只需要两个参数(也要固定一个值)就能表示颜色空间中任意一个颜色了，而这种表示方式所得到的颜色集合，我们就称之为色域<br><img src="/Graphics/Fundamental/Camera/Chromaticity.png" alt="Chromaticity"><br>计算机屏幕并不是人眼，他所支持的色域通常会比可见光色域小得多，必须把计算得到的 XYZ 转换到屏幕空间中（空间变换和gamma校正），而因为不同设备的转码方式不同，就形成了不同设备各自的色彩空间<br>色彩空间: <a href="https://zhuanlan.zhihu.com/p/24214731">https://zhuanlan.zhihu.com/p/24214731</a><br>gamma矫正:<br>从Radiance到颜色，不是简单线性变换就能得到的，因为显示器上颜色显示是非线性的，必须要矫正过<br><a href="https://zhuanlan.zhihu.com/p/36581276">https://zhuanlan.zhihu.com/p/36581276</a><br><img src="/Graphics/Fundamental/Camera/gamut.png" alt="gamut"><br>光学三原色和绘画三原色是不一样的，光学三原色是红绿蓝rgb，美术三原色是品红，黄和靛青<br>光学三原色是加色模型，美术三原色是减色模型<br><img src="/Graphics/Fundamental/Camera/cmyk.png" alt="cmyk">  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Animation</title>
    <url>/Graphics/Fundamental/Animation/</url>
    <content><![CDATA[<h1 id="Animation-simulation"><a href="#Animation-simulation" class="headerlink" title="Animation / simulation"></a>Animation / simulation</h1><p>Keyframe Animation 关键帧动画<br>画师画出关键的画面，再由其助手补全关键帧之间的过渡<br>所以关键帧动画的主要问题在于使用怎样的插值方法得到更为平滑的过渡<br>通常来说线性插值是无法满足平滑过渡的需求的，所以一般会用贝塞尔，b样条之类的几何插值技术  </p>
<h2 id="Physical-Simulation-物理模拟"><a href="#Physical-Simulation-物理模拟" class="headerlink" title="Physical Simulation 物理模拟"></a>Physical Simulation 物理模拟</h2><p>通过建立物理模型来还原诸如流体，布料等基于真实情况的动画  </p>
<ul>
<li><p>Mass Spring System 质点弹簧系统<br>  理想弹簧没有初始长度，且满足牛顿第三定律，用胡克定律求解作用力的大小<br>  在理想弹簧的基础上引入原长，就变成了非零长弹簧<br>  不考虑能量损失，非零长弹簧会始终保持运动的状态<br>  如果简单引入摩擦力，则所有运动最后都会停止<br>  无法考虑弹簧内部的相互作用力的影响 再引入一个内部的阻尼力<br>  最终得到:<br>  <img src="/Graphics/Fundamental/Animation/Spring.png" alt="Spring"><br>  红框内表示b与a的相对速度在二者连线方向上的投影，是一个标量，再乘以b到a的归一化方向以及劲度系数，就得到的b上的总阻力<br>  两个质点-&gt;弹簧系统，模拟纸或布料这种具有抗切变性质的材质<br>  <img src="/Graphics/Fundamental/Animation/Structures%20from%20Springs.png" alt="Structures from Springs"><br>  抗切变：对于平面内的力，普通质点弹簧系统一拉就会变形，而抗切变材质不会；对于非平面力，质点弹簧系统可以做到完美对折，而抗切变材质不会<br>  为了模拟这种情况，对原本的质点弹簧系统添加两步约束，如上图所示，一个是对角线的强约束，一个是跨顶点的弱约束<br>  依旧不够精确  </p>
</li>
<li><p>Particle Systems 粒子系统<br>  粒子生成的步骤如下：<br>  生成粒子 -&gt; 计算每个粒子的力 -&gt; 更新每个粒子的位置和速度 -&gt; 将死亡的粒子移除 -&gt; 渲染到屏幕<br>  粒子之间常见的作用力举例：重力，电磁力，摩擦力，空气阻力，粘滞力，碰撞等<br>  粒子的模拟不仅限于计算机图形，现实中的大自然如鸟群行为，细胞结构都可以通过粒子模拟  </p>
</li>
<li><p>Kinematics 运动学<br>  正向运动学 Forward Kinematics 是通过定义一些可活动关节（如铰链），通过计算来控制末端的点的运动<br>  逆向运动学 Inverse Kinematics 是艺术家习惯直接控制末端的点的运动，而不是控制关节来间接运动<br>  <img src="/Graphics/Fundamental/Animation/Forward%20Kinematics.png" alt="Forward Kinematics"><br>  <img src="/Graphics/Fundamental/Animation/Inverse%20Kinematics.png" alt="Inverse Kinematics">  </p>
</li>
<li><p>Rigging 角色绑定<br>  形象理解为提线木偶，是对逆运动学的一种应用<br>  角色的动作与动作之间原本需要对三维模型进行插值，现在只需要对骨骼插值即可  </p>
</li>
<li><p>Motion Capture 动作捕捉<br>  捕捉真实的控制点来生成动画<br>  光学动捕，在动捕演员的关键位置设置信号源，还有诸如应用了电磁波的或是直接纯机械的动捕，都可以达到最终目的  </p>
</li>
<li><p>The Production Pipeline<br>  <img src="/Graphics/Fundamental/Animation/The%20Production%20Pipeline.png" alt="The Production Pipeline">  </p>
</li>
</ul>
<h2 id="模拟方法"><a href="#模拟方法" class="headerlink" title="模拟方法"></a>模拟方法</h2><h3 id="Single-particle-simulation-单粒子模拟"><a href="#Single-particle-simulation-单粒子模拟" class="headerlink" title="Single particle simulation 单粒子模拟"></a>Single particle simulation 单粒子模拟</h3><p>模拟一个粒子的运动 假定一个速度场，在场内使用一阶常微分方程来得到其速度信息 计算得到速度之后，再用欧拉方法等各种手段，解出位置信息，得到模拟结果  </p>
<ul>
<li><p>Euler’s Method<br>对时间进行离散化，以一定步长细分时间，并每次用前一帧的计算结果更新当前帧的位置信息（前项欧拉）<br>前项欧拉 $x^{t+\Delta t} = x^t + \Delta t \dot{x}^t$<br>非前项欧拉 $\dot{x}^{t+\Delta t} = \dot{x}^t + \Delta t \ddot{x}^t$<br>不过，这么做容易造成很大的误差，并且稳定性也非常差<br>一旦步长低于一定精度，这种模拟就显得非常粗糙 在一些速度场中，产生的误差会被无限放大，出现正反馈现象  </p>
</li>
<li><p>Combating Instability  </p>
<ul>
<li><p>Midpoint Method 中点法<br>做了两次欧拉方法，第一次欧拉方法获得中点位置，在取中点位置的速度，再代入算一遍欧拉方法<br><img src="/Graphics/Fundamental/Animation/Midpoint%20Method.png" alt="Midpoint Method">  </p>
</li>
<li><p>Adaptive Step Size 自适应步长方法<br>也是算两遍欧拉，第一遍用$\Delta t$算，第二遍用$\frac{\Delta t}{2}$算，算完之后检验两次计算结果，如果偏差较大，则步长减半重新计算<br>这与直接减小步长的最大差别就是，他可以根据计算结果判断哪里应该用小步长，哪里用大步长，这就是所谓的“自适应”<br><img src="/Graphics/Fundamental/Animation/Adaptive%20Step%20Size.png" alt="Adaptive Step Size">  </p>
</li>
<li><p>Implicit Euler Method 隐式欧拉方法<br>又称后向欧拉方法，前向欧拉是每次计算都用前一帧数据，那后向计算顾名思义就是用未来的数据<br>需要求解非线性方程组，会用到牛顿法等求根算法，计算会慢，但稳定性相应也高 一阶稳定<br><img src="/Graphics/Fundamental/Animation/Implicit%20Euler%20Method.png" alt="Implicit Euler Method">  </p>
</li>
<li><p>Runge-Kutta Families<br>一种四阶的方法，稳定性非常好<br><img src="/Graphics/Fundamental/Animation/Runge-Kutta%20Families.png" alt="Runge-Kutta Families">  </p>
</li>
<li><p>Position-Based / Verlet Integration 非物理方法<br>如位置调整法，韦尔莱积分等 通过调整粒子的位置使其满足一些特定性质  </p>
</li>
</ul>
</li>
</ul>
<h3 id="Rigid-body-simulation-刚体模拟"><a href="#Rigid-body-simulation-刚体模拟" class="headerlink" title="Rigid body simulation 刚体模拟"></a>Rigid body simulation 刚体模拟</h3><p>刚体不会发生形变，并且内部所有粒子都以同一种运动方式运动<br>那么相对于粒子模拟只考虑位置和速度，刚体模拟会考虑更多的参数，如角度和角速度，角速度和角加速度等这些的对应关系<br><img src="/Graphics/Fundamental/Animation/Rigid%20Body%20Simulation.png" alt="Rigid Body Simulation">  </p>
<h3 id="Fluid-simulation-流体模拟"><a href="#Fluid-simulation-流体模拟" class="headerlink" title="Fluid simulation 流体模拟"></a>Fluid simulation 流体模拟</h3><p>流体模拟同样认为流体粒子不可压缩，且密度处处相等（变化前后密度也保持不变），那么任何时<br>刻，任意位置的流体粒子发生运动都会导致其周围粒子的密度发生变化（马尔科夫链），而要使运动前后密度不变，就需要通过改变流体粒子位置来修正  </p>
<blockquote>
<p>有两种主流的模拟思想，拉格朗日视角（质点法）和欧拉视角（网格法）<br>前一种是逐个进行单粒子模拟，后一种是将空间定义为多个网格单元，通过观察网格来决定如何模拟<br>将上述两种思想结合，就是现在流行的材质点方法（MPM）<br>具体做法是，先将属性参数储存在粒子上（拉格朗日视角），再在模拟变换的过程中运用欧拉视角进行模拟计算，最后将每一个时刻网格的信息写回网格内的粒子上，并渲染到屏幕上  </p>
</blockquote>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Geometry</title>
    <url>/Graphics/Fundamental/Geometry/</url>
    <content><![CDATA[<h1 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry"></a>Geometry</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="Implicit-隐式几何"><a href="#Implicit-隐式几何" class="headerlink" title="Implicit 隐式几何"></a>Implicit 隐式几何</h3><p>不会告诉任何点的信息，只会告诉该曲面上所有点满足的关系<br>f(x,y,z) = 0<br>容易判断点在物体内外<br>具体表示方法:  </p>
<ul>
<li>Algebraic Surfaces 代数曲面<br>  f(x,y,z) = 0  </li>
<li>Constructive Solid Geometry (CSG)<br>  通过基本几何的基本布尔运算形成新的几何<br>  <img src="/Graphics/Fundamental/Geometry/csg.png" alt="csg">  </li>
<li>Signed Distance Functions (SDF) 符号距离函数<br>  通过空间中的点到几何体的最小距离描述几何体<br>  距离函数是描述表面的函数,两个距离函数相加,就是两个物体表面的特征融合相加<br>  <img src="/Graphics/Fundamental/Geometry/sdf.png" alt="sdf"><br>  如图定义空间中每一个点的SDF为该点到阴影区域右边界的垂直距离，对这两个距离函数选择性的做一些运算得到最终的距离函数，采用最简单的SDF = SDF(A)+SDF(B)，最终得到的SDF为零的点的集合即为blend之后曲面<br>  只需合理定义空间中任意一个点的SDF，再令SDF为0即可得到混合的效果了  </li>
<li>Level Set Methods水平集<br>  像是SDF的一种特殊形式 找出函数值为0的地方作为曲线 对该面内的每一个点利用已经定义好的格子值进行双线性插值就可以得到任意一点的函数值，找出所有=0的点作为曲面<br>  <img src="/Graphics/Fundamental/Geometry/lsm.png" alt="lsm">  </li>
<li>Fractals 分型几何<br>  类似递归 自相似的形体所组成  </li>
</ul>
<h3 id="Explict-显式几何"><a href="#Explict-显式几何" class="headerlink" title="Explict 显式几何"></a>Explict 显式几何</h3><p>所有曲面的点被直接给出，或者可以通过映射关系得到<br>f(u,v) = ((2+cosu)cosv,(2+cosu)sinv,sinu) 通过uv即可找到所有点值<br>难以判断点在物体内外<br>具体表示方法:  </p>
<ul>
<li>Point Cloud 点云<br>  一堆点  </li>
<li>Polygon Mesh 多边形网格<br>  定义各个多边形面的顶点以及顶点之间的连接关系得到三角形面或是四边形面<br>  .obj模型文件<br>  <img src="/Graphics/Fundamental/Geometry/obj.png" alt="obj"><br>  3-10行定义了立方体的8个顶点信息 12-25行定义了这些顶点的纹理坐标信息(每个面4个点，共6个面所以最多有24种不同的纹理坐标信息，这里有一些纹理对于不同面上的点是公用的) 27-34行定义了6个面的法线信息，8个是因为建模软件输出的精度问题 其中有两个是重复的 36-47行f代表一个面，其中x/x/x的第一位表示是哪个顶点，第二位表示该顶点纹理坐标是第几个，第三位表示法线信息是第几个 3个 x/x/x表示3个顶点的信息构成一个面  </li>
</ul>
<h2 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h2><h3 id="Bezier-Curves-贝塞尔曲线"><a href="#Bezier-Curves-贝塞尔曲线" class="headerlink" title="Bézier Curves(贝塞尔曲线)"></a>Bézier Curves(贝塞尔曲线)</h3><p><img src="/Graphics/Fundamental/Geometry/bezier.png" alt="bezier"><br>曲线会与初始与终止端点相切，并且经过起点p0与终点p3<br>给定一个参数t∈[0,1]就能确定贝塞尔曲线上的一点，倘若取完所有t值，就能得到完整的贝塞尔曲线  </p>
<h3 id="de-Casteljau-Algorithm-画贝塞尔曲线"><a href="#de-Casteljau-Algorithm-画贝塞尔曲线" class="headerlink" title="de Casteljau Algorithm 画贝塞尔曲线"></a>de Casteljau Algorithm 画贝塞尔曲线</h3><p><img src="/Graphics/Fundamental/Geometry/Casteljau.png" alt="Casteljau"><br>核心就是多次的线性插值，并在生成的新的顶点所连接构成的线段之上递归的执行这个过程，直到得到最后一个顶点  </p>
<h3 id="Algebraic-Formula-代数公式"><a href="#Algebraic-Formula-代数公式" class="headerlink" title="Algebraic Formula 代数公式"></a>Algebraic Formula 代数公式</h3><p><img src="/Graphics/Fundamental/Geometry/threepoints.png" alt="threepoints"><br>塞尔曲线方程恰好就是一个关于参数 t 的二次方程，控制点的系数很像二项系数<br><img src="/Graphics/Fundamental/Geometry/Algebraic%20Formula.png" alt="Algebraic Formula"><br>伯恩斯坦多项式</p>
<h3 id="Properties-of-Bezier-Curves-性质"><a href="#Properties-of-Bezier-Curves-性质" class="headerlink" title="Properties of Bézier Curves 性质"></a>Properties of Bézier Curves 性质</h3><ol>
<li>必定经过起始与终止控制点</li>
<li>必定经与起始与终止线段相切</li>
<li>具有仿射变换性质，可以通过移动控制点移动整条曲线</li>
<li>凸包性质，曲线一定不会超出所有控制点构成的多边形范围</li>
</ol>
<h3 id="Piecewise-Bezier-Curves-分段贝塞尔曲线"><a href="#Piecewise-Bezier-Curves-分段贝塞尔曲线" class="headerlink" title="Piecewise Bézier Curves 分段贝塞尔曲线"></a>Piecewise Bézier Curves 分段贝塞尔曲线</h3><p><img src="/Graphics/Fundamental/Geometry/piecewise.png" alt="piecewise"><br>拼接光滑 一阶连续(连接点导数的左右极限相等)，二阶连续等<br>其它曲线: B-splines等  </p>
<h2 id="Surfaces"><a href="#Surfaces" class="headerlink" title="Surfaces"></a>Surfaces</h2><h3 id="Bezier-Surfaces"><a href="#Bezier-Surfaces" class="headerlink" title="Bézier Surfaces"></a>Bézier Surfaces</h3><p><img src="/Graphics/Fundamental/Geometry/Bézier%20Surfaces.png" alt="Bézier Surfaces">  </p>
<h3 id="曲面形成"><a href="#曲面形成" class="headerlink" title="曲面形成"></a>曲面形成</h3><p><img src="/Graphics/Fundamental/Geometry/form%20Bézier%20Surfaces.png" alt="form Bézier Surfaces">  </p>
<p>设 u∈[0,1]，v∈[0,1]  </p>
<ol>
<li>在如红圈4个控制点之下利用u之前曲线的方法得到蓝色点，得到4个蓝色点。(灰色曲线分别为每列4个点所对应的贝塞尔曲线)</li>
<li>得到4个蓝色顶点之后，在这四个蓝色顶点的基础之下利用第二个参数v可以成功得出贝塞尔曲面上的正确一点</li>
<li>遍历所有的 u，v值就可以成功得到一个贝塞尔曲面</li>
</ol>
<h2 id="Mesh-Operations-Geometry-Processing"><a href="#Mesh-Operations-Geometry-Processing" class="headerlink" title="Mesh Operations: Geometry Processing"></a>Mesh Operations: Geometry Processing</h2><h3 id="Mesh-subdivision-曲面细分"><a href="#Mesh-subdivision-曲面细分" class="headerlink" title="Mesh subdivision 曲面细分"></a>Mesh subdivision 曲面细分</h3><p>将一个模型的面合理的分成更多小的面，从而提升模型精度，提高渲染效果  </p>
<h4 id="Loop-Subdivision"><a href="#Loop-Subdivision" class="headerlink" title="Loop Subdivision"></a>Loop Subdivision</h4><ol>
<li>生成更多三角形或顶点<br><img src="/Graphics/Fundamental/Geometry/split.png" alt="split"><br>连接每条边的中点生成一个新的三角形</li>
<li><p>调整这些三角形或顶点的位置  </p>
<ul>
<li>对新的顶点<br>  <img src="/Graphics/Fundamental/Geometry/newvert.png" alt="newvert"><br>  周围4个顶点的权重之和，各顶点权重如图所示，其余边上的新顶点处理类似  </li>
<li>对旧的顶点<br>  <img src="/Graphics/Fundamental/Geometry/oldvert.png" alt="oldvert"><br>  也是其自身以及邻接顶点的权重和，但权重的设置与该旧顶点度数有关  </li>
</ul>
</li>
</ol>
<h4 id="Catmull-Clark-Subdivision"><a href="#Catmull-Clark-Subdivision" class="headerlink" title="Catmull-Clark Subdivision"></a>Catmull-Clark Subdivision</h4><p>Loop细分针对所有三角形面，Catmull-Clark细分可以处理多边形面<br><img src="/Graphics/Fundamental/Geometry/Catmull-Clark.png" alt="Catmull-Clark"><br>对于所有不是四边形的面称之为Non-quad face<br>所有度不为4的顶点称之为Extraordinary vertex奇异点<br>细分步骤: 在每个面中都添加一个点，在每条边的中点也都添加一个点，面上的新顶点连接所有边上的新顶点<br><img src="/Graphics/Fundamental/Geometry/onesubdivision.png" alt="onesubdivision"><br>有几个Non-quad face，就会多出几个奇异点<br>新多出来的奇异点的度数与原来所在面的边数相等<br>第一次细分之后所有面都会变成四边形，且往后奇异点数目不再增加<br>各类顶点位置调整:<br><img src="/Graphics/Fundamental/Geometry/catmullrules.png" alt="catmullrules">  </p>
<h3 id="Mesh-simplification-曲面简化"><a href="#Mesh-simplification-曲面简化" class="headerlink" title="Mesh simplification 曲面简化"></a>Mesh simplification 曲面简化</h3><p>将一个模型的面合理的合成更少的面，从而降低模型精度，为特定情形下提供使用(如LOD技术)  </p>
<ul>
<li><p>edge collapsing 边坍缩<br><img src="/Graphics/Fundamental/Geometry/edgecollapsing.png" alt="edgecollapsing"><br>将一条边的两个顶点合成为一个顶点  </p>
</li>
<li><p>Quadric Error Metrics 二次误差度量<br><img src="/Graphics/Fundamental/Geometry/Quadric%20Error%20Metrics.png" alt="Quadric Error Metrics"><br>坍缩之后蓝色新顶点所在的位置与原来各个平面的垂直距离之和最小  </p>
</li>
</ul>
<ol>
<li>为模型每条边赋值，其值为坍缩这条边之后，代替两个老顶点的新顶点所能得到的最小二次误差度量</li>
<li>选取权值最小的边做坍缩，新顶点位置为原来计算得出使得二次误差最小的位置</li>
<li>坍缩完之后，与之相连其他的边的位置会改动，更新这些边的权值</li>
<li>重复上述步骤，直到到达终止条件(贪心)</li>
</ol>
<h3 id="Mesh-regularization-曲面规则化"><a href="#Mesh-regularization-曲面规则化" class="headerlink" title="Mesh regularization 曲面规则化"></a>Mesh regularization 曲面规则化</h3><p>将三角面都变的尽可能相同，提升模型效果</p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>GAMES101</title>
    <url>/Graphics/Fundamental/GAMES101/</url>
    <content><![CDATA[<h1 id="GAMES101笔记"><a href="#GAMES101笔记" class="headerlink" title="GAMES101笔记"></a>GAMES101笔记</h1><p><img src="/Graphics/Fundamental/GAMES101/CGCVdiff.png" alt="diff">  </p>
<h2 id><a href="#" class="headerlink" title="  "></a><img src="/Graphics/Fundamental/GAMES101/GAMES101.png" alt="GAMES101">  </h2><p>参考&amp;引用:  </p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1X7411F744/">https://www.bilibili.com/video/BV1X7411F744/</a></li>
<li><a href="https://www.zhihu.com/column/c_1249465121615204352">https://www.zhihu.com/column/c_1249465121615204352</a>  </li>
<li><a href="https://zhuanlan.zhihu.com/p/434498517">https://zhuanlan.zhihu.com/p/434498517</a>  </li>
<li><a href="https://blog.csdn.net/weixin_43803133/category_10303553.html">https://blog.csdn.net/weixin_43803133/category_10303553.html</a>  </li>
<li><a href="https://zhuanlan.zhihu.com/p/394932478">https://zhuanlan.zhihu.com/p/394932478</a>  </li>
</ul>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Materials</title>
    <url>/Graphics/Fundamental/Materials/</url>
    <content><![CDATA[<h1 id="Materials"><a href="#Materials" class="headerlink" title="Materials"></a>Materials</h1><h2 id="Material"><a href="#Material" class="headerlink" title="Material"></a>Material</h2><p>Material == BRDF<br>BRDF 描述单位受照面吸收能量后辐射出去的Radiance分布情况 就表示了材质如何与光线作用  </p>
<h3 id="Diffuse-Lambertian-Material-漫反射材质"><a href="#Diffuse-Lambertian-Material-漫反射材质" class="headerlink" title="Diffuse / Lambertian Material 漫反射材质"></a>Diffuse / Lambertian Material 漫反射材质</h3><p><img src="/Graphics/Fundamental/Materials/diffuse.png" alt="diffuse"><br>不同于经验性的blinn-phong模型用 Intensity/R² 来不准确地定义到达着色点的能量<br>由渲染方程(假设任意方向的入射光和出射光的Radiance和Irradiance都相等，着色点不吸收任何能量，且自发光项为0)推出的$f_r$以及定义的albedo反射率相乘可以控制材质颜色变化 引入反射率ρ，取值0~1让物体能够接受能量获得不同颜色的BRDF  </p>
<h3 id="Glossy-material-BRDF-光泽材质"><a href="#Glossy-material-BRDF-光泽材质" class="headerlink" title="Glossy material (BRDF)光泽材质"></a>Glossy material (BRDF)光泽材质</h3><p>介于漫反射和镜面反射之间 光线反射集中在一个小范围内  </p>
<h3 id="Ideal-reflective-refractive-material-BSDF-理想反射-折射材质"><a href="#Ideal-reflective-refractive-material-BSDF-理想反射-折射材质" class="headerlink" title="Ideal reflective / refractive material (BSDF*) 理想反射/折射材质"></a>Ideal reflective / refractive material (BSDF*) 理想反射/折射材质</h3><p>光线到达材质表面被吸收一部分，同时发生镜面反射和镜面折射  </p>
<ul>
<li><p>Perfect Specular Reflection<br>  <img src="/Graphics/Fundamental/Materials/Perfect%20Specular%20Reflection.png" alt="Perfect Specular Reflection"><br>  左图（正视图）观察入射角和出射角，右图（俯视图）观察方位角  </p>
</li>
<li><p>Specular Refraction<br>  Snell’s Law $\qquad n_i\sin\theta_i = n_t\sin\theta_t$<br>  可推得<br>  <img src="/Graphics/Fundamental/Materials/Law%20of%20Refraction.png" alt="Law of Refraction"><br>  <img src="/Graphics/Fundamental/Materials/refraction.png" alt="refraction"><br>  对于$\cos\theta$中根号项 需要保证大于0才能发生折射<br>  入射材质的折射率大于出射材质折射率时观察角度足够大会全反射  </p>
<ul>
<li>Fresnel Reflection<br>  物体的反射率其实与你的观察角度即有关，对于绝缘体来说观察角度与法线夹角越大，反射的程度就越大<br>  在相同的入射角情况下，不同的材质也具有不同的反射率，即具有不同的菲涅尔项<br>  计算精确的反射率<br>  <img src="/Graphics/Fundamental/Materials/Fresnel%20Term.png" alt="Fresnel Term"><br>  物体的反射率和入射角度，和入射空间的折射率，和物体的折射率有关<br>  下半部分为近似结果  </li>
</ul>
</li>
<li><p>双向散射分布函数(BSDF)<br>  描述反射的分布函数被称为双向反射分布函数（BRDF），那么描述折射也需要一种分布函数<br>  这种分布函数被称为双向折射(透射)分布函数（BTDF）<br>  BRDF和BTDF统称为双向散射分布函数（BSDF）<br>  $f_s=f_r+f_t$  </p>
</li>
</ul>
<h3 id="Microfacet-Material"><a href="#Microfacet-Material" class="headerlink" title="Microfacet Material"></a>Microfacet Material</h3><p>离得足够远的时候，微观表面可以被忽略，而最后看到一个宏观的结果  </p>
<ul>
<li>微观解释镜面反射 漫反射:<br>法线方向分布比较集中的镜面反射明显，而法线分布比较分散表面相对粗糙<br><img src="/Graphics/Fundamental/Materials/specular.jpg" alt="specular"><br>从微观看漫反射表面，每个微元表面都是完美镜面反射 当光线照射到物体表面时，一部分光线会与表面的许许多多的微小镜面发生镜面反射，另一部分光线则会折射进入物体内部<br>光线折射进入内部的时候会与物体的微小粒子不断发生碰撞并散射到随机方向，同时在碰撞的过程中一部分光线的能量会被吸收转换为热能，有些光线在多次碰撞之后能量消耗殆尽，则表示该光线完全被物体吸收。还有一部分折射到物体内部的光线会因为散射方向的随机性重新离开表面，而这部分光线就形成了漫反射<br>(不考虑光线散射出来离开表面的点可能并不是进入表面的点这种情形，次表面散射(Subsurface Scattering)技术考虑了 可见AdvancedTopics中半透明材质BSSRDF)<br>漫反射和次表面散射其实是相同物理现象，本质都是折射光的次表面散射的结果。唯一的区别是相对于观察尺度的散射距离 光的折射现象，建模为漫反射还是次表面散射，取决于观察的尺度<br><img src="/Graphics/Fundamental/Materials/diffuse.jpg" alt="diffuse">  </li>
</ul>
<p>有了微表面模型，我们就可以提出在微表面下的更精确的BRDF方程<br><img src="/Graphics/Fundamental/Materials/Microfacet%20BRDF.png" alt="Microfacet BRDF">  </p>
<ul>
<li>F为菲涅尔项；描述了物体表面在不同入射光角度下反射光线所占的比率  </li>
<li>D为法线分布函数，查询半程向量是否在法线分布内  </li>
<li>G为几何项，由于在微表面上，对于那些几乎和表面平行的入射光，很容易发生互相遮挡的现象，从而使得部分微表面失去作用，我们把这种光线角度称为掠射角度（Grazing Angle），在这种角度下的着色会非常亮，G项就起到了一定的修正作用  </li>
</ul>
<p>微表面模型可以得到非常真实的渲染结果，因为他本身就是基于物理的渲染（PBR/PBS） </p>
<p>以上为仅考虑微观镜面反射时的情况, 折射会造成能量损失, 所以很多模型会增加某一项去补回能量的损失.如 cook-torrance微表面模型, Kulla-Conty 模型(见RTR-PBR)  </p>
<h3 id="Isotropic-Anisotropic-Materials-BRDFs"><a href="#Isotropic-Anisotropic-Materials-BRDFs" class="headerlink" title="Isotropic / Anisotropic Materials (BRDFs)"></a>Isotropic / Anisotropic Materials (BRDFs)</h3><p>各向同性（Isotropic Materials）：微表面不存在方向性<br>各向异性（Anisotropic Materials）：微表面存在方向性 不锈钢,尼龙,天鹅绒<br>对BRDF 方向性是指如果入射光和出射光做一定方位角的旋转前后，BRDF方程不变<br><img src="/Graphics/Fundamental/Materials/Isotropic%20Anisotropic%20Materials.png" alt="Isotropic / Anisotropic Materials ">  </p>
<h3 id="Properties-of-BRDFs"><a href="#Properties-of-BRDFs" class="headerlink" title="Properties of BRDFs"></a>Properties of BRDFs</h3><p>Non-negativity 非负性：描述能量分布<br>Linearity 线性性：可以被拆分成不同项的线性组合（ambient，diffuse，specular)<br>Reciprocity principle 可逆性：调换入射出射方向，BRDF渲染结果严格不变<br>Energy conservation 能量守恒：出射光线的能量永远不能超过入射光线的能量<br>Isotropic vs. anisotropic 各向同/异性：如果是各项同性材质，则BRDF值只和相对方位角有关，四维的BRDF材质可以被降维为三维，并且根据可逆性，结果不需要考虑方位角的正负  </p>
<h3 id="Measuring-BRDFs"><a href="#Measuring-BRDFs" class="headerlink" title="Measuring BRDFs"></a>Measuring BRDFs</h3><p><img src="/Graphics/Fundamental/Materials/Image-Based%20BRDF%20Measurement.png" alt="Image-Based BRDF Measurement"><br>给定一个着色点，通过改变入射和出射的角度（改变光源与相机位置）进行测量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">foreach outgoing direction wo</span><br><span class="line">    move light to illuminate surface with a thin beam from wo</span><br><span class="line">    <span class="keyword">for</span> each incoming direction wi</span><br><span class="line">        move sensor to be at direction wi from surface</span><br><span class="line">        measure incident radianc</span><br></pre></td></tr></table></figure><br>这样测出来的BRDF是四维的，这样的测量是非常费时的<br>为了提高效率，我们可以尽量让材质呈各向同性<br>就像之前说的，这不仅可以让BRDF从四维降至三维，还能由光路可逆性再砍去一半的测量  </p>
<h2 id="Advanced-Appearance-Modeling-高级外观建模方法"><a href="#Advanced-Appearance-Modeling-高级外观建模方法" class="headerlink" title="Advanced Appearance Modeling 高级外观建模方法"></a>Advanced Appearance Modeling 高级外观建模方法</h2><ul>
<li>Non-surface models  <ul>
<li>Participating media 散射介质  </li>
<li>Hair / fur / fiber (BCSDF)  </li>
<li>Granular material 颗粒材质  </li>
</ul>
</li>
<li>Surface models  <ul>
<li>Translucent material (BSSRDF) 半透明材质  </li>
<li>Cloth  </li>
<li>Detailed material (non-statistical BRDF)  </li>
</ul>
</li>
<li>Procedural appearance 程序化生成材质  </li>
</ul>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Quaternion</title>
    <url>/Graphics/Fundamental/Quaternion/</url>
    <content><![CDATA[<h1 id="一、3D-中的方位与角位移"><a href="#一、3D-中的方位与角位移" class="headerlink" title="一、3D 中的方位与角位移"></a>一、3D 中的方位与角位移</h1><p><strong>方位</strong>：从上一方位旋转后的 结果值（单一状态，用欧拉角表示）<br><strong>角位移</strong>：相对于上一方位旋转后的 偏移量（用四元数、矩阵表示）</p>
<h2 id="1-欧拉角-Euler-angles"><a href="#1-欧拉角-Euler-angles" class="headerlink" title="1. 欧拉角 (Euler angles)"></a>1. 欧拉角 (Euler angles)</h2><p>定义：</p>
<ul>
<li>欧拉角可以用来描述任意旋转，将一个角位移分解为三个互相垂直轴的<strong>顺序旋转步骤</strong></li>
<li>旋转后，原来互相垂直的轴可能不再垂直，<strong>当前步骤只能影响下一个旋转步骤，不能影响之前的旋转步骤</strong>，通过这个特性我们可以选择 <strong>适合的旋转方式(如：YXZ)</strong> 来避免万像锁的发生</li>
<li>这里<strong>默认右手坐标系，逆时针为正</strong>，任意三个轴可以作为旋转轴，下图仅为举例<br>heading：绕<strong>惯性坐标系</strong>的 Y 轴旋转<br>yaw：绕<strong>模型坐标系</strong>的 Y 轴旋转 </li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/rollPichYaw.png" alt></p>
<p>优点：</p>
<ul>
<li>仅需要三个角度值，节省内存</li>
<li>表示直观（便于显示和输入方位）</li>
<li>任意三个数对于欧拉角都是合法的</li>
</ul>
<p>缺点：</p>
<ul>
<li>欧拉角之间求差值（角位移）困难</li>
<li>欧拉角的方位表达方式不唯一（n = n + 360）</li>
<li>由于三个角度不互相独立，可能产生：pich 135 = heading 180 + pich 45 + bank 180 的情况<br>（通过限制角的范围解决，heading 和 bank 限制在 -180 ～ 180，pitch 限制在 -90 ～90）</li>
<li>万向锁问题（避免方法：<strong>重新排列角度的旋转顺序</strong>，但万向锁仍可能产生）</li>
</ul>
<p>万向锁: </p>
<p><a href="http://v.youku.com/v_show/id_XNzkyOTIyMTI=.html">视频</a>  </p>
<ul>
<li>当沿着任意角位移 90 度时，导致两个方向的旋转轴同线，导致三次旋转中有两次旋转的效果是一样的<br>即：少了一个维度的旋转变化</li>
<li>如下图在万向锁的情况下没有单一的旋转轴可以实现箭头向下, 但仍可以旋转到想要的位置，必须同时旋转三个轴向，但此时物体没有按仅在一个平面中的直线轨迹转动, 而是走了个不规则的曲线，箭头如果是相机，则相机会发生抖动</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><img src="/Graphics/Fundamental/Quaternion/gimbalLock.png" alt></th>
<th style="text-align:center"><img src="/Graphics/Fundamental/Quaternion/gimbalLock.gif" alt></th>
<th style="text-align:center"><img src="/Graphics/Fundamental/Quaternion/gimbalLockRight.png" alt></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">万向锁</td>
<td style="text-align:center"><strong>发生万向锁后</strong>的旋转</td>
<td style="text-align:center">期望的旋转</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-四元数的相关知识"><a href="#2-四元数的相关知识" class="headerlink" title="2. 四元数的相关知识"></a>2. 四元数的相关知识</h2><h3 id="2-1-复数"><a href="#2-1-复数" class="headerlink" title="2.1 复数"></a>2.1 复数</h3><p>复数是一种复合的数字，$C_{复数} = a + b \cdot i$ ，其中 a、b 为实数，$i$ 为虚数，$i^2 = -1$</p>
<ul>
<li>复数通过 <strong>实部 a 和 虚部 b</strong> 构成的二维虚平面，将一维的数扩展到二维平面</li>
<li>$i$ 只是区分 实部  a 和 虚部 b 的标记，这样可以把复数用二维的向量表示<br>加法：$(a + bi) + (c + di) = (a + c) + (b+d)i$<br>乘法：$(a + bi) *(c + di) = (ac - bd) + (bc+ad)i$</li>
<li>复数乘以 $i$ 的几何意义，在二维平面上逆时针旋转 90 度<br>$(a + b \cdot i) <em> i = a</em>i + b*i^2 = -b + a \cdot i$ </li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/complex_number.png" alt></p>
<h3 id="2-2-欧拉旋转定理"><a href="#2-2-欧拉旋转定理" class="headerlink" title="2.2 欧拉旋转定理"></a>2.2 欧拉旋转定理</h3><p><img src="/Graphics/Fundamental/Quaternion/EularRotate.png" alt></p>
<p>这里 $a = cos \phi, b = sin \phi, \phi$ 是从上一方位到当前方位的角位移，复数值表示当前方位 则 $c_{方位} =  a + b \cdot i$ 在极坐标下表示为 $e_{方位} = cos \phi + sin \phi \cdot i$<br>在极坐标下，复数能够更方便的表示旋转角的变化：</p>
<ol>
<li><p><strong>连续的旋转可以用两个复数的乘积表示</strong><br>例： $e_1$ 为先旋转 $\phi$，$e_2$ 再旋转 $\theta$，则根据 $i^2 = -1$ 以及和差公式可得最后的方位</p>
<script type="math/tex; mode=display">
\begin{align}
e_1 &= cos \phi + sin \phi \cdot i \\
e_2 &= cos \theta + sin \theta \cdot i \\
e &= cos(\phi + \theta) + sin(\phi + \theta) \cdot i \\
&= (cos \phi \cdot cos \theta - sin \phi \cdot sin \theta) +(sin \phi \cdot cos \theta + cos \phi \cdot sin \theta) \cdot i \\
&= (cos \phi + sin \phi \cdot i )(cos \theta + sin \theta \cdot i) \\
&= e_1 \cdot e_2
\end{align}</script></li>
<li><p>在不知道当前角位移的情况下，<strong>可以通过当前方位+角位移计算出之后的方位</strong></p>
</li>
</ol>
<h3 id="2-3-三维空间旋转的拆分"><a href="#2-3-三维空间旋转的拆分" class="headerlink" title="2.3 三维空间旋转的拆分"></a>2.3 三维空间旋转的拆分</h3><p>四元数在表示三维空间旋转的方式时采用 <strong>轴角式（Axis-angle)</strong> 的旋转<br>轴角式旋转方法如下图，v 绕过原点的方向向量 u 逆时针旋转 $\theta$ 得到 v ’ （图中采用右手坐标系，逆时针旋转方向为正方向）</p>
<p><img src="/Graphics/Fundamental/Quaternion/axisAngle.png" alt></p>
<p>拆分轴角式旋转：</p>
<ol>
<li><p>如下图 A，假设 u 是单位向量</p>
<script type="math/tex; mode=display">
\begin{align}
v &= v_{||} + v_{\bot}\\
v_{||} &= v_{||}'\\
v_{||} &= proj_u(v) = {u \cdot v \over ||u||} \cdot {u \over ||u||} = {(u \cdot v)u \over ||u||^2} = (u \cdot v)u\\
v_{\bot} &= v - v_{||} = v - (u \cdot v)u
\end{align}</script></li>
<li><p>如下图 B，C：w 既垂直于 u 又垂直于 $v_{\bot}$</p>
<script type="math/tex; mode=display">
\begin{align}
w &= u \times v_{\bot}\\
||w|| &= ||u \times v_{\bot}|| \\
&= ||u|| \cdot ||v_{\bot}|| \cdot sin{\pi \over 2}\\
&= ||v_{\bot}|| \\\\
v_{\bot}' &= v_v' + v_w'\\
&= v_{\bot} \cdot cos\theta + w \cdot sin\theta \\
&= v_{\bot} \cdot cos\theta + (u \times v_{\bot})sin\theta
\end{align}</script></li>
<li><p>结合 1，2 可得</p>
<script type="math/tex; mode=display">
v' = v \cdot cos\theta + (u\cdot v)u(1 - cos\theta)+(u \times v)sin\theta</script></li>
</ol>
<p><img src="/Graphics/Fundamental/Quaternion/axisAngleSplit.png" alt></p>
<h2 id="3-四元数-Quaternion"><a href="#3-四元数-Quaternion" class="headerlink" title="3. 四元数 (Quaternion)"></a>3. 四元数 (Quaternion)</h2><blockquote>
<p>相对于复数的二维空间，为了解决三维空间的旋转变化问题，爱尔兰数学家 William Rowan Hamilton 把复数进行了推广，也就是四元数</p>
<p><strong>四元数包含旋转方向</strong>： 3D 中的一个旋转对应正向和反向旋转的两个四元数，不是一一对应的</p>
</blockquote>
<p>定义：<strong>四元数表示角位移的大小</strong></p>
<ul>
<li><p>与复数类似，四元数由 1 个实部 和 3 个虚部构成。其中，a、b、c 、d 为实数，$i$ 为虚数<br>$\vec Q_{四元数} = a + b \cdot i_x + c \cdot i_y + d \cdot i_z$</p>
</li>
<li><p>$i$ 代表旋转，$-i$ 代表反向旋转</p>
<script type="math/tex; mode=display">
\begin{align}
i_x * i_y * i_z &= i_x * i_x = i_y * i_y = i_z * i_z = -1\\
i_x &= i_y * i_z  = - i_z * i_y = - i_x\\
-i_y &= i_x * i_z \\
\end{align}</script><ul>
<li>四元数的 3 个虚数 $i$ 之间的乘法与向量之间的点积结果形式很类似，于是四元数有了另外一种表示形式<script type="math/tex; mode=display">
\begin{align}
\vec Q_{四元数} &= w + x \cdot i_x + y \cdot i_y + z \cdot i_z \\
&= (x, y, z, w) \\
&= (\vec u, w)
\end{align}</script></li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>平滑差值</strong>：slerp 和 squad 提供了方位间的平滑差值 <strong>（矩阵和欧拉角都没有这个功能）</strong></li>
<li>快速连接和角位移求逆：<br>多个角位移 ${四元数叉乘 \over \to}$ 单个角位移（比矩阵快）<br>反角位移 = 四元数的共轭（比矩阵快）</li>
</ul>
<p>缺点：</p>
<ul>
<li>四元数比欧拉角多存储一个数（当保存大量角位移时尤为明显，如存储动画数据）</li>
<li>浮点数舍入误差和随意输入，会导致四元数不合法（可以通过四元数标准化解决，确保四元数为单位大小）</li>
<li>难以直接使用</li>
</ul>
<h3 id="3-1-四元数的运算"><a href="#3-1-四元数的运算" class="headerlink" title="3.1 四元数的运算"></a>3.1 四元数的运算</h3><ul>
<li><p><strong>乘法，合并两个四元数的偏移量，得到总的角位移</strong><br>四元数的乘法有很多种，其中最常用的一种是格拉丝曼积，与数学多项式乘法相同（与复数乘法概念相同）<br>乘法满足结合律：abc = (ab)c = a(bc)<br>但不符合交换律：ab != ba</p>
<script type="math/tex; mode=display">
\begin{align}
\vec Q_1 \vec Q_2 &= w_1w_2 - \vec u_1 \cdot \vec u_2 + w_1 \vec u_2 + w_2 \vec u_1 + \vec u_1 \times \vec u_2\\
&= ((w_1 \vec u_2 + w_2 \vec u_1 +  \vec u_1 \times \vec u_2), (w_1w_2 - \vec u_1 \cdot \vec u_2))
\end{align}</script></li>
<li><p>四元数与标量相乘、点积、加法、叉乘、单位化，均与四维向量的点积相同，以点积为例</p>
<script type="math/tex; mode=display">
\begin{align}
\vec Q_1 \cdot \vec Q_2 &= (w_1, x_1, y_1, z_1)(w_2, x_2, y_2, z_2) \\
&= w_1w_2 + x_1 x_2 + y_1y_2 + z_1z_2
\end{align}</script></li>
<li><p>求模：代表一个四维的长度，与向量的求模方法一致</p>
<script type="math/tex; mode=display">
||\vec Q|| = \sqrt{w^2 + \vec u \cdot \vec u} = \sqrt{w^2 + x^2 + y^2 + z^2}</script></li>
<li><p>共轭：实部相同，虚部相反（与复数共轭概念相同）</p>
<script type="math/tex; mode=display">
\vec  Q^* \vec  Q = (-\vec u, w) (\vec u,w) = ||\vec Q||^2 = \vec Q \cdot \vec Q</script></li>
<li><p>求逆：<strong>为了计算四元数的 “差”</strong>，例<br>给定方位 A 和 B，求 A 旋转到 B 的<strong>角位移 d</strong>，即：Ad = B，$d = A^{-1}B$</p>
<script type="math/tex; mode=display">
\begin{align}
\vec Q\vec Q^{-1} &= 1\\
\vec Q^* \vec Q\vec Q^{-1} &= \vec Q^*\\
||\vec Q||^2 \cdot \vec Q^{-1} &= \vec Q^*\\
\vec Q^{-1} &= {\vec Q^* \over ||\vec Q||^2}\\
\end{align}</script></li>
<li><p>单位四元数：任意四元数乘以单位四元数后保持不变，$(\vec 0, \pm 1)$，模为 1<br><strong>单位四元数的 逆 = 共轭</strong>，由于共轭比逆好求出，一般用四元数的共轭代替逆使用<br>几何上存在两个单位四元数 -u 和 u，因为他们几何意义相同都表示没有位移，但数学上只有 u</p>
<script type="math/tex; mode=display">
Q_{单位} = {Q \over ||Q||}\\
Q_{单位}Q_1 = Q_1Q_{单位} = Q_1\\
((w_1 \vec u + w \vec u_1 +  \vec u_1 \times \vec u), (w_1w - \vec u_1 \cdot \vec u)) = (\vec u_1, w_1)</script></li>
</ul>
<h3 id="3-2-四元数默认在极坐标下"><a href="#3-2-四元数默认在极坐标下" class="headerlink" title="3.2 四元数默认在极坐标下"></a>3.2 四元数默认在极坐标下</h3><p><strong>极坐标下的优势：使四元数的运算和向量的运算方法一致</strong></p>
<p>由 4.2.1 复数在笛卡尔坐标和极坐标的转换方式可得，四元数在</p>
<ul>
<li>笛卡尔坐标下为<br>$\vec Q = (x, y, z, w) = (\vec u, w)$</li>
<li>极坐标下为，其中 $\theta$ 为绕 $\vec u$ 旋转后的角位移（旋转方式见 4.2.3，<a href="https://krasjet.github.io/quaternion/quaternion.pdf">推导到极坐标</a>）<br>$\vec Q  = (x sin{\theta \over 2}, y sin{\theta \over 2},z sin{\theta \over 2}, cos{\theta \over 2}) = (\vec u sin{\theta \over 2}, cos{\theta \over 2})$</li>
</ul>
<p><strong>只有旋转轴 u 为单位向量时，下面公式才成立</strong></p>
<ul>
<li><p>用指数代替四元数：根据旋转角位移 $\theta$ 和旋转轴 u 求出四元数</p>
<script type="math/tex; mode=display">
e^{(\vec u {\theta \over 2}, 0)} = (\vec usin{\theta \over 2}, cos{\theta \over 2})</script></li>
<li><p>对数：根据四元数和旋转轴 u 求出旋转角位移 $\theta$</p>
<script type="math/tex; mode=display">
log_e(（\vec u sin{\theta \over 2}, cos{\theta \over 2}）) = (\vec u {\theta \over 2}, 0)</script></li>
<li><p>将点 P 绕 $\vec{u}$ 旋转 $\theta$ 度<br>$P_{旋转后} = aPa^{-1} = aPa^*, a = (\vec u sin{\theta \over 2}, cos{\theta \over 2})$</p>
</li>
<li><p>将点 P 绕 $\vec{u}$ 旋转 $\theta$ 度后再旋转 $\alpha$ 度（方位的叠加是点乘）<br>$P_{旋转后} = baPa^{-1}b^{-1} = (ba)P(ba)^{-1},a = (\vec u  sin{\theta \over 2},cos{\theta \over 2}),b = (\vec u sin{\alpha \over 2},cos{\alpha \over 2})$</p>
</li>
<li><p><strong>四元数求幂</strong>：四元数的 x 次幂等同于将它的旋转角缩放 x 倍</p>
<script type="math/tex; mode=display">
(\vec u sin{\theta \over 2}, cos{\theta \over 2})^x
= (\vec u {sin({\theta \over 2}x)\over sin{\theta \over 2}}, cos({\theta \over 2}x))</script></li>
</ul>
<p>四元数 * 向量 = 旋转后的向量，例：<br>设 用四元数 q = (u, w)，u 为单位向量，旋转三维向量 v，则</p>
<script type="math/tex; mode=display">
\begin{align}
p &= (v, 0)\\
p'&= qpq^{-1} = qpq^* = (u,w)(v,0)(-u,w)\\
&= (2(u\cdot v)u + (w^2 -u\cdot v)v + 2w(u \times v),...)\\
&= (v',...)
\end{align}</script><h3 id="3-3-四元数的常用插值方法"><a href="#3-3-四元数的常用插值方法" class="headerlink" title="3.3 四元数的常用插值方法"></a>3.3 四元数的常用插值方法</h3><p>所有插值用的旋转四元数<strong>都是单位四元数</strong><br>插值要采用弧面最短路径</p>
<ul>
<li>$Q$ 和 $-Q$ 代表不同的旋转角度得到的相同方位，在插值时会有不同的结果，如下图：可以将 q0 和 q1（蓝色的弧）插值，这会导致 3D 空间的向量旋转接近 360 度，而实际上这两个旋转相差并没有那么多，所以 q0 和 -q1（红色的弧）的插值才是插值的最短路径</li>
<li>每次插值前要通过 $cos\theta = q_0 \cdot q_1$ 判断 q0 和 q1 的夹角是否为钝角，若为钝角将 q1 改为 -q1 来计算插值</li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/Interpolation.png" alt></p>
<p><strong>线形插值</strong>（Lerp：<strong>L</strong>inear Int<strong>erp</strong>olation）</p>
<ul>
<li>对四元数插值后，得到的结果不是单位四元数，插值的弧度越大缺点越明显</li>
<li>公式：$Q_t = (1- t)Q_0 + t Q_1, t$ 为插值比例</li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/Lerp.png" alt></p>
<p><strong>正规化线性插值</strong>（Nlerp：<strong>N</strong>ormalized <strong>L</strong>inear Int<strong>erp</strong>olation）</p>
<ul>
<li>对四元数插值后，虽然把弦等分了，但是弦上对应的弧却不是等分的，插值的弧度越大缺点越明显<br>{ % raw % }</li>
<li>公式：$Q_t = { { (1- t)Q_0 + tQ_1}\over{||(1- t)Q_0 + tQ_1||} }, t$ 为插值比例<br>{ % endraw % }</li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/NLerp.png" alt></p>
<p><strong>旋转角度球面线性插值</strong>（Slerp：<strong>S</strong>pherical <strong>L</strong>inear Int<strong>erp</strong>olation）</p>
<ul>
<li>对单个角度做线形插值，做到固定角速度，无法平滑过渡连接不同方向的角度</li>
<li><p>公式 1：这里用的四元数都是单位四元数，所以有 $Q^{-1} = Q^*,  t$ 为插值比例</p>
<script type="math/tex; mode=display">
Q_t = Q_0(Q_0^{-1}Q_1)^t = Q_0(Q_0^* Q_1)^t​</script></li>
<li><p>公式 2：效率比公式 1 高，其中 $\theta = cos^{-1}(Q_0\cdot Q_1)$</p>
<script type="math/tex; mode=display">
Q_t = {sin((1 - t)\theta) \over sin\theta} Q_0 + {sin(t\theta) \over sin\theta}Q_1</script></li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/Slerp.png" alt></p>
<p><strong>Slerp 和 Nlerp 的比较</strong></p>
<ul>
<li>效率上 Nlerp 比 Slerp 高<br>效果上 Nlerp 和 Slerp 在单位四元数之间的夹⻆ θ 非常小时差别不大，夹角越大 Nlerp 的效果越差</li>
<li>单位四元数之间的夹⻆ θ 非常小，那么 sinθ 可能会由于浮点数的误差被近似为 0.0，从而导致除以 0 的错误。我们在实施 Slerp 之前，需要检查两个四元数的夹⻆是否过小一旦发现这种问题，我们就必须改用 Nlerp 对两个四元数进行插值，这时候 Nlerp 的误差非常小所以基本不会与真正的 Slerp 有什么区别 </li>
</ul>
<h3 id="3-4-贝塞尔曲线和-Squad-插值"><a href="#3-4-贝塞尔曲线和-Squad-插值" class="headerlink" title="3.4 贝塞尔曲线和 Squad 插值"></a>3.4 贝塞尔曲线和 Squad 插值</h3><p><strong>样条（Spline）</strong>：在一个向量序列 $v_0,v_1,…,v_n$ 中分别对每对向量 $v_i,v_{i+1}$ 进行插值后互相连接得到的曲线</p>
<p><strong>贝塞尔曲线（Bézier）</strong>：通过不断在现有点的基础上添加控制点，使最终得到的曲线更加平滑</p>
<p><img src="/Graphics/Fundamental/Quaternion/bezier.png" alt></p>
<p>三次贝塞尔曲线：</p>
<p><img src="/Graphics/Fundamental/Quaternion/bezier.gif" alt></p>
<p><img src="/Graphics/Fundamental/Quaternion/bezier2.png" alt></p>
<p><img src="/Graphics/Fundamental/Quaternion/bezier3.png" alt></p>
<p>插值方式可以用 lerp、Slerp 等方式，上图采用 de Casteljau 算法构造贝塞尔曲线<br>上图采用 lerp 方式插值，插值方程为：</p>
<script type="math/tex; mode=display">
v_t = (1 − t)^3v_0 + 3(1 − t)^2tv_1 + 3(1 − t)t^2v_2 + t^3v_3</script><p>$de Casteljau$ 算法构造贝塞尔曲线的过程为：</p>
<ul>
<li>第一次贝塞尔曲线，由相邻的基础点得到插值点 $v_{01}、v_{12}、v_{23}$</li>
<li>第二次贝塞尔曲线，由上次贝塞尔的插值点得到本次的插值点 $v_{012}、v_{123}$</li>
<li>第三次贝塞尔曲线，由上次贝塞尔的插值点得到本次的插值点 $v_{0123}$</li>
</ul>
<p><strong>球面四边形插值</strong>（Squad：<strong>S</strong>pherical and <strong>Quad</strong>rangle）</p>
<ul>
<li>平滑过渡连接不同方向的旋转角，效率最低，效果最好</li>
<li>Squad 的插值方法类似贝塞尔曲线的构造过程，<strong>由于取基础点的方式不同，效率比构造贝塞尔曲线要高</strong><br>Squad 的插值过程中可以用 lerp、Slerp 等方式插值<br>如果使用 lerp 插值，<strong>插值参数为 2t(1-t)，而非 t</strong><br>插值方程为：</li>
</ul>
<script type="math/tex; mode=display">
v_t = (2t^2 − 2t + 1)(1 − t)v_0 + 2(1 − t)^2tv_1 + 2(1 − t)t^2v_2 + t(2t^2 − 2t + 1)v_3</script><p>  插值步骤为：</p>
<ol>
<li>由基础点得到插值点 $v_{12}，v_{03}$</li>
<li>根据上次的插值点得出本次的插值点 $v_{0312}$</li>
</ol>
<p><img src="/Graphics/Fundamental/Quaternion/Squad.png" alt></p>
<p>三次贝塞尔曲线和 Squad 插值构造的曲线对比：</p>
<p><img src="/Graphics/Fundamental/Quaternion/comparedBS.png" alt></p>
<h2 id="4-欧拉角、旋转矩阵、四元数的互相转换"><a href="#4-欧拉角、旋转矩阵、四元数的互相转换" class="headerlink" title="4 欧拉角、旋转矩阵、四元数的互相转换"></a>4 欧拉角、旋转矩阵、四元数的互相转换</h2><h3 id="4-1-欧拉角和旋转矩阵"><a href="#4-1-欧拉角和旋转矩阵" class="headerlink" title="4.1 欧拉角和旋转矩阵"></a>4.1 欧拉角和旋转矩阵</h3><p>欧拉角 -&gt; 旋转矩阵</p>
<ul>
<li><p>这里的旋转矩阵和 [2.4 Rotate] 类似，这里的欧拉角操作的模型的坐标系</p>
</li>
<li><p>设在<strong>右手坐标系</strong>，矩阵<strong>列向量</strong>存储，旋转角<strong>逆时针</strong>为正方向（改变的角度方向取反），则<br>最后的转换矩阵为 Heading/Pich/Roll 按需要的顺序相乘的结果（HPR 为相机避免万向死锁的最佳顺序）</p>
<script type="math/tex; mode=display">
\begin{align}
Heading &= 
\begin{bmatrix}
cosH & 0 & sinH\\
0 & 1 & 0\\
-sinH & 0 & cosH
\end{bmatrix} \\
Pich &=
\begin{bmatrix}
1 & 0 & 0\\
0 & cosP & -sinP\\
0 & sinP & cosP
\end{bmatrix} 
\\
Roll &=
\begin{bmatrix}
cosR & -sinR & 0\\
sinR & cosR & 0\\
0 & 0 & 1
\end{bmatrix} \\
M_{HPR} &= 
\begin{bmatrix}
cosHcosR+sinHsinPsinR & -cosHsinR+sinHsinPcosR & sinHcosP \\
sinRcosP & cosRcosP & -sinP\\
-sinHcosR+cosHsinPsinR & sinRsinH+cosHsinPcosR & cosHcosP
\end{bmatrix}
\end{align}\\</script></li>
</ul>
<p><img src="/Graphics/Fundamental/Quaternion/rollPichYaw.png" alt></p>
<p>旋转矩阵 -&gt; 欧拉角</p>
<blockquote>
<p>转换后的欧拉角是限制欧拉角，即 Heading 和 Roll 范围为 $\pm$ 180 度，Pich 的范围为 90 度 </p>
</blockquote>
<p>当矩阵每列都是单位向量时，矩阵为正交矩阵，则</p>
<script type="math/tex; mode=display">
M \cdot M^{-1} = M \cdot M^T = I\\
M^{-1} = M^T\\</script><ol>
<li>若 $Pich \neq \pm 90$，由欧拉角转矩阵的公式可得：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}
m11 & m12 & m13\\
m21 & m22 & m23\\
m31 & m32 & m33
\end{bmatrix}
&= 
\begin{bmatrix}
cosHcosR+sinHsinPsinR & -cosHsinR+sinHsinPcosR & sinHcosP \\
sinRcosP & cosRcosP & -sinP\\
-sinHcosR+cosHsinPsinR & sinRsinH+cosHsinPcosR & cosHcosP
\end{bmatrix}\\
\\
m23 &= -sinP\\
arcsin(-m23) &= P\\
\\
m13 &= sinHcosP\\
m33 &= cosHcosP\\
{m13 \over m33} &= tanH\\
arctan({m13 \over m33}) &= H\\
\\
m21 &= sinRcosP\\
m22 &= cosRcosP\\
arctan({m21 \over m22}) &= R\\
\end{align}</script><ol>
<li>若 $Pich = \pm 90$，是万向锁情况，此时 Heading 和 Roll 绕同样的轴竖直旋转，默认旋转的最后一步 Roll 不转，即 Roll = 0 ，由欧拉角转矩阵的公式可得：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}
m11 & m12 & m13\\
m21 & m22 & m23\\
m31 & m32 & m33
\end{bmatrix}
&= 
\begin{bmatrix}
cosH & sinHsinP & 0 \\
0 & 0 & -sinP\\
-sinH & cosHsinP & 0
\end{bmatrix}\\
\\
m11 &= cosH\\
m13 &= -sinH\\
-arctan({m13\over m11}) &= H
\end{align}</script><h3 id="4-2-四元数和旋转矩阵"><a href="#4-2-四元数和旋转矩阵" class="headerlink" title="4.2 四元数和旋转矩阵"></a>4.2 四元数和旋转矩阵</h3><p>四元数 -&gt; 旋转矩阵 </p>
<p>设四元数为 $\vec Q = (\vec n, cos{ \theta \over 2 }) = (x,y,z,w)$，绕 n 旋转 $\theta$ ，由 <a href="#2.4 Rotate">2.4 Rotate</a> 沿任意方向旋转的矩阵 得旋转矩阵 M：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
(1-cos\theta)x^2 + cos\theta & (1-cos\theta)yx+sin\theta z & (1-cos\theta)zx - sin\theta y\\
(1-cos\theta)xy - sin\theta z & (1-cos\theta)y^2 + cos\theta & -(1-cos\theta)zy + sin\theta x\\
(1-cos\theta)xz + sin\theta y & (1-cos\theta)yz - sin\theta x & (1-cos\theta)z^2 + cos\theta
\end{bmatrix}
\to M = 
\begin{bmatrix}
1-2y^2-2z^2 & 2xy+2wz & 2xz-2wy\\
2xy-2wz & 1-2x^2-2z^2 & 2yz+2wx\\
2xz+2wy & 2yz-2wx & 1-2x^2-2y^2
\end{bmatrix}</script><p>旋转矩阵 -&gt; 四元数</p>
<ol>
<li>由四元数转旋转矩阵可知：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}
m11 & m12 & m13\\
m21 & m22 & m23\\
m31 & m32 & m33
\end{bmatrix}
&= 
\begin{bmatrix}
1-2y^2-2z^2 & 2xy+2wz & 2xz-2wy\\
2xy-2wz & 1-2x^2-2z^2 & 2yz+2wx\\
2xz+2wy & 2yz-2wx & 1-2x^2-2y^2
\end{bmatrix}\\\\
m11+m22+m33
&= (1-2y^2-2z^2)+(1-2x^2-2z^2)+(1-2x^2-2y^2)\\
&= 3-4(x^2+y^2+z^2)\\
&= 3-4(1-w^2)\\
&= 4w^2-1\\
\\
w&={\sqrt{m11+m22+m33+1} \over 2}


\end{align}</script><ol>
<li>使 m11、m22、m33 其中两个为负，一个为正可得：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
x &={\sqrt{m11-m22-m33+1} \over 2}\\
y &={\sqrt{-m11+m22-m33+1} \over 2}\\
z &={\sqrt{-m11-m22+m33+1} \over 2}
\end{align}</script><p>以上方法得到的<strong>四元数总是正的</strong>，没有判断四元数符号的依据</p>
<ol>
<li>在由：</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
m12 + m21 &= 4xy\\
m12 - m21 &= 4wz\\
m31 + m13 &= 4xz\\
m31 - m13 &= 4wy\\
m23 + m32 &= 4yz\\
m23 - m32 &= 4wx\\
\end{align}</script><ol>
<li><p>综上可得：</p>
<script type="math/tex; mode=display">
\begin{align}
x &= {m23-m32 \over 4w}\\
情况一、w ={\sqrt{m11+m22+m33+1} \over 2} \to  y &= {m31-m13 \over 4w}\\
z &= {m12-m21 \over 4w}\\
\\
w &= {m23-m32 \over 4x}\\
情况二、x ={\sqrt{m11-m22-m33+1} \over 2} \to  y &= {m12+m21 \over 4x}\\
z &= {m31+m13 \over 4x}\\
\\
w &= {m31-m13 \over 4y}\\
情况三、y ={\sqrt{-m11+m22-m33+1} \over 2} \to  x &= {m12+m21 \over 4y}\\
z &= {m23+m32 \over 4y}\\
\\
w &= {m12-m21 \over 4z}\\
情况四、z ={\sqrt{-m11-m22+m33+1} \over 2} \to  x &= {m31+m13 \over 4z}\\
y &= {m23+m32 \over 4z}
\end{align}</script></li>
<li><p>取 1、2 中得到的 w、x、y、z 的最大值是哪个来判断，选择哪种情况</p>
</li>
</ol>
<h3 id="4-3-欧拉角和四元数"><a href="#4-3-欧拉角和四元数" class="headerlink" title="4.3 欧拉角和四元数"></a>4.3 欧拉角和四元数</h3><p>四元数 -&gt; 欧拉角</p>
<p>由 旋转矩阵 转 四元数 和 旋转矩阵 转 欧拉角的条件可得：</p>
<script type="math/tex; mode=display">
\begin{align}
P &= asin(-2(yz+wx)) \\
H &=
\begin{cases}
atan2(xz-wy, 0.5 - x^2 - y^2),& \cos P \neq 0 \\
atan2(-xz-wy, 0.5 - y^2 - z^2),& \cos P = 0
\end{cases}\\
R &=
\begin{cases}
atan2(xy-wz,0.5 - x^2 - z^2),& \cos P \neq 0\\
0,& \cos P = 0
\end{cases}
\end{align}</script><p>欧拉角 -&gt; 四元数</p>
<p>由四元数的公式得，在<strong>右手坐标系</strong>下的欧拉角列向量 H、P、R 为：</p>
<script type="math/tex; mode=display">
HPR=
\begin{bmatrix}
cos{H \over 2}\\\\ 0 \\-sin{H \over 2}\\ 0
\end{bmatrix}
\begin{bmatrix}
cos{P \over 2}\\\\ -sin{H \over 2} \\0 \\0
\end{bmatrix}
\begin{bmatrix}
cos{R \over 2}\\\\ 0\\ 0\\-sin{H \over 2}
\end{bmatrix}
= 
\begin{bmatrix}
cos{H \over 2}cos{P \over 2}cos{R \over 2}+sin{H \over 2}sin{P \over 2}sin{R \over 2}\\\\ 
-cos{H \over 2}sin{P \over 2}cos{R \over 2}-sin{H \over 2}cos{P \over 2}sin{R \over 2} \\
cos{H \over 2}sin{P \over 2}sin{R \over 2}-sin{H \over 2}cos{P \over 2}cos{R \over 2} \\
sin{H \over 2}sin{P \over 2}cos{R \over 2}-cos{H \over 2}cos{P \over 2}sin{R \over 2} 
\end{bmatrix}</script><p><img src="/Graphics/Fundamental/Quaternion/rollPichYaw.png" alt></p>
<h2 id="5-SQT-变换"><a href="#5-SQT-变换" class="headerlink" title="5. SQT 变换"></a>5. SQT 变换</h2><blockquote>
<p>四元数只能表示旋转，但是 4 X 4 的矩阵却可以表示旋转、平移、缩放</p>
</blockquote>
<p>SQT 变换矩阵：四元数、平移向量、缩放向量/缩放统一系数 构成的一个 4 X 3 的矩阵</p>
<p>使用 SQT 矩阵的目的：便于对 旋转、平移、缩放 的插值计算</p>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li><a href="http://v.youku.com/v_show/id_XNzkyOTIyMTI">欧拉角，万向锁 视频解释</a></li>
<li><a href="https://www.bilibili.com/video/av33385105/#reply1117064951">四元数的可视化解释</a><br>-<a href="https://blog.csdn.net/weixin_43803133/article/details/107520595">文字版解释</a></li>
<li><a href="https://krasjet.github.io/quaternion/">四元数与三维旋转</a></li>
<li><a href="https://qiita.com/HMMNRST/items/0a4ab86ed053c770ff6a">四元数在三维计算的几何意义</a></li>
</ul>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Rasterization</title>
    <url>/Graphics/Fundamental/Rasterization/</url>
    <content><![CDATA[<h1 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h1><p><img src="/Graphics/Fundamental/Rasterization/fov.png" alt="fov"></p>
<p>视锥由fovY和aspect即可定义<br>aspect ration = width/height<br>What is a screen?</p>
<ul>
<li>An array of pixels(1920*1080)</li>
<li>Size of the array: resolution</li>
<li>A typical kind of raster display</li>
</ul>
<p>Raster == screen in German</p>
<ul>
<li>Rasterize == drawing onto the screen</li>
</ul>
<p>Pixel (FYI, short for “picture element”)像素</p>
<ul>
<li>For now: A pixel is a little square with uniform color</li>
<li>Color is a mixture of (red, green, blue)</li>
<li>(x+0.5,y+0.5)为(x,y)像素的中心 像素从(0,0)到(width - 1,height - 1)</li>
</ul>
<p>所有变换之后 现在图片上仍是一堆多边形 下一步多边形打散成像素—<strong>光栅化 Drawing to Raster Displays</strong>  </p>
<h2 id="直线光栅化"><a href="#直线光栅化" class="headerlink" title="直线光栅化"></a>直线光栅化</h2><ul>
<li>DDA数值微分算法<br>  1.当|k|<1时，从起点开始画起每次x = x+1， y="y+k," 并将y四舍五入，得到新的x，y就是像素点应该画的地方 2.当|k|>1时，从起点开始画起每次y = y+1， x = x+1/k, 并将x四舍五入，得到新的x，y就是像素点应该画的地方  </1时，从起点开始画起每次x></li>
<li>中点Bresenham算法<br>  f(x,y)=y-kx-b 考虑0<k<1时 当f(x+1,y+0.5)> 0的时候中点在直线上方 选择右边，当f(x+1,y+0.5) &lt; 0的时候中点在直线下方 选择右上    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y=y0</span><br><span class="line"><span class="keyword">for</span> x=x0 to x1 <span class="keyword">do</span></span><br><span class="line">    draw(x,y)</span><br><span class="line">    <span class="keyword">if</span> f(x+<span class="number">1</span>,y+<span class="number">0.5</span>)&lt;<span class="number">0</span> then</span><br><span class="line">        y = y+<span class="number">1</span></span><br></pre></td></tr></table></figure>
  由于f(x,y)=(y0-y1)x+(x1-x0)y+x0y1-x1y0<br>  利用增量算法 f(x+1,y) = f(x,y)+y0-y1 f(x+1,y+1)=f(x,y)+y0-y1+x1-x0<br>  代码简化得    <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">y=y0</span><br><span class="line">d=f(x0+<span class="number">1</span>,y0+<span class="number">0.5</span>) - f(x0, y0)=y0-y1+<span class="number">0.5</span>(x1-x0)</span><br><span class="line"><span class="keyword">for</span> x=x0 to x1 <span class="keyword">do</span></span><br><span class="line">    draw(x,y)</span><br><span class="line">    <span class="keyword">if</span> d&lt;<span class="number">0</span> then</span><br><span class="line">        y = y+<span class="number">1</span></span><br><span class="line">        d = d+x1-x0+y0-y1</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        d = d+y0-y1</span><br><span class="line"><span class="comment">//为方便计算可将d相关都乘2 d=2(y0-y1)+x1-x0 d+=2(y0-y1) .. 由于只需判断d的正负所以乘二不影响结果</span></span><br></pre></td></tr></table></figure>
  实现时根据k的大小分情况 k绝对值&gt;1时x和y互换</k<1时></li>
</ul>
<h2 id="三角形光栅化-Sampling-采样"><a href="#三角形光栅化-Sampling-采样" class="headerlink" title="三角形光栅化 Sampling 采样"></a>三角形光栅化 Sampling 采样</h2><p>把蕴含几何信息的数据转化为屏幕上的像素 一条直线该用哪些像素点去逼近，一个三角形用哪些像素集合表示  </p>
<p>三角形优势: 最基础多边形 一定在一个平面 内外定义清晰 定义三个顶点属性可以在内部渐变(重心坐标插值)  </p>
<p>关键: 确定像素中心点和三角形的关系  </p>
<p>将函数离散化discretize a function by sampling = Sample 2D Positions<br>Sampling is a core idea in graphics<br>对像素点中心采样  </p>
<script type="math/tex; mode=display">
inside(t, x, y) =
\begin{cases}
1,Point (x, y) \quad in \quad triangle t\\
0,otherwise
\end{cases}\\
x, y: not\quad necessarily\quad integers</script><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; xmax; ++x)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; ymax; ++y)</span><br><span class="line">image[x][y] = inside(tri,</span><br><span class="line">x + <span class="number">0.5</span>,</span><br><span class="line">y + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<p>inside具体实现:<br>判断点是否在三角形内 三边分别叉乘 想要光栅化的三角形的三个顶点P0，P1，P2，以及检测点Q 分别计算P0P1×P0Q，P1P2×P1Q，P2P0×P2Q，三者同号则代表Q处于三角形内部，不同号则在三角形外部  </p>
<p>效率提升:<br>包围盒Bounding Box AABB 包围住想要测试的三角形 减少对不包含三角形的像素的检测<br>Incremental Triangle Traversal 直接找三角形边界(相当于对每行的包围盒)  </p>
<h3 id="Antialiasing-反走样"><a href="#Antialiasing-反走样" class="headerlink" title="Antialiasing 反走样"></a>Antialiasing 反走样</h3><p>抗锯齿<br>采样产生的问题Sampling Artifacts:</p>
<ul>
<li>Jaggies 锯齿（空间采样上的错误）</li>
<li>Moire 摩尔纹（如，采样时跳过奇数行奇数列）</li>
<li>Wagon wheel effect 马车轮效应：人眼在时间上的采样跟不上运动速度</li>
<li>采样伪影的原因：信号频率太快，采样速度跟不上</li>
</ul>
<p>原因:信号变化太快导致采样跟不上</p>
<p>Blurring (Pre-Filtering) Before Sampling 先模糊(滤波)再采样<br>Blurred Aliasing先采样再模糊(不行  </p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>Frequency Domain频域  </p>
<p>傅里叶变换把函数分成很多正弦余弦函数的和 分解成不同频率的段  </p>
<p><img src="/Graphics/Fundamental/Rasterization/frequencies%20sampling.png" alt="Higher Frequencies Need Faster Sampling"></p>
<p>对高频的采样出的结果不能恢复原来的函数 不准确  </p>
<p>采样与函数频率相关  </p>
<p><strong>以同一个采样频率对不同频率信号获取了同样的信息，称之为走样</strong>  </p>
<p>Filtering = Getting rid of certain frequency contents 滤波 去掉某个频率的信息</p>
<p>傅里叶变换FT把时域变到频域  </p>
<p><img src="/Graphics/Fundamental/Rasterization/filter.png" alt="filter"><br>低频信号靠近中心 且低频信号多故亮</p>
<p>图像的边界处变化非常大 -&gt; 高频信息</p>
<p>High-pass filter高通滤波 只剩高频 故只剩边界</p>
<p>Filtering = Convolution卷积(= Averaging) 滤波=平均=卷积<br><img src="/Graphics/Fundamental/Rasterization/convolution.png" alt="convolution"></p>
<p>卷积图形学上简单理解:对信号及周边求平均</p>
<p>时域上的卷积=频域上的乘积<br><img src="/Graphics/Fundamental/Rasterization/Convolution%20Theorem.png" alt="Convolution Theorem"></p>
<p>先傅里叶变换为频域乘再逆傅里叶变换回去 低通滤波</p>
<p>Box Filter 低通滤波器 1/9是为了像素大小不变<br>box越大频域越小</p>
<p>Sampling = Repeating Frequency Contents<br><img src="/Graphics/Fundamental/Rasterization/repeating%20frequency%20contents.png" alt="Repeating Frequency Contents"></p>
<p>采样即为时域上函数乘一系列的冲激函数得到一系列的点<br>在频域上即FT之后的函数和一系列冲击函数FT之后仍为冲激函数的卷积 得到一系列FT之后函数的复制<br><strong>所以采样就是重复一个原始信号的频谱</strong>  </p>
<p>走样就是频谱在复制的过程中发生了混合<br><img src="/Graphics/Fundamental/Rasterization/Mixed%20Frequency%20Contents.png" alt="Mixed Frequency Contents"></p>
<p>采样率变低，采样间隔变大，波长变大，频率变小<br>采样频率小 复制间隔就小 (时域和频域不一样)  </p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>Reduce Aliasing Error</p>
<ul>
<li>Increase sampling rate 增加采样频率 相当于在频谱上增大复制的间隔</li>
<li><p>Antialiasing 反走样 先模糊(低通滤波)再采样</p>
<p>  <img src="/Graphics/Fundamental/Rasterization/Antialiasing.png" alt="Antialiasing"></p>
<p>  去掉高频的信号来防止重叠</p>
<p>  变模糊的方法—用一定的滤波器去卷积(求块的平均)(可以是时域上的一个像素点)<br>  对每个三角形覆盖的像素都求像素内的覆盖区域的平均  </p>
</li>
<li>SSAA<br>  增加采样点 对每一个像素点分成更小的”像素点”再求平均<br>  最终得到每个像素点的覆盖率 故可认为合并了采样操作<br>  并不是提高采样率  </li>
<li><p>MSAA<br>  优化SSAA看有多少个子采样点在三角形中对母采样点的数据乘百分比<br>  不必每个采样点都进行着色计算 只计算像素中心的 然后分开计算子采样点在三角形中个数得到百分比 再用像素中心的乘百分比即可<br>  在光栅化阶段，判断一个三角形是否被像素覆盖的时候会计算多个覆盖样本（Coverage sample），但是在pixel shader着色阶段计算像素颜色的时候每个像素还是只计算一次<br>  和deferred shading 不兼容 场景都先被光栅化到GBuffer上去了，不直接做shading  </p>
</li>
<li><p>其它抗锯齿方法:</p>
<ul>
<li>FXAA 图像处理上找到有锯齿的再换成无锯齿的</li>
<li><p>TAA 复用上一帧的像素点</p>
<p>超分辨率 拉大图<br>DLSS深度学习方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="Visibility-occlusion"><a href="#Visibility-occlusion" class="headerlink" title="Visibility/occlusion"></a>Visibility/occlusion</h2><p>Painter’s Algorithm - Paint from back to front, overwrite in the framebuffer 新画的覆盖之前画的<br>深度不好判断 绘制顺序不同可能结果不同  </p>
<ul>
<li>Z-Buffer 深度缓存</li>
</ul>
<p>同步生成两张图</p>
<ul>
<li>frame buffer stores color values</li>
<li>depth buffer (z-buffer) stores depth Store current min. z-value for each sample (pixel) 之前mvp变换得到的z值 近处值小所以黑(距离为正)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Initialize depth buffer to ∞</span></span><br><span class="line"><span class="comment">//每一个像素内记录最小深度</span></span><br><span class="line"><span class="keyword">for</span> (each triangle T)</span><br><span class="line"><span class="keyword">for</span> (each <span class="built_in">sample</span> (x,y,z) in T)</span><br><span class="line">    <span class="keyword">if</span> (z &lt; zbuffer[x,y]) <span class="comment">// closest sample so far</span></span><br><span class="line">        framebuffer[x,y] = rgb; <span class="comment">// update color</span></span><br><span class="line">        zbuffer[x,y] = z; <span class="comment">// update depth</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ; <span class="comment">// do nothing, this sample is occluded</span></span><br></pre></td></tr></table></figure>
<p>和顺序无关 O(n)的复杂度 本质是求最小值不是排序 和绘制顺序无关 可以对每个采样点zbuffer 处理不了透明物体</p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>RayTracing</title>
    <url>/Graphics/Fundamental/RayTracing/</url>
    <content><![CDATA[<h1 id="RayTracing"><a href="#RayTracing" class="headerlink" title="RayTracing"></a>RayTracing</h1><p>Rasterization 不能处理全局效果 软阴影 多个光源等情况 快但质量不高<br>RayTracing 更精确但更慢 多用于离线 (实时光线追踪见RTR)<br>光线的假设:  </p>
<ol>
<li>光线一定沿着直线传播</li>
<li>光线之间无法碰撞</li>
<li>光线路径可逆，即从A发出的到B的光线，一定也可以从B发出到A（中途可发生反射和折射）<br>由光路可逆可以模拟从人眼发射光线的方法还原出所有的光路<br>从光源出发难以模拟那就反着从摄像机发射光线  </li>
</ol>
<h2 id="Whitted-style光线追踪"><a href="#Whitted-style光线追踪" class="headerlink" title="Whitted-style光线追踪"></a>Whitted-style光线追踪</h2><h3 id="Ray-Casting"><a href="#Ray-Casting" class="headerlink" title="Ray Casting"></a>Ray Casting</h3><p><img src="/Graphics/Fundamental/RayTracing/raycasting1.png" alt="raycasting1">  </p>
<ul>
<li>从人眼或摄像机向近投影平面上的每一个像素点发射一条光线到场景中  </li>
<li>找到与场景物体的最近交点    </li>
<li>连接交点和光源，判断这条连线之间是否有物体存在就可以知道该交点是否在阴影之中  </li>
<li><strong>根据不同着色模型计算着色情况写回像素中</strong> <em>(Blinn-Phong, Whitted-Style, Path Tracing)</em>  </li>
</ul>
<p><img src="/Graphics/Fundamental/RayTracing/raycasting2.png" alt="raycasting2"><br>利用Blinn-Phong模型进行局部光照模型计算那么它的效果与局部光照模型是一样的 需要真正的考虑全局效果  </p>
<h3 id="Recursive-Whitted-Style-Ray-Tracing"><a href="#Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="Recursive (Whitted-Style) Ray Tracing"></a>Recursive (Whitted-Style) Ray Tracing</h3><p><img src="/Graphics/Fundamental/RayTracing/recursive.png" alt="recursive"><br>不仅仅第一个相交的点贡献光给眼睛, 折射与反射之后再与物体相交的点也能贡献光 有光照射到其他物体，再沿着eye rays的反射或折射的光线方向传回人眼<br>直接光照，反射方向间接光，折射方向间接光 计算所有点的局部光照模型的结果，将其按照光线能量权重累加(递归) 得到全局效果的光照模型  </p>
<blockquote>
<p>注:  </p>
<ol>
<li>递归终止条件，比如说允许的最大反射或折射次数为10  </li>
<li>每次反射和折射之后都有能量损耗，由系数决定，越往后的折射和反射光贡献的能量越小，这也是为什么在上文中提到根据光线能量权重求和  </li>
<li>如果反射或折射光线没有碰撞到物体，一般直接返回一个背景色  </li>
<li>经典的whited-style光线追踪遇到漫反射表面会直接利用blinn-phong模型计算颜色值返回，而不再递归下去  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="built_in">RayTracing</span> (original_point, ray_direction, objects, depth)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; maxDepth)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">color</span> (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsHitObject</span> (original_point, ray_direction,objects))</span><br><span class="line">    &#123;</span><br><span class="line">        hitPoint =<span class="built_in">GetHitPoint</span>();</span><br><span class="line">        normal =<span class="built_in">GetNormal</span>();</span><br><span class="line">        </span><br><span class="line">        reflectionDirection = <span class="built_in">reflect</span>(ray_direction,normal);</span><br><span class="line">        refractionDirection = <span class="built_in">refract</span>(ray_direction，normal);<span class="comment">//如果没有折射，舍弃折射项</span></span><br><span class="line"></span><br><span class="line">        local_color = <span class="built_in">BlinnPhongShader</span>(original_point,normal，light_position);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> local_color</span><br><span class="line">        + k1 * <span class="built_in">RayTracing</span> (hitPoint, reflectionDirection,objects,depth + <span class="number">1</span>)</span><br><span class="line">        + k2 * <span class="built_in">RayTracing</span> (hitPoint, refractionDirection,objects,depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> background_color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="Ray-Surface-Intersection-IsHitObject实现"><a href="#Ray-Surface-Intersection-IsHitObject实现" class="headerlink" title="Ray-Surface Intersection (IsHitObject实现)"></a>Ray-Surface Intersection (IsHitObject实现)</h3><p>光线表示 r(t) = o + td (0&lt;=t&lt;$\infin$) 光线为射线 o起点d单位方向  </p>
<ul>
<li>光线与隐式曲面求交 (p是着色点<br>  <img src="/Graphics/Fundamental/RayTracing/Implicit%20Surface.png" alt="Implicit Surface"><br>  代入求解t  </li>
<li>光线与显示曲面求交<br>点如果在封闭形状内，向外打一条光线，得到的交点数量一定是奇数；如果在封闭形状外，则交点数一定是偶数 -&gt; 遍历物体的所有三角形面，求交点数  <ul>
<li>求光线与三角形所在平面的交点<br><img src="/Graphics/Fundamental/RayTracing/plane.png" alt="plane">  </li>
<li>判断交点是否在三角形内  </li>
<li>快捷方法 Möller Trumbore Algorithm<br><img src="/Graphics/Fundamental/RayTracing/mollertrumbore.png" alt="mollertrumbore"><br>将点的形式用重心坐标的形式表示，随后利用克莱姆法则求解线性方程组<br>推导: <a href="https://blog.csdn.net/zhanxi1992/article/details/109903792">https://blog.csdn.net/zhanxi1992/article/details/109903792</a></li>
</ul>
</li>
</ul>
<h3 id="Accelerating-Ray-Surface-Intersection-加速光线追踪"><a href="#Accelerating-Ray-Surface-Intersection-加速光线追踪" class="headerlink" title="Accelerating Ray-Surface Intersection 加速光线追踪"></a>Accelerating Ray-Surface Intersection 加速光线追踪</h3><p>判断光线与场景交点的时候，需要去进行所有三角形面与光线的求交，而且这仅仅是对一个像素而言 #pixels ⨉ # traingles (⨉ #bounces<br><strong>Bounding Volumes</strong>  </p>
<h4 id="Axis-Aligned-Bounding-Box-AABB-轴对⻬包围盒"><a href="#Axis-Aligned-Bounding-Box-AABB-轴对⻬包围盒" class="headerlink" title="Axis-Aligned Bounding Box (AABB) 轴对⻬包围盒"></a>Axis-Aligned Bounding Box (AABB) 轴对⻬包围盒</h4><p>光线与三对分别与x-axis y-axis z-axis垂直的平面相交<br>将先进入的交点(偏小的那个)记为 tmin, 后出去的交点(偏大的那个)记为 tmax( t 可以&lt; 0 代表的是光线反向传播与对应平面的交点)<br>对三组tmin和tmax $\qquad t_{enter} =max\{tmin\},t_{exit} =min\{tmax\}$<br>当$t_{enter} &lt; t_{exit}$的时候，光线所在直线一定在盒子中待过一段时间，也必然存在交点<br><img src="/Graphics/Fundamental/RayTracing/aabb.png" alt="aabb">  </p>
<h4 id="Uniform-Spatial-Partitions-Grids-均匀空间划分"><a href="#Uniform-Spatial-Partitions-Grids-均匀空间划分" class="headerlink" title="Uniform Spatial Partitions (Grids) 均匀空间划分"></a>Uniform Spatial Partitions (Grids) 均匀空间划分</h4><p>AABB对只有一个极其复杂的单一人物模型和充斥着大量的细小模型效率提升有限<br>更好的划分场景形成不同的AABB  </p>
<ul>
<li>Build Acceleration Grid<br><img src="/Graphics/Fundamental/RayTracing/Build%20Acceleration%20Grid.png" alt="Build Acceleration Grid"><br>找一个包围盒均匀划分后在每个重叠小包围盒上存储物体模型信息  </li>
<li>Ray-Scene Intersection<br><img src="/Graphics/Fundamental/RayTracing/Ray-Scene%20Intersection.png" alt="Ray-Scene Intersection"><br>利用bresenham算法判断出所有和光线相交的方格 若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交  </li>
</ul>
<p>最适合的场景就是空间中均匀布满了三角形面<br>格子的划分方法在大量均匀分布的物体上比较有效，然而在复杂空旷的场景中，会造成很多资源浪费  </p>
<h4 id="Spatial-Partitions-空间划分"><a href="#Spatial-Partitions-空间划分" class="headerlink" title="Spatial Partitions 空间划分"></a>Spatial Partitions 空间划分</h4><p><img src="/Graphics/Fundamental/RayTracing/Spatial%20Partitions.png" alt="Spatial Partitions">  </p>
<ul>
<li><p>Oct-Tree 八叉树<br>每次将空间分为8个相等的部分，再递归的对子空间进行划分.当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。n维空间对应$2^n$叉树  </p>
</li>
<li><p>KD-Tree<br>每次将空间划分为两部分，且划分依次沿着x-axis，y-axis，z-axis，依次递归划分，终止条件与八叉树类似 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间。<br><img src="/Graphics/Fundamental/RayTracing/kdtree.png" alt="kdtree"><br>第一步判断光线是否与最外层的包围盒相交 如果相交进一步判断是否与对应的两个子空间相交 (图中做了简化，包围盒的左半边并没继续进行划分 实际上应该要划分的) 递归的执行这个步骤即可  </p>
<ul>
<li>假设有一条光线射出  </li>
<li>逐个对每个子树进行判断是否有与包围盒相交  </li>
<li>若相交则对他的子树继续遍历知道将找到所有与光线相交的包围盒  </li>
<li>将其包围盒下的物体查找交点  </li>
</ul>
<p>优点： 倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程<br>缺点： 判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单，其次同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面</p>
</li>
<li><p>BSP-Tree<br>其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。  </p>
</li>
</ul>
<h4 id="Bounding-Volume-Hierarchy-BVH"><a href="#Bounding-Volume-Hierarchy-BVH" class="headerlink" title="Bounding Volume Hierarchy (BVH)"></a>Bounding Volume Hierarchy (BVH)</h4><p>不再以空间作为划分依据，而是从对象的角度考虑Object partition，即三角形面<br><img src="/Graphics/Fundamental/RayTracing/bvh.png" alt="bvh"><br>为了画图方便，只进行了左半部分的划分，右半部分其实同理  </p>
<ol>
<li>包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内</li>
<li>每次划分一般选择最长的那一轴划分 划分点选择所有三角面的重心坐标在对应轴坐标上的中位数进行划分</li>
<li>中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Intersect</span>(Ray ray, BVH node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ray misses node.bbox) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (node is a leaf node)</span><br><span class="line">     test intersection with all objs;</span><br><span class="line">     <span class="keyword">return</span> closest intersection;</span><br><span class="line">  hit1 = <span class="built_in">Intersect</span>(ray, node.child1);</span><br><span class="line">  hit2 = <span class="built_in">Intersect</span>(ray, node.child2);</span><br><span class="line">  <span class="keyword">return</span> the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="PBR基础"><a href="#PBR基础" class="headerlink" title="PBR基础"></a>PBR基础</h2><h3 id="Basic-radiometry-辐射度量学"><a href="#Basic-radiometry-辐射度量学" class="headerlink" title="Basic radiometry 辐射度量学"></a>Basic radiometry 辐射度量学</h3><p>光线亮度的定义? 需要合适的物理量来描述光线<br>whitted-style 没有对漫反射的光线进行追踪 使用了Blinn-Phong这个不准确的经验模型<br>辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质<br>光线的概念: Radiant energy, flux, intensity, irradiance, radiance  </p>
<h4 id="Radiant-Energy-and-Flux-Power"><a href="#Radiant-Energy-and-Flux-Power" class="headerlink" title="Radiant Energy and Flux (Power)"></a>Radiant Energy and Flux (Power)</h4><p>Radiant energy : Q[J = Joule] 辐射出来的电磁能量，单位为焦耳 类似功<br>Radiant flux(power) : $\Phi = \frac{dQ}{dt}[W = Watt][lm =lumen]^*$ 单位时间的能量 类似功率 一般偏向用radiant flux来衡量光线的亮度  </p>
<blockquote>
<p>sr：球面度，立体角国际单位<br>lm：流明，光通量国际单位<br>cd：坎德拉，光强单位，SI 7大基本单位之一  </p>
</blockquote>
<h4 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h4><p><img src="/Graphics/Fundamental/RayTracing/Light%20Measurements.png" alt="Light Measurements"><br>Radiant itensity 从一个光源出发某一方向上的亮度<br>Irradiance 某一微小平面所接受到的光线亮度<br>radiance 一条传播光线所具有的亮度(不受传播方向影响而改变)<br>这里的亮度也可以理解为radiant flux<br>Radiant itensity:<br>$I(\omega) = \frac{d\Phi}{d\omega}$<br>$[\frac{W}{sr}][\frac{lm}{sr}=cd=candela]$<br>从光源发出的每单位立体角上的功率  </p>
<blockquote>
<p>立体角 solid angle $\Omega = \frac{A}{r^2}$<br><img src="/Graphics/Fundamental/RayTracing/Solid%20Angles.png" alt="Solid Angles">  </p>
</blockquote>
<p>各向同性点光源 Radiant intensity:<br>$\Phi = \int_{S^2} I d\omega = 4\pi I$<br>$I = \frac{\Phi}{4\pi}$  </p>
<h4 id="irradiance"><a href="#irradiance" class="headerlink" title="irradiance"></a>irradiance</h4><p>$E(x) = \frac{d\Phi(x)}{dA}$<br>$[\frac{W}{m^2}][\frac{lm}{m^2}=lux]$<br>每单位照射面积所接收到的power<br>当光线垂直照射平面时，照射到平面上的面积与光线本身的“宽度一致”。当光线斜着照射到平面时，此时的照射面积就不再是光线本身的“宽度”了，此时的照射面积A2=A/cosθ<br>可以解释Blinn-Phong模型中的垂直入射和距离衰减(光能衰减的并不是Radiant Intensity，而是Irradiance)  </p>
<h4 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h4><p><img src="/Graphics/Fundamental/RayTracing/Radiance.png" alt="Radiance"><br>radiance就是指每单位立体角，每单位垂直面积的功率<br>像是Intensity和irradiance的结合。它同时指定了光的方向与照射到的表面所接受到的亮度<br>在irradiance中定义的每单位照射面积 在radiance中关于接收面积的部分是每单位垂直面积($\cos\theta$) $\qquad dA^{\perp} = dA\cos\theta$<br>准确的光线追踪与radiance关系非常大，渲染就是在计算radiance  </p>
<p>Incident Radiance：每单位立体角到达表面的Irradiance $L(p,\omega)=\frac{dE(p)}{d\omega \cos\theta}$  </p>
<p>Exiting Radiance：每单位面积离开表面发射的Intensity $L(p,\omega)=\frac{dI(p,\omega)}{dA \cos\theta}$  </p>
<p><img src="/Graphics/Fundamental/RayTracing/lrradiancevsradiance.png" alt="lrradiancevsradiance"><br>一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到<br>Radiance是某个单位面积向某个单位立体角辐射出去的能量，Irradiance是某个单位面积上接受到来自四面八方的能量<br>区别就在于辐亮度Radiance有方向的概念，而辐照度Irradiance没有<br>把半球面上的所有Radiance积分起来得到的就是Irradiance  </p>
<h3 id="Bidirectional-Reflectance-Distribution-Function-BRDF-双向反射分布函数"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF-双向反射分布函数" class="headerlink" title="Bidirectional Reflectance Distribution Function(BRDF) 双向反射分布函数"></a>Bidirectional Reflectance Distribution Function(BRDF) 双向反射分布函数</h3><blockquote>
<p>BRDF：Bidirectional Reflectance Distribution Function 双向反射分布函数<br>BSDF：Bidirectional Scattering Distribution Function 双向散射分布函数<br>BTDF：Bidirectional Transmittance Distribution Function 双向透射分布函数<br>BSSRDF：Bidirectional Scattering-Surface Reflectance Distribution Function 双向散射表面反射（次表面散射）分布函数  </p>
</blockquote>
<p><img src="/Graphics/Fundamental/RayTracing/Reflection%20at%20a%20Point.png" alt="Reflection at a Point"><br>光线的反射: 一个点(微分面积元)在接受到一定方向上的亮度$(dE(\omega_i))$之后，再向不同方向把能量辐射出去$(dL_r(\omega_r))$<br>$dE(w_i)表示：从w_i方向射来的Radiance在到达反射点时，被吸收转化，然后得到的Irradiance  \\<br>dL(x, w_r)则表示反射点向w_r方向反射出去的Radiance$</p>
<p>BRDF就是描述一个从不同方向入射之后，反射光线分布情况的函数 理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有。理想粗糙表面会把入射光线均匀的反射到所有方向<br>很容易求得单位面积从某一方向吸收了多少能量，而很难求出吸收之后辐射出去的Radiance分布情况 于是就定义一种函数来描述这种Radiance的分布<br>其实就是定义了一种比例(由材质决定) $\frac{吸收后向某立体角方向辐射出去的Radiance}{辐射前某单位面积dA接收到的Irradiance}$<br><img src="/Graphics/Fundamental/RayTracing/brdf.png" alt="brdf"><br>反射方程<br><img src="/Graphics/Fundamental/RayTracing/The%20Reflection%20Equation.png" alt="The Reflection Equation"><br>摄像机所接受到的$\omega_r$方向上的反射光，是由所有不同方向上入射光线的irradiance贡献得到的($L_i(p,\omega_i)\cos \theta_i d\omega_i$)，而不同方向入射光线的irradiance对反射方向$\omega_r$的贡献程度则由物体表面材质决定，所以乘上了一个BRDF函数<br>得到完全正确的光线传播模型<br>入射光线的radiance不仅仅是光源所引起的，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p(即间接光照)，同时其他物体上的反射光线的radiance依然也是由直接光照和间接光照构成，因此这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程  </p>
<h3 id="The-Rendering-Equation-渲染方程"><a href="#The-Rendering-Equation-渲染方程" class="headerlink" title="The Rendering Equation 渲染方程"></a>The Rendering Equation 渲染方程</h3><p>$L_o(p,\omega_o)=L_e(p,\omega_o)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i$<br>在反射方程的基础之上添加了一个自发光项(Emission term)<br>$\cos \theta_i$用$n \cdot \omega_i$代替<br><img src="/Graphics/Fundamental/RayTracing/reflectionequation.png" alt="reflectionequation">  </p>
<ul>
<li>点光源对一个点来说只有一个方向有入射光 没有积分  </li>
<li>多个点光源的贡献全部求和即可  </li>
<li>面光源相当于无穷多个点光源的集合，只需要对面光源所在的立体角范围进行积分  </li>
<li>加入其它物体同样考虑成面光源 且将$L_i$视作$L_r$<br>而式子可简化为$l(u)=e(u)+\int l(v)K(u,v)dv$<br>离散化为$L=E+KL$<br>$L=(I-K)^{-1}E$<br>$L=E+KE+K^2E+K^3E+…$<br>K 为对光线进行反射的一种算子操作(由BRDF化来)<br>E为光源发出的光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果，对于全局光照Global illumination来说，还考虑了$K^2E$，即一次弹射的间接照明，$K^3E$就是两次弹射的间接照明</li>
</ul>
<h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><blockquote>
<ul>
<li>Monte Carlo Integration 蒙特卡洛积分<br>目的: 当一个积分很难通过解析的方式得到答案的时候可以通过蒙特卡洛的方式近似得到积分结果<br>做法: 对函数值进行多次采样求均值作为积分值的近似<br>均匀采样的话，其实就相当于将整个积分面积切成了许许多多个长方形，然后将这些小长方形的面积全部加起来 还可以指定一个采样的分布p(x)来对被积分的值进行采样<br><img src="/Graphics/Fundamental/RayTracing/Monte%20Carlo%20Integration.png" alt="Monte Carlo Integration"><br>N为采样次数，$X_i$为随机变量（采样值）这里除以pdf可以理解为一种加权，哪里采样的多哪里就多做平均<br>求均值的做法其实也是对期望的逼近<br><img src="/Graphics/Fundamental/RayTracing/montecarloprocessing.png" alt="montecarloprocessing"><br>均匀采样:<br>若采样方式为均匀采样（采样pdf为均匀分布），则认为样本和采样值的乘积xf(x)<br>为单次采样的积分结果，随后多次采样取平均，得到最终近似结果<br><img src="/Graphics/Fundamental/RayTracing/uniformmonte.png" alt="uniformmonte">  </li>
</ul>
</blockquote>
<p>Whitted-Style Ray Tracing 做法是，光线在镜面反射表面弹射，而在漫反射表面停 不够正确<br>但上述得出的渲染方程是正确的<br>pathtracing主要解决raytracing中的漫反射(全局光照)问题<br>解出渲染方程的解主要有两个难点：  </p>
<ol>
<li>积分的计算</li>
<li>递归形式</li>
</ol>
<ul>
<li>A Simple Monte Carlo Solution  <ul>
<li>首先舍弃自发光项且仅考虑直接光照<br><img src="/Graphics/Fundamental/RayTracing/A%20Simple%20Monte%20Carlo%20Solution.png" alt="A Simple Monte Carlo Solution"><br>$L_o(p,\omega_o)=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)d\omega_i$<br>得到的即为着色点p到摄像机或人眼的Radiance值 用Monte Carlo Integration可近似结果 $L_o(p,\omega_o)\approx\frac{1}{N}\sum_{i=1}^N\frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n \cdot \omega_i)}{p(\omega_i)}$<br>$p(\omega_i)=\frac{1}{2\pi}$(均匀采样)<br>只有当采样的方向$\omega_i$击中光源的时候，光源才会对该着色点有贡献  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = <span class="number">0.0</span></span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray <span class="built_in">r</span>(p, wi)</span><br><span class="line">        If ray r hit the light</span><br><span class="line">        Lo += (<span class="number">1</span> / N) * L_i * f_r * cosine / <span class="built_in">pdf</span>(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure></li>
<li>考虑间接光照<br>当采样的ωi方向碰撞到了别的物体<br><img src="/Graphics/Fundamental/RayTracing/globalillumination.png" alt="globalillumination"><br>对着色点P的贡献是在点Q的直接光照再乘上反射到该方向上的百分比 类似光线追踪的递归，不同在于该方法通过对光线方向的采样从而找出一条条可行的路径  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Randomly choose N directions wi~pdf</span><br><span class="line">    Lo = <span class="number">0.0</span></span><br><span class="line">    For each wi</span><br><span class="line">        Trace a ray <span class="built_in">r</span>(p, wi)</span><br><span class="line">        If ray r hit the light</span><br><span class="line">            Lo += (<span class="number">1</span> / N) * L_i * f_r * cosine / <span class="built_in">pdf</span>(wi)</span><br><span class="line">        Else If ray r hit an object at q</span><br><span class="line">            Lo += (<span class="number">1</span> / N) * <span class="built_in">shade</span>(q, -wi) * f_r * cosine / <span class="built_in">pdf</span>(wi)</span><br><span class="line">    Return Lo</span><br></pre></td></tr></table></figure>
此时解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归 但还有几个缺陷  </li>
</ul>
</li>
<li>Problem 1: Explosion of #rays as #bounces go up<br>  <img src="/Graphics/Fundamental/RayTracing/problem1.png" alt="problem1"><br>  p的着色需要q的环境光照信息，而q的环境光照信息又必须包含其他物体的环境光照信息，如此需要采样的光线数量会爆炸增长 =&gt; 每次只采样一个方向 N=1 （N!=1时称为分布式光线追踪    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Randomly choose ONE direction wi~<span class="built_in">pdf</span>(w)</span><br><span class="line">    <span class="function">Trace a ray <span class="title">r</span><span class="params">(p, wi)</span></span></span><br><span class="line"><span class="function">    If ray r hit the light</span></span><br><span class="line"><span class="function">        Return L_i * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span></span></span><br><span class="line"><span class="function">    Else If ray r hit an object at q</span></span><br><span class="line"><span class="function">        Return <span class="title">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span></span></span><br><span class="line"><span class="function">    Return Lo</span></span><br></pre></td></tr></table></figure>
  但积分计算的结果会非常的noisy，虽然蒙特卡洛积分是无偏估计，但样本越少显然偏差越大 =&gt; 对每个像素重复多次寻找到多条路径，将多条路径的结果求得平均<br>  <img src="/Graphics/Fundamental/RayTracing/raygeneration.png" alt="raygeneration">    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Very similar to ray casting in ray tracing</span></span><br><span class="line"><span class="built_in">ray_generation</span>(camPos, pixel)</span><br><span class="line">    Uniformly choose N sample positions within the pixel</span><br><span class="line">    pixel_radiance = <span class="number">0.0</span></span><br><span class="line">    For each sample in the pixel</span><br><span class="line">        Shoot a ray <span class="built_in">r</span>(camPos, cam_to_sample)</span><br><span class="line">        If ray r hit the scene at p</span><br><span class="line">            pixel_radiance += <span class="number">1</span> / N * <span class="built_in">shade</span>(p, sample_to_cam)</span><br><span class="line">    Return pixel_radiance</span><br></pre></td></tr></table></figure>
  通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题  </li>
<li><p>Problem 2: The recursive algorithm will never stop!<br>  递归没有出口 并不采用类似光线追踪当中设定反射深度显示的给出递归出口的方法<br>  <strong><em>Russian Roulette (RR)(俄罗斯轮盘赌)</em></strong>  </p>
<blockquote>
<p>设定一个概率P, 有P的概率光线会继续递归并设置返回值为Lo/P，有1−P的概率光线停止递归，并返回0。光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为Radiance的期望不变(E=P⋆(Lo/P)+(1−P)⋆0=L0)  </p>
</blockquote>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    Manually specify a probability P_RR</span><br><span class="line">    Randomly select ksi in a uniform dist. in [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="built_in">If</span> (ksi &gt; P_RR) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    Randomly choose ONE direction wi~<span class="built_in">pdf</span>(w)</span><br><span class="line">    <span class="function">Trace a ray <span class="title">r</span><span class="params">(p, wi)</span></span></span><br><span class="line"><span class="function">    If ray r hit the light</span></span><br><span class="line"><span class="function">        Return L_i * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span> / P_RR</span></span><br><span class="line"><span class="function">    Else If ray r hit an object at q</span></span><br><span class="line"><span class="function">        Return <span class="title">shade</span><span class="params">(q, -wi)</span> * f_r * cosine / <span class="title">pdf</span><span class="params">(wi)</span> / P_RR</span></span><br></pre></td></tr></table></figure></li>
<li>Problem 3: correct but not really efficient<br>  由于只通过均匀采样选出一个方向,很少的光线可以hit光源,大多都浪费了<br>  <strong><em>Sampling the Light</em></strong><br>  计算直接光照的时候改进为<strong>直接对光源进行采样</strong> 所有采样的光线都一定会击中光源<br>  光源的面积为A，那么对光源进行采样的 pdf=1/A (∫pdf⁡dA=1)<br>  渲染方程的积分是定义在立体角上，定义在着色点的半球上的 不是定义在光源上的<br>  渲染方程都是采样到哪个点就计算哪个点的立体角的积分，要求积分和采样是在一个域上, 这里在光源上采样，却还用着着色点的立体角微分，这显然是不对的<br>  还要找到渲染方程中$d\omega_i$和dA的关系 由立体角定义<br>  <img src="/Graphics/Fundamental/RayTracing/dwdA.png" alt="dwdA"><br>  渲染方程改为<br>  $L_o(x,\omega_o)=\int_{A}L_i(x,\omega_i)f_r(x,\omega_i,\omega_o)\frac{\cos\theta\cos\theta’}{\lVert x’-x \rVert^2}dA$<br>  计算直接光照的积分值直接对光源采样(pdf=1/A)且不用RR，间接光照仍用先前的方法进行光线方向的均匀采样    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shade</span>(p, wo)</span><br><span class="line">    # Contribution from the light source.</span><br><span class="line">    Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">    L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^<span class="number">2</span> / pdf_light </span><br><span class="line">    # Contribution from other reflectors.</span><br><span class="line">    L_indir = <span class="number">0.0</span></span><br><span class="line">    Test Russian Roulette with probability P_RR</span><br><span class="line">    Uniformly sample the hemisphere toward <span class="built_in">wi</span> (pdf_hemi = <span class="number">1</span> / <span class="number">2</span>pi)</span><br><span class="line">    Trace a ray <span class="built_in">r</span>(p, wi)</span><br><span class="line">    If ray r hit a non-emitting object at q</span><br><span class="line">        L_indir = <span class="built_in">shade</span>(q, -wi) * f_r * cos θ / pdf_hemi / P_RR</span><br><span class="line">    Return L_dir + L_indir</span><br></pre></td></tr></table></figure></li>
<li>Problem 4: if the sample on the light is not blocked or not<br>  计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡<br>  只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可    <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># Contribution from the light source.</span><br><span class="line">L_dir = <span class="number">0.0</span></span><br><span class="line">Uniformly sample the light at x’ (pdf_light = <span class="number">1</span> / A)</span><br><span class="line">Shoot a ray from p to x’</span><br><span class="line">If the ray is <span class="keyword">not</span> blocked in the middle</span><br><span class="line">    L_dir = ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>摄像机发出的光线第一次相交   </p>
<ul>
<li>交点是光源  </li>
<li>交点是物体  <ol>
<li>向光源采样计算L_dir  </li>
<li>向其他物体采样递归计算L_indir  </li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>Shading</title>
    <url>/Graphics/Fundamental/Shading/</url>
    <content><![CDATA[<h1 id="Shading"><a href="#Shading" class="headerlink" title="Shading"></a>Shading</h1><p>着色 引入明暗和颜色的不同 对不同物体应用不同材质  </p>
<h2 id="A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model"><a href="#A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model" class="headerlink" title="A Simple Shading Model (Blinn-Phong Reflectance Model)"></a>A Simple Shading Model (Blinn-Phong Reflectance Model)</h2><p><img src="/Graphics/Fundamental/Shading/shadingpoint.png" alt="shadingpoint"></p>
<p>shading是局部的，只考虑光源的影响 不考虑其它物体的存在 是对每个点而言的</p>
<ul>
<li>Diffuse Reflection漫反射</li>
</ul>
<p>Lambert漫反射模型<br>光真正接受的是光照进来的法线分量 $\cos \theta = l \cdot n$ (l,n均为单位向量)</p>
<p>光源到距离为r的shading point的强度I变为$\frac{I}{r^2}$</p>
<p>$L_d = k_d(\frac{I}{r^2})\max(0,n \cdot l)$</p>
<p>$L_d$是漫反射的光  $k_d$指的是漫反射的系数，为1则全部反射，为0则全部吸收 max是为了剔除夹角大于90°的光</p>
<ul>
<li>Specular Term 高光项<br>Phong反射模型<br><img src="/Graphics/Fundamental/Shading/specular.png" alt="specular"></li>
</ul>
<p>V close to mirror direction当视线和入射的镜面反射接近时 &lt;=&gt; half vector near normal 半程向量h和法线接近(点乘为0)<br>Blinn-Phong反射模型<br>$L_s = k_s(\frac{I}{r^2})\max(0,n \cdot h)^p$<br>$h = \frac{v + l}{\big\lvert \lvert v + l \rvert \big\rvert}$<br>$k_s$为镜面反射系数<br>本来要考虑多少入射被吸收(l·n) 但被简化<br>但只用夹角余弦太宽泛所以要有系数p p控制高光的大小 需要一个指数p加速衰减</p>
<ul>
<li>Ambient Term 环境光</li>
</ul>
<p><img src="/Graphics/Fundamental/Shading/ambient.png" alt="ambient"></p>
<p>假设认为环境光都是相同的 确保没有地方是黑的 精确要全局光照的知识</p>
<p>$L_a = k_aI_a$</p>
<p><img src="/Graphics/Fundamental/Shading/blinnphong.png" alt="blinnphong">  </p>
<p>$L = L_a + L_d + L_s = k_aI_a + k_d(\frac{I}{r^2})\max(0,n \cdot l) + k_s(\frac{I}{r^2})\max(0,n \cdot h)^p$</p>
<h2 id="Shading-Frequencies"><a href="#Shading-Frequencies" class="headerlink" title="Shading Frequencies"></a>Shading Frequencies</h2><p>之前是着色的方法/模型 现在是着色的频率  </p>
<ul>
<li><p>Flat shading 平面着色<br>求三角形法线 逐面<br>计算很快 很明显的看到一块块面形状  </p>
</li>
<li><p>Gouraud shading<br>求顶点的法线，对顶点着色，三角形内部通过差值算出<br>法线:顶点关联的面的法线的平均(或加权)再标准化 (不精确<br>(按理来说Gouraud用的是双线性插值)  </p>
</li>
<li><p>Phong shading<br>逐像素 像素法线由顶点法线重心插值</p>
</li>
</ul>
<p>几何模型相对复杂(面密度大)时shading频率可以小一些  </p>
<h2 id="Graphics-Real-time-Rendering-Pipeline-图形管线"><a href="#Graphics-Real-time-Rendering-Pipeline-图形管线" class="headerlink" title="Graphics (Real-time Rendering) Pipeline 图形管线"></a>Graphics (Real-time Rendering) Pipeline 图形管线</h2><p><img src="/Graphics/Fundamental/Shading/pipeline.png" alt="pipeline"></p>
<p>顶点处理 -&gt; 三角形处理 -&gt; 光栅化 -&gt; 片元处理 -&gt; 逐片元操作<br>其中，Vertex和Fragment阶段是可编程的<br>GPUs：可并行的图形管线处理器  </p>
<ul>
<li>Vertex Processing 顶点处理: 对所有顶点MVP变换 得到二维平面坐标(zbuffer的z值)  </li>
<li>Triangle Processing 三角形处理: 所有的顶点按照原几何信息，变成三角面  </li>
<li>Rasterization 光栅化  </li>
<li>Fragment Processing 片元处理(片元可能比像素更小 如MSAA采样点):<br>  进行shading<br>  此时Vertex Processing也会处理(需要顶点信息对三角形内的点属性插值/Gouraud shading中顶点处理阶段就算出每个顶点的颜色值)<br>  可以去做texture mapping，利用texture的信息来代替blinn-phong模型漫反射系数来当作颜色  </li>
<li>Framebuffer Operations<br>  zbuffer 处理遮挡关系 将所有的像素颜色信息整合在一起，输送给显示设备显示  </li>
</ul>
<pre><code>shader 自行编程控制顶点和像素(片元)如何进行着色代替原来固定的顶点处理和片元处理 GLSL  
</code></pre><h2 id="Texture-Mapping-纹理映射"><a href="#Texture-Mapping-纹理映射" class="headerlink" title="Texture Mapping 纹理映射"></a>Texture Mapping 纹理映射</h2><p>定义任何一个点着色时的属性  </p>
<p>将三维物体上的任意一个点都映射到一个二维平面之上  </p>
<p>只需要将每个点的颜色信息即漫反射系数存储在二维的Texture纹理之上  </p>
<p>纹理上有坐标u-v映射到三角形上 u，v在(0,1)内  </p>
<p>只需要在三维world space中每个顶点的信息之中存储下该顶点在texture space的(u,v)坐标信息  </p>
<p>特殊的纹理tile 重复拼接之后上下左右都是连续的 可以复制很多张贴</p>
<h3 id="Barycentric-coordinates-重心坐标"><a href="#Barycentric-coordinates-重心坐标" class="headerlink" title="Barycentric coordinates 重心坐标"></a>Barycentric coordinates 重心坐标</h3><p>Interpolation Across Triangles<br>对于三角形所在平面上的任意一点的坐标，都可以用三角形的三个顶点坐标的线性表达式表<br>示(和重心区别)  </p>
<script type="math/tex; mode=display">
(x,y) = \alpha A + \beta B + \gamma C\\
\alpha + \beta + \gamma = 1\\
三个系数也可用点所对三角形的面积表示\\
\alpha = \frac{S_A}{S_A+S_B+S_C}\\
\beta = \frac{S_B}{S_A+S_B+S_C}\\
\gamma = \frac{S_C}{S_A+S_B+S_C}\\</script><p>展开得<br><img src="/Graphics/Fundamental/Shading/barycentric.png" alt="barycentric"></p>
<p><img src="/Graphics/Fundamental/Shading/Barycentric%20Coordinates.png" alt="Barycentric Coordinates"></p>
<p>另一种视角:<br><img src="/Graphics/Fundamental/Shading/barycentric2.png" alt="barycentric2"><br>$p=a + \beta(b-a) + \gamma(c-a) = (1-\beta - \gamma)a + \beta b+ \gamma c$</p>
<p>重心坐标最重要的运用便是插值 无论是位置，颜色，深度，法线向量等等  </p>
<p>投影后的重心坐标会改变 所以三维空间中的属性在三维空间中做插值再投影(如深度)  </p>
<p>重心坐标一定要是原世界坐标空间中的重心坐标，但实际计算中一般会使用投影之后的二维平面来计算重心坐标(重心坐标往往都是在屏幕空间下所得到的)，存在着一个误差需要校正  </p>
<p>重心坐标任意属性的正确插值:  </p>
<blockquote>
<p>Z为世界坐标中的深度值 其它为屏幕坐标所得</p>
<script type="math/tex; mode=display">
I_t = (\alpha \frac{I_A}{Z_A} + \beta \frac{I_B}{Z_B} + \gamma \frac{I_C}{Z_C}) * \frac{1}{(\frac{\alpha}{Z_A} + \frac{\beta}{Z_B} + \frac{\gamma}{Z_C})}</script><p>推导:<br><a href="https://www.zhihu.com/column/c_1249465121615204352">https://www.zhihu.com/column/c_1249465121615204352</a><br><a href="https://zhuanlan.zhihu.com/p/403259571">https://zhuanlan.zhihu.com/p/403259571</a></p>
</blockquote>
<h3 id="Applying-Textures"><a href="#Applying-Textures" class="headerlink" title="Applying Textures"></a>Applying Textures</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> each rasterized screen <span class="title function_">sample</span> <span class="params">(x,y)</span>:</span><br><span class="line">    <span class="params">(u,v)</span> = evaluate texture coordinate <span class="title function_">at</span> <span class="params">(x,y)</span></span><br><span class="line">    texcolor = texture.sample(u,v);</span><br><span class="line">    <span class="built_in">set</span> sample<span class="number">&#x27;</span>s color to texcolor;</span><br></pre></td></tr></table></figure>
<h3 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h3><p>A pixel on a texture — a texel (纹理元素、纹素 纹理上的像素)<br>pixel是投影在屏幕上的 texel是贴在三维图形上的  </p>
<ul>
<li><p>纹理太小</p>
<p>  把一张100x100的纹理贴图应用在一500x500的屏幕之上必然会导致走样失真<br>  屏幕空间的几个像素点对应在纹理贴图的坐标上都是集中在一个像素大小之内<br>  多个pixel映射到了同一个texel  </p>
<p>  Texture Magnification 纹理放大  </p>
<ul>
<li>Bilinear Interpolation 双线性插值<br>  对非整数的纹理值取四个相邻的采样点 水平+竖直做两次插值，即双线性插值 Lerp<br>  <img src="/Graphics/Fundamental/Shading/Bilinear%20Interpolation.png" alt="Bilinear Interpolation"></li>
<li>对周围16个点做三次插值，双三次插值 Bicubic，运算量更大，结果更好  </li>
</ul>
</li>
<li><p>纹理太大<br>  纹理贴图大小500x500，屏幕空间100x100，将屏幕空间的像素点均匀分布在纹理空间之中，那么1个屏幕空间像素点所占的平均大小就是5x5=25个纹理空间像素<br>  用一个点采样的结果代替纹理空间一片范围的颜色信息，必然会导致严重失真！(采样频率过低无法还原信号原貌)<br>  一个pixel对应了多个texel<br>  近处锯齿远处摩尔纹<br>  Supersampling超采样可以解决但计算量太大<br>  <img src="/Graphics/Fundamental/Shading/footprint.png" alt="footprint"><br>  <strong>Mipmap</strong><br>  一个采样点的颜色信息不足以代表footprint里一个区域的颜色信息，可以求出这样一个区域里面所有颜色的均值<br>  从 <em>点查询Point Query</em> 迈向 <em>范围查询Range Query</em> (仅取正方形的范围)<br>  多级渐远纹理 一系列的纹理图像，后一个纹理图像的分辨率是前一个的二分之一 再选择最适合像素大小的一个<br>  <img src="/Graphics/Fundamental/Shading/mipmap2.png" alt="mipmap"><br>  多余存储空间为1/3<br>  <img src="/Graphics/Fundamental/Shading/Mipmap.png" alt="Mipmap"><br>  <img src="/Graphics/Fundamental/Shading/Computing%20Mipmap%20Level.png" alt="Computing Mipmap Level"><br>  由相邻像素点(取当前像素点的右方和上方的两个相邻像素点)转换到纹理空间后求在Texture space的距离取最大值, level D = log2L 从多个纹理图像中选最合适的  </p>
<p>  若D非2的整数倍:<br>  四舍五入 or 利用D值在向下和向上取整的两个不同level进行三线性插值<br>  <img src="/Graphics/Fundamental/Shading/trilinearinterpolation.png" alt="trilinearinterpolation"><br>  三线性插值，就是在向下取整的D level上进行一次双线性插值(前文提过)，再在D+1 level之上进行一次双线性插值，这二者数据再根据实际的连续D值在向下和向上取整的两个不同level之间的比例，再来一次线性插值  </p>
<p>  对于在纹理上一个像素方块形成不规则的形状(远处很模糊):  </p>
<ul>
<li>Anisotropic Filtering各向异性过滤 可以处理矩形的形状<br>准备不同级别的纹理贴图时，不再是简简单单横纵纹素各减小一半进行分<br>级，而是长减半宽不变 or 宽减半长不变 or 长和宽各减半三种情况各进行一次分级<br>多余存储空间为3倍 算出水平方向的level D1，再算一个竖直方向的level D1，然后算根据这两个level去各项异性过滤的texture里面找一张最合适的  </li>
<li>EWA filtering  使用很多的圆形来覆盖不规则区域,通过多次查询来覆盖对应区域<br><img src="/Graphics/Fundamental/Shading/Anisotropic%20Filtering.png" alt="Anisotropic Filtering">  </li>
</ul>
</li>
</ul>
<h3 id="Applications-of-textures"><a href="#Applications-of-textures" class="headerlink" title="Applications of textures"></a>Applications of textures</h3><p>纹理可理解为一块数据用于不同类型的查询</p>
<h4 id="Normal-Maps"><a href="#Normal-Maps" class="headerlink" title="Normal Maps"></a>Normal Maps</h4><ul>
<li><p>存储object space下的法线向量坐标<br>  一但该法线向量的三角形面发生了变形(如人物模型在做各种动画)，该法线向量就不再正确  </p>
</li>
<li><p>存储切线空间之中的法线向量坐标<br>切线空间（tbn）tangant轴（t）、bitangent轴（b）及法线轴（N）所组成的坐标系 z轴由原来该面上的几何法线n构成 x，y轴分别由该面所对应的贴图上U,V增加的两个方向构成<br>真正存储的时候只需要t 和 n即可，第三轴可以直接叉乘得到。并且将t和n作为顶点的属性进行存储<br>详解: <a href="https://zhuanlan.zhihu.com/p/139593847">https://zhuanlan.zhihu.com/p/139593847</a></p>
</li>
</ul>
<h4 id="Environment-Map"><a href="#Environment-Map" class="headerlink" title="Environment Map"></a>Environment Map</h4><p>假设光源无限远，只记录光照的方向信息，这种贴图被称作环境光贴图<br>Spherical Environment Map 环境光信息描述在球面纹理上(上方和下方均有较为严重的扭曲)<br>利用观察方向相对于法线的反射方向去查询环境映射的颜色值<br>Cube Map 天空盒 但会需要额外判断某一方向上的光照应该记录在立方体的哪个面上，<br>计算量更大<br><img src="/Graphics/Fundamental/Shading/cubemap.png" alt="cubemap">  </p>
<p>Textures can affect shading 凹凸贴图 法线贴图 改变法线方向 给人凹凸的效果  </p>
<h4 id="Bump-Mapping-凹凸贴图"><a href="#Bump-Mapping-凹凸贴图" class="headerlink" title="Bump Mapping 凹凸贴图"></a>Bump Mapping 凹凸贴图</h4><p>Normal Maps直接存储了法线信息，而Bump Maps存储的是该点逻辑上(物理上没有)的相对高度(可为负值)，该高度的变化实际上表现了物体表面凹凸不平的特质，利用该高度信息，再计算出该点法线向量，最后再利用该法线计算光照 多了从height到normal向量<br>由切线算法线<br><img src="/Graphics/Fundamental/Shading/bumpmapping2d.png" alt="bumpmapping2d">  </p>
<blockquote>
<p>p点原来的法线朝上，即n(p) = (0, 1)<br>上图蓝色曲线为使用法线贴图后的效果<br>通过dp = (c[h(p+1) - h(p)])求出两点的高度差。其中c为常数表示凹凸贴图的影响程度，h为p点、p+1点对应高度<br>因此切线可表示为(1,dp)<br>切线与法线为垂直的关系因此n(p) = (-dp, 1)  </p>
</blockquote>
<p><img src="/Graphics/Fundamental/Shading/bumpmapping3d.png" alt="bumpmapping3d"><br>所有计算出来的法线都是局部坐标即切线空间之下，因此还需要左乘[t b n]矩阵转到(世界)相机坐标系之下得到正确法向  </p>
<h4 id="Displacement-mapping-位移贴图"><a href="#Displacement-mapping-位移贴图" class="headerlink" title="Displacement mapping 位移贴图"></a>Displacement mapping 位移贴图</h4><p>和上一个相比改变了几何 去对模型的顶点做位移  </p>
<h4 id="Shadow-Mapping-阴影贴图"><a href="#Shadow-Mapping-阴影贴图" class="headerlink" title="Shadow Mapping 阴影贴图"></a>Shadow Mapping 阴影贴图</h4><p><strong><em>阴影 =&gt; 摄像机能看到的地方，光源看不见</em></strong>  </p>
<ol>
<li>把光源当做一个摄像机去渲染整个场景从而得到从光源视角的深度Buffer，记为dmap(ShadowMap)<br> <img src="/Graphics/Fundamental/Shading/shadowmap1.png" alt="shadowmap1">  </li>
<li>从设定好的摄像机位置去真正的渲染场景<br> <img src="/Graphics/Fundamental/Shading/shadowmap2.png" alt="shadowmap2">  </li>
<li>将所有摄像机视角可见点，利用光源视角下的那一套投影矩阵，重新投影回光源，得到光源视角下的屏幕坐标，找到该屏幕坐标在dmap上的深度值  <ul>
<li>如果和投影回光源的点的实际深度值相等，则说明此点可被光源照射，不在阴影中  </li>
<li>如果小于投影回光源的点的实际深度值，则说明此点不可被光源看见，即该点前方有物体遮挡，在阴影中<br><img src="/Graphics/Fundamental/Shading/shadowmap3.png" alt="shadowmap3">  </li>
</ul>
</li>
</ol>
<p>如果在阴影之中就不去计算Blinn-Phong中的镜面反射项与漫反射项  </p>
<ul>
<li>细节:  <ol>
<li>浮点数难以判断相等，所以一般会有一个tolerance</li>
<li>shadow maps查询时不采用双线性插值，只寻找最近的点，因为倘若插值发生在物体边缘时，与邻接点的深度差距很大，会导致插值结果会有很大的误差</li>
<li>属于硬阴影(棱角分明)，只适用于点光源 软阴影为光源具有体积，导致，不同地方看到光源的比例不同  </li>
<li>渲染出来的阴影比较脏<br>原因：深度值的比较位浮点数比较，而判断浮点数相等势必会产生误差，虽然处理精度的方法有很多种，但并不能从本质上解决问题  </li>
<li>走样<br>原因：本身储存的深度图存在分辨率限制，与渲染时的分辨率搭配不好的话，就会产生走样  </li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>C++2.0</title>
    <url>/CPlusPlus/HouJie/C++2.0/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="C++2.0.pdf" width="100%" height="550" type="application/pdf">
	</div>



<p>more:<br><a href="https://changkun.de/modern-cpp/zh-cn/00-preface/">https://changkun.de/modern-cpp/zh-cn/00-preface/</a><br><a href="https://github.com/AnthonyCalandra/modern-cpp-features#coroutines">https://github.com/AnthonyCalandra/modern-cpp-features#coroutines</a>  </p>
]]></content>
      <categories>
        <category>CPlusPlus</category>
        <category>HouJie</category>
      </categories>
  </entry>
  <entry>
    <title>Transformation</title>
    <url>/Graphics/Fundamental/Transformation/</url>
    <content><![CDATA[<h1 id="Transformation-基础变换"><a href="#Transformation-基础变换" class="headerlink" title="Transformation 基础变换"></a>Transformation 基础变换</h1><h2 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h2><h3 id="Dot-product"><a href="#Dot-product" class="headerlink" title="Dot product"></a>Dot product</h3><script type="math/tex; mode=display">
\vec{a}\cdot\vec{b} = \big\lvert \lvert a \rvert \lvert b \lvert \big\rvert \cos \theta\\
\cos \theta = \hat{a}\cdot\hat{b}\\
\vec{a}\cdot\vec{b} = \binom{x_a}{y_a} \cdot \binom{x_b}{y_b} = x_ax_b + y_ay_b</script><p>求投影projection<br>求夹角<br>判断前后</p>
<h3 id="Cross-product"><a href="#Cross-product" class="headerlink" title="Cross product"></a>Cross product</h3><script type="math/tex; mode=display">
\vec{a}\times\vec{b} =
\left(
\begin{matrix}
y_az_b-y_bz_a \\
z_ax_b-x_az_b \\
x_ay_b-y_ax_b
\end{matrix}
\right)\\
\vec{a}\times\vec{b} = A*b = 
\left(
\begin{matrix}
0 & -z_a & y_a \\
z_a & 0 & -x_a \\
-y_a & x_a & 0
\end{matrix}
\right)
\left(
\begin{matrix}
x_b \\
y_b \\
z_b
\end{matrix}
\right)</script><p>判断左右和前后<br>右手系$\vec{\omega}=\vec{u}\times\vec{v}$</p>
<h3 id="Matrices"><a href="#Matrices" class="headerlink" title="Matrices"></a>Matrices</h3><script type="math/tex; mode=display">(M\times N)(N\times P) = (M\times P)</script><p>不满足交换律 满足结合律</p>
<p>转置Transpose</p>
<script type="math/tex; mode=display">
\left(
\begin{matrix}
1 & 2 \\
3 & 4 \\
5 & 6
\end{matrix}
\right)^\mathrm T=
\left(
\begin{matrix}
1 & 3 & 5\\
2 & 4 & 6
\end{matrix}
\right)</script><h2 id="2D-transformations"><a href="#2D-transformations" class="headerlink" title="2D transformations"></a>2D transformations</h2><span id="more"></span>
<p>Linear Transforms:<br>用相同维度的矩阵相乘进行变换<br>Scale Matrix</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
x' \\
y'
\end{matrix}
\right]=
\left[
\begin{matrix}
s_x & 0 \\
0 & s_y
\end{matrix}
\right]
\left[
\begin{matrix}
x \\
y
\end{matrix}
\right]</script><p>Reflection Matrix</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
x' \\
y'
\end{matrix}
\right]=
\left[
\begin{matrix}
-1 & 0 \\
0 & 0
\end{matrix}
\right]
\left[
\begin{matrix}
x \\
y
\end{matrix}
\right]</script><p>Shear Matrix</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
x' \\
y'
\end{matrix}
\right]=
\left[
\begin{matrix}
1 & a \\
0 & 1
\end{matrix}
\right]
\left[
\begin{matrix}
x \\
y
\end{matrix}
\right]</script><p>Rotation Matrix 默认逆时针</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
x' \\
y'
\end{matrix}
\right]=
\left[
\begin{matrix}
\cos\theta & -\sin\theta \\
\sin\theta & \cos\theta
\end{matrix}
\right]
\left[
\begin{matrix}
x \\
y
\end{matrix}
\right]</script><h2 id="3D-Transforms"><a href="#3D-Transforms" class="headerlink" title="3D Transforms"></a>3D Transforms</h2><p>3D Rotations<br>我们所采用的是右手系，在二维之中其逆时针旋转矩阵是x轴向y轴旋转，对应到3维便是绕z轴旋转(x轴转向y轴)，不难推出绕x轴旋转(y转向z)，绕y轴旋转(z转向x)  </p>
<script type="math/tex; mode=display">
R_x(\alpha)=
\left(
\begin{matrix}
1 & 0 & 0 & 0\\
0 & \cos\alpha & -\sin\alpha & 0\\
0 & \sin\alpha & \cos\alpha & 0\\
0 & 0 & 0 & 1
\end{matrix}
\right)\\
R_y(\alpha)=
\left(
\begin{matrix}
\cos\alpha & 0 & \sin\alpha & 0\\
0 & 1 & 0 & 0\\
-\sin\alpha & 0 & \cos\alpha & 0\\
0 & 0 & 0 & 1
\end{matrix}
\right)\\
R_z(\alpha)=
\left(
\begin{matrix}
\cos\alpha & -\sin\alpha & 0 & 0\\
\sin\alpha & \cos\alpha & 0 & 0\\
0 & 0 & 1 & 0\\
0 & 0 & 0 & 1
\end{matrix}
\right)\\</script><p><strong>任意旋转矩阵都是正交矩阵($AA^T=I$)</strong> 正交矩阵逆和转置相同 $R_{-\theta} = R_\theta^T$  </p>
<p>(所有的旋转都是针对原点来说)  </p>
<h2 id="Affine-Transformations仿射变换"><a href="#Affine-Transformations仿射变换" class="headerlink" title="Affine Transformations仿射变换"></a>Affine Transformations仿射变换</h2><ul>
<li><p>Homogeneous coordinates 齐次坐标</p>
<p>  引入齐次坐标目的:将平移也用矩阵变换实现</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
  x' \\
  y'
  \end{matrix}
  \right]=
  \left[
  \begin{matrix}
  a & b \\
  c & d
  \end{matrix}
  \right]
  \left[
  \begin{matrix}
  x \\
  y
  \end{matrix}
  \right]+
  \left[
  \begin{matrix}
  t_x \\
  t_y
  \end{matrix}
  \right]</script><p>  添加一个维度</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
  x \\
  y \\
  \omega
  \end{matrix}
  \right]</script><p>  $\omega$为0时表示矢量 不为0时表示点<br>  且为点时</p>
<script type="math/tex; mode=display">
  \left[
  \begin{matrix}
  x \\
  y \\
  \omega
  \end{matrix}
  \right]和
  \left[
  \begin{matrix}
  x/\omega \\
  y/\omega \\
  1
  \end{matrix}
  \right]表示一个点</script><p>  vector + vector = vector<br>  point - point = vector<br>  point + vector = point<br>  point + point = point(中点)  </p>
</li>
</ul>
<p>仿射变换  </p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
x' \\
y' \\
1
\end{matrix}
\right]=
\left[
\begin{matrix}
a & b & t_x\\
c & d & t_y\\
0 & 0 & 1
\end{matrix}
\right]\cdot
\left[
\begin{matrix}
x \\
y \\
1
\end{matrix}
\right]</script><p>3D同2D增加一个维度</p>
<script type="math/tex; mode=display">
\left[
\begin{matrix}
x' \\
y' \\
z' \\
1
\end{matrix}
\right]=
\left[
\begin{matrix}
a & b & c & t_x\\
d & e & f & t_y\\
g & h & i & t_z\\
0 & 0 & 0 & 1
\end{matrix}
\right]\cdot
\left[
\begin{matrix}
x \\
y \\
z \\
1
\end{matrix}
\right]</script><p>先进行线性变换再平移变换  </p>
<p>最后一维为1，表示点(point), 为0表示方向(direction).方向的位移没有意义，方向始终不会变。第四维不是只能是1和0，在投影变换中，齐次坐标会有更多的作用  </p>
<h2 id="Composing-Transforms组合变换"><a href="#Composing-Transforms组合变换" class="headerlink" title="Composing Transforms组合变换"></a>Composing Transforms组合变换</h2><p>不满足交换率 从后往前实现<br>满足结合率<br>对绕非原点的旋转可先平移再绕原点旋转再平移回去</p>
<h1 id="Viewing-Transformation-观测变换"><a href="#Viewing-Transformation-观测变换" class="headerlink" title="Viewing Transformation 观测变换"></a>Viewing Transformation 观测变换</h1><p>将虚拟世界中以(x,y,z)为坐标的物体变换到 以一个个像素位置(x,y) 来表示的屏幕坐标系之中(2维)<br>Think about how to take a photo (MVP)</p>
<ul>
<li>Find a good place and arrange people (model transformation)游戏场景中的物体调整至他们应该在的位置  </li>
<li>Find a good “angle” to put the camera (view transformation)得到物体与摄像机的相对位置  </li>
<li>Cheese! (projection transformation)将三维空间投影至标准二维平面($[-1,1]^2$)之上(这里的z并没有丢掉，为了之后的遮挡关系检测）  </li>
<li>视口变换(viewport transformation)：将处于标准平面映射到屏幕分辨率范围之内，即$[-1,1]^2→[0,width]*[0,height]$, 其中width和height指屏幕分辨率大小  </li>
</ul>
<h2 id="View-Camera-Transformation-视图变换"><a href="#View-Camera-Transformation-视图变换" class="headerlink" title="View / Camera Transformation 视图变换"></a>View / Camera Transformation 视图变换</h2><p>Define the camera first</p>
<ul>
<li>Position $\vec{e}$</li>
<li>Look-at / gaze direction $\hat{g}$</li>
<li>Up direction $\hat{t}$</li>
</ul>
<p>transform the camera to <strong>The origin, up at Y, look at -Z</strong> 相机和物体一起都要变换  </p>
<p><img src="/Graphics/Fundamental/Transformation/viewtransformation.png" alt="viewtransformation"></p>
<p>正常旋转不好就考虑逆变换 旋转矩阵的逆变换既为转置</p>
<h2 id="Projection-Transformation-投影变换"><a href="#Projection-Transformation-投影变换" class="headerlink" title="Projection Transformation 投影变换"></a>Projection Transformation 投影变换</h2><h3 id="Orthographic-projection-正交投影"><a href="#Orthographic-projection-正交投影" class="headerlink" title="Orthographic projection 正交投影"></a>Orthographic projection 正交投影</h3><p>simple:<br>Drop Z coordinate<br>Translate and scale the resulting rectangle to [-1, 1]</p>
<p>In general:<br>将物体全部转换到一个$[−1,1]^3$的空间之中<br>将原空间范围的左下角移至原点 放大给定倍数 将缩放后的空间范围移至新空间范围<br><img src="/Graphics/Fundamental/Transformation/orthoprocess.jpg" alt="推导过程"></p>
<script type="math/tex; mode=display">
M_{ortho}=
\left[
\begin{matrix}
\frac{2}{r-l} & 0 & 0 & 0\\
0 & \frac{2}{t-b} & 0 & 0\\
0 & 0 & \frac{2}{n-f} & 0\\
0 & 0 & 0 & 1
\end{matrix}
\right]
\left[
\begin{matrix}
1 & 0 & 0 & -\frac{r+l}{2}\\
0 & 1 & 0 & -\frac{t+b}{2}\\
0 & 0 & 1 & -\frac{n+f}{2}\\
0 & 0 & 0 & 1
\end{matrix}
\right]=
\left[
\begin{matrix}
\frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l}\\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b}\\
0 & 0 & \frac{2}{n-f} & -\frac{n+f}{n-f}\\
0 & 0 & 0 & 1
\end{matrix}
\right]</script><p>摄像机方向:看向z的负方向 所以远的物体z更小  </p>
<h3 id="Perspective-projection-透视投影"><a href="#Perspective-projection-透视投影" class="headerlink" title="Perspective projection 透视投影"></a>Perspective projection 透视投影</h3><p>看成先挤压为长方体再正交投影</p>
<p><img src="/Graphics/Fundamental/Transformation/perspectiveprojection.png" alt="perspectiveprojection"></p>
<p>$y’=\frac{n}{z}y$ x同y</p>
<script type="math/tex; mode=display">
M_{persp->ortho}
\left(
\begin{matrix}
x \\
y \\
z \\
1
\end{matrix}
\right)=>
\left(
\begin{matrix}
\frac{n}{z}x \\
\frac{n}{z}y \\
unknown \\
1
\end{matrix}
\right)==
\left(
\begin{matrix}
nx \\
ny \\
unknown \\
z
\end{matrix}
\right)</script><p>再由两个特殊点，近平面z=n上的点不变和远平面z=f上的点的z坐标不变可得矩阵</p>
<script type="math/tex; mode=display">
\left(
\begin{matrix}
0 ,0 ,A ,B
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
n \\
1
\end{matrix}
\right)=>n^2  
\qquad
\left(
\begin{matrix}
0 ,0 ,A ,B
\end{matrix}
\right)
\left(
\begin{matrix}
x \\
y \\
f \\
1
\end{matrix}
\right)=>f^2</script><script type="math/tex; mode=display">
M_{persp\rightarrow ortho}=
\left(
\begin{matrix}
n & 0 & 0 & 0 \\
0 & n & 0 & 0 \\
0 & 0 & n+f & -nf \\
0 & 0 & 1 & 0
\end{matrix}
\right)\\
M_{persp}=M_{ortho}M_{persp\rightarrow ortho}=
\left[
\begin{matrix}
\frac{2n}{r-l} & 0 & \frac{r+l}{l-r} & 0\\
0 & \frac{2n}{t-b} & \frac{t+b}{b-t} & 0\\
0 & 0 & \frac{n+f}{n-f} & \frac{2fn}{f-n}\\
0 & 0 & 1 & 0
\end{matrix}
\right]</script><p>以上得到$[-1,1]^3$  </p>
<p>详细推导: <a href="https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888">https://zhuanlan.zhihu.com/p/122411512?utm_source=qq&amp;utm_medium=social&amp;utm_oi=605668290971045888</a></p>
<h2 id="viewport-transformation-视口变换"><a href="#viewport-transformation-视口变换" class="headerlink" title="viewport transformation 视口变换"></a>viewport transformation 视口变换</h2><p>$[-1,1]^2→[0,width]*[0,height]$ 三维变二维  </p>
<script type="math/tex; mode=display">
M_{viewport}=
\left(
\begin{matrix}
\frac{width}{2} & 0 & 0 & \frac{width}{2} \\
0 & \frac{height}{2} & 0 & \frac{height}{2} \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & 1
\end{matrix}
\right)</script><p><strong>$M=M_{viewport}M_{persp}M_{view}$</strong></p>
<h2 id="变换法线向量"><a href="#变换法线向量" class="headerlink" title="变换法线向量"></a>变换法线向量</h2><p>模型变换可能会导致模型位置形状发生改变，如果属于该模型的各个三角形面的法线向量不跟着改变的话，那么此时所记录的法线向量就是错误的。因此法线向量一定也要跟着模型本身发生改变<br>对模型实行M矩阵的变换之后:  </p>
<ol>
<li>平移, 旋转的情况下，法线变换矩阵就是变换矩阵M，不需要额外计算；</li>
<li>等比缩放情况下，法线变换矩阵就是变换矩阵M，法线变换后需要除以缩放比例归一化；</li>
<li><p>其他情况使用$N = (M^{-1})^T$求法线变换矩阵  </p>
<blockquote>
<p>n为法向量 t为切向量 $t_M$为变化后的切向量 $n_N$为变化后的法向量<br>$n^Tt = n^TIt = n^TM^{-1}Mt = 0$<br>$(n^TM^{-1})Mt = n^TM^{-1}t_M = 0$<br>$n_N^T = n^TM^{-1}$<br>$n_N = (n^TM^{-1})^T = (M^{-1})^T n$  </p>
</blockquote>
<p>M不可逆时使用伴随矩阵$A^<em> = |A|A^{-1}$ $N = (M^</em>)^T$</p>
</li>
</ol>
<p>详细推导 <a href="https://zhuanlan.zhihu.com/p/449976247">https://zhuanlan.zhihu.com/p/449976247</a></p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>MemoryManagement</title>
    <url>/CPlusPlus/HouJie/MemoryManagement/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="MemoryManagement1.pdf" width="100%" height="550" type="application/pdf">
	</div>


  
<p>C++程序的生前与死后  </p>


	<div class="row">
    <embed src="MemoryManagement2.pdf" width="100%" height="550" type="application/pdf">
	</div>


  
<p><img src="/CPlusPlus/HouJie/MemoryManagement/MM.png" alt="MM"></p>
]]></content>
      <categories>
        <category>CPlusPlus</category>
        <category>HouJie</category>
      </categories>
  </entry>
  <entry>
    <title>Design Patterns</title>
    <url>/CPlusPlus/HouJie/DesignPatterns/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="DesignPatterns.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>CPlusPlus</category>
        <category>HouJie</category>
      </categories>
  </entry>
  <entry>
    <title>STL</title>
    <url>/CPlusPlus/HouJie/STL/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="STL.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <categories>
        <category>CPlusPlus</category>
        <category>HouJie</category>
      </categories>
  </entry>
  <entry>
    <title>IBL</title>
    <url>/Graphics/RTR/EnvironmentMapping/</url>
    <content><![CDATA[<h1 id="Environment-Mapping"><a href="#Environment-Mapping" class="headerlink" title="Environment Mapping"></a>Environment Mapping</h1><p><img src="/Graphics/RTR/EnvironmentMapping/IBL.jpg" alt="IBL">  </p>
<h2 id="Shading-From-Environment-Lighting"><a href="#Shading-From-Environment-Lighting" class="headerlink" title="Shading From Environment Lighting"></a>Shading From Environment Lighting</h2><p>环境光照：用一张图来记录在场景中往任何一个方向看的光照<br>Image-Based Lighting (IBL)  </p>
<blockquote>
<p>基于物理的渲染：  </p>
<ol>
<li>基于微平面理论</li>
<li>使用基于物理的BRDF(Blinn-Phong光照模型也被认为是一个BRDF。然而由于Blinn-Phong模型并没有遵循能量守恒定律，因此它不被认为是基于物理的渲染)</li>
<li>保证能量守恒</li>
</ol>
</blockquote>
<p>在基于物理的渲染方法之中，想要计算间接光照, 需要分析光线的传播(光线追踪、光子映射)等方法, 但在实时渲染中计算量太大. 实时渲染中最常用的是基于图像照明(IBL)计算间接光照，把天空盒环境贴图上的颜色信息当做环境光源，通过对反射方程的近似计算，从而生成采样贴图，最终计算光照能量时仅仅需要去对这个贴图进行采样再加以计算即可，相比于完整的全局光照减轻了计算代价，同时也带来了不错的渲染质量的提升  </p>
<p>IBL的情况下，通常解渲染方程-蒙特卡洛积分-需要采样 每个shadingpoint采样太慢<br>通常只要shader中有sampling就不能用在实时渲染（但近几年技术的提升 在实时渲染使用sampling有了可行性）  </p>
<p>不考虑visibility<br>rendering equation就只有brdf和lighting相乘再积分<br>brdf是glossy时，在球面上的覆盖范围很小<br>brdf是diffuse时，覆盖范围大，且足够平滑<br>此时可以用$\int_\Omega f(x)g(x) dx \approx \frac{\int_\Omega f(x) dx}{\int_\Omega dx} \cdot \int_\Omega g(x) dx$ 近似  </p>
<h3 id="1-light"><a href="#1-light" class="headerlink" title="1. light"></a>1. light</h3><p>把light单独拆出来，并normalize，相当于把ibl表示的图给模糊了<br><img src="/Graphics/RTR/EnvironmentMapping/prefiltering.jpg" alt="prefiltering"><br><img src="/Graphics/RTR/EnvironmentMapping/split1.png" alt="split1"><br>把light拆出来，其实就定义了一种操作filtering，可以去滤波环境光。滤波的核取多大取决于BRDF占多大,BRDF的区域越大,最后取得的图也就越模糊  </p>
<p>Prefiltering就是提前把滤波环境光生成，提前将不同卷积核的滤波核的环境光生成（和mipmap相似）即把环境贴图在render前就模糊，当需要时进行查询即可,其他尺寸的图则可以经过这些已生成的通过三线性插值得到(要取一片区域的近似可以先近似好再取)  </p>
<p><img src="/Graphics/RTR/EnvironmentMapping/lightprefiltering.png" alt="lightprefiltering"><br>用brdf来计算shading point时，左图要根据glosness来以一定立体角的范围内进行采样再加权平均来得到 右图从镜面反射方向望去在pre-filtering的图上进行查询 进行一次查询就等价于左图的操作,并且不需要采样<br><strong><em>Prefiltering + single query = no filtering + multiple queries</em></strong></p>
<p>到此解决了拆分后的前半部分积分采样的问题,接下来处理BRDF项采样的问题  </p>
<h3 id="2-brdf"><a href="#2-brdf" class="headerlink" title="2. brdf"></a>2. brdf</h3><p>要解决积分就要通过预计算，直接把brdf进行预计算需要打一个五维的表格，这样就会导致爆炸的存储量。想要进行预计算，就要把预计算的参数维度压到二维<br>主要想法：降维，减少依赖变量，拆开菲尼尔项<br>brdf 详解:<br><img src="/Graphics/RTR/EnvironmentMapping/brdf.png" alt="brdf">  </p>
<ul>
<li>近似F（Fresnel）和D(NDF)项 <strong>spilt sum</strong>:  <ul>
<li>此时暂时不考虑阴影  </li>
<li>Frenel term可以近似成一个基础反射率R0和入射角度的指数函数  </li>
<li>法线分布函数（NDF）是一个一维的分布，其中有两个变量，一个变量定义是diffuse还是gloosy，另一个是half vector和法线中间的夹角，可以近似成入射角度相关的数，这样就变成了3维的预计算  </li>
<li>再把Frenel的近似公式带入到brdf里，R0拆到积分的外面去，这样需要积分的变量只有roughnes和入射角度，这样就可以预计算存成一个二维的数组，就不用采样了<br><img src="/Graphics/RTR/EnvironmentMapping/split2.png" alt="split2">  </li>
</ul>
</li>
</ul>
<p>工业界用求和<br><img src="/Graphics/RTR/EnvironmentMapping/splitsum.png" alt="splitsum">  </p>
<p>将预计算后的结果存入一个2D的纹理texture中 使用时查询即可<br><img src="/Graphics/RTR/EnvironmentMapping/texture.png" alt="texture">  </p>
<h2 id="Shadow-from-environment-lighting"><a href="#Shadow-from-environment-lighting" class="headerlink" title="Shadow from environment lighting"></a>Shadow from environment lighting</h2><p>very difficult  </p>
<ul>
<li>many-light problem 把环境光照认为成很多光源的光照 每个光源都要有个shadowmap 开销大  </li>
<li>sampling problem 在任何一个shading point采样各个方向的光照的Visibility项很复杂 需要大量采样的样本 brdf可能是非常高频的glossy 不容易把brdf给拆分开来 很难从环境中分离出V项  </li>
</ul>
<p>工业界主流方法 只用一个主要光源生成阴影  </p>
<blockquote>
<p>生成阴影相关研究:<br>Imperfect shadow maps 全局光照部分产生的shadow<br>Light cuts 离线渲染 把反射物当成小光源,把所有的小光源做归类并近似出照射的结果<br>RTRT 可能是最终解决方案<br>PRT &#10004;  </p>
</blockquote>
<p>preKnowledge:<br>两种函数相乘的积分可以认为成一个卷积操作。其中只要有一个函数是低频的，得到的结果也是低频, 相当于做了低通滤波，<strong><em>积分之后的频率取决于积分前最低的频率</em></strong> 低频也就是smooth<br>基函数（Basis Functions）把一个函数可以描绘成其他函数(基函数)的线性组合 傅里叶变化就是基函数  </p>
<h3 id="Spherical-Harmonics-SH"><a href="#Spherical-Harmonics-SH" class="headerlink" title="Spherical Harmonics (SH)"></a>Spherical Harmonics (SH)</h3><p>定义在球面上的一系列二维函数组成的基函数<br><img src="/Graphics/RTR/EnvironmentMapping/Spherical%20Harmonics.png" alt="Spherical Harmonics"><br>类似一维里的傅里叶级数 存在不同频率的函数，不同频率的函数个数也不同。第l阶的SH有2l+1个二维函数 每个基函数都有一个比较复杂的数学表示，对应一个legendre多项式  </p>
<p>一个函数f由一系列基函数B和系数c的线性组合表示，通过投影操作确定基函数前面的系数c  </p>
<blockquote>
<p>空间中想描述一个向量，可以xyz三个坐标来表达，就可以这么理解，把xyz轴当做三个基函数，把向量投影到，xyz轴上，得到三个系数就是三个坐标  </p>
<p>球面函数变cos sin再傅里叶展开可能会有缝 所以用Spherical Harmonics 适用于直接分析球面上的函数  </p>
</blockquote>
<p>重建：已经知道基函数对应的系数，就能恢复原来的函数。基函数的l可以是无限个的，可以只用前几阶来恢复原来的函数，取的阶数的个数越多，越能还原原来函数的细节  </p>
<p>rendering equation在计算shading的情况下就只有lighting和brdf<br>brdf如果是diffuse材质，就会像一个低通滤波器，只有低频的信息，非常smooth<br>因为brdf是低频的，那么Lighting和brdf两个函数相乘的积分也是低频的<br>由于环境光是来自于四面八方且都有值,所以环境光照就是一个球面函数,可以把它投影到任何一个SH basis上,可以投影很多阶,但是只需要取前三阶的SH去恢复环境光就可以恢复出最低频的细节 这样SH只要用前三阶就能还原shading的结果<br><img src="/Graphics/RTR/EnvironmentMapping/diffusebrdf.png" alt="diffusebrdf">  </p>
<p>以上仍然还是shading  </p>
<p>SH 实现: <a href="https://zhuanlan.zhihu.com/p/362460950">https://zhuanlan.zhihu.com/p/362460950</a></p>
<h3 id="Precomputed-Radiance-Transfer-PRT"><a href="#Precomputed-Radiance-Transfer-PRT" class="headerlink" title="Precomputed Radiance Transfer (PRT)"></a>Precomputed Radiance Transfer (PRT)</h3><p>解决shadows和global illumination  </p>
<p>在rendering equation中把lighting,visbility,brdf项可以描述成三个二维的球面函数，在环境光照中，需要大量的采样，开销很大  </p>
<p>PRT会假设在一个环境中，就光照变化，其他不变  </p>
<ul>
<li><p>把渲染方程看作lighting 和 light transport（brdf和visibility）  </p>
<ul>
<li>lighting是一个球面函数,可用基函数表示,预计算阶段计算出lighting  </li>
<li>light transport 只和当前shading point相关(只有light发生变化时) 可以认为是shading point自己的性质 写成基函数形式预计算出 (brdf只有一个变量，即入射光线，出射光线不随相机变化而改变，只要有入射光线，出射光线的值就是确定的)<br><img src="/Graphics/RTR/EnvironmentMapping/prt.png" alt="prt">  </li>
</ul>
</li>
<li><p>diffuse:<br>brdf是一个常值，可以从积分里拿出来。把lighting写成一个用基函数来描述的函数，这样就能把Lighting从积分从拿出来<br>积分里剩下来的就是light transport（brdf和visibility）乘一个基函数，这就成了lighting transport投影到一个基函数的系数，就能进行预计算，这样就只要算一个点乘就好了。<br>代价就是场景里的物体就不能动(light transport预计算,visibility当成常量)，而且在光源可以旋转的环境就处理不了<br><img src="/Graphics/RTR/EnvironmentMapping/diffuseprt.png" alt="diffuseprt">  </p>
<p>旋转一个基函数之后，得到的函数就不再是一个基函数(因为基函数有严格的朝向等限制)，但是旋转球谐函数等价于同阶基函数的线性组合 预计算的光照可以旋转 可以立刻得出旋转后的sh基函数新的线性组合  </p>
<p>可以把Bi理解为lighting,也就是说每个basis所描述的环境光去照亮这个物体从而得到照亮之后的结果,预计算就是把每个basis照亮得到的结果生成  </p>
<p>最终在任意一个shading point点(几何形体上的vertex)求得的shading result,在实际计算时只是lighting项投影到sh基函数上求得的li系数组成的vector和Light transport项投影到SH基函数上求得的Ti系数组成的vector做了个点乘</p>
<p>在实际运算时,对每个顶点预计算出它的shading result,三角形内部任一点则通过插值得到它的shading result,叫做per vertex shading.</p>
<p>或者在三角形内部先插值好lighting的vector和light transport的vector,然后再去计算pixel上的shading result,叫做per pixel shading.</p>
<p>另一种思路把light transport和lighting一样也描述成基函数，再在积分中把lighting 和light transport合并，变成一个双重求和，因为SH的正交性，虽然结果是O（$n^2$），但和O（n）没区别<br><img src="/Graphics/RTR/EnvironmentMapping/diffuseprt2.png" alt="diffuseprt2">  </p>
</li>
<li><p>glossy:<br>diffuse的brdf是常数，glossy的不是<br>像diffuse一样把light transport投影的到SH，这样light transport包含v又包含brdf，brdf是四维函数(2维的输入方向,2维的输出方向)<br>对于diffuse，brdf与摄像机位置无关，存储小，而glossy与摄像机有关，摄像机方向是无限可能的无法存储<br>即使light transport即使投影到了i方向上的基函数,所得到的仍然是一个关于O的函数而不是系数<br>light transpoert投影到SH就成了关于o的二维函数，把投影的结果再投影到SH上去，这样一来就得到一个矩阵。diffuse的情况下SH会用到三阶的basis function，glossy的情况用四阶,五阶，甚至更高阶数<br>上面的积分已经计算了全部入射光线关于一个固定的出射光线的值，换一个出射光线，就又要积分一次，所以T变成了T（O）<br>结果就从原来的向量点乘变为了一个向量和一个矩阵的乘法<br><img src="/Graphics/RTR/EnvironmentMapping/glossyprt.png" alt="glossyprt"><br>light transport上就不认为得到的是向量,而是矩阵,即对任意一个O都会得到一串VECTOR,把所有不同O得到的VECTOR摆在一起,就形成了一个矩阵  </p>
<p>多次反射当作lighttransport的一部分 不管中间boucne几次,只需要预计算出Light transport就能得出最后的shading result  </p>
<p>可以把任意复杂的light transport给预计算出来,只是light transport越复杂在预计算时花费的时间多而实际跑时候是很快的  </p>
<p>预计算是一个独立的程序，会有存储和读取的过程  </p>
<p>PRT使用要求: 静态场景、动态光源 低频的情况  </p>
</li>
</ul>
<h3 id="Wavelet-小波函数"><a href="#Wavelet-小波函数" class="headerlink" title="Wavelet 小波函数"></a>Wavelet 小波函数</h3><p>SH只适合低频的情况，不太适合描述高频的情况，需要非常高的阶数才能才能还原一个比较高频场景。SH是用预计算的方式，只能在固定场景中使用，在场景中也不能动态改变物体的材质<br>其他不同basis functions - wavelet<br>sh是定义在球面上，小波是定义在一个图像块 SH通过截断前几阶的SH来压缩，小波是任何一个函数也能投影到各个不同的小波对应的基函数上，投影在基函数之后会发现很多基函数对应的系数是接近0的，这样就能通过保留非接近0或者保留最大的几个来近似地描述原始的函数 支持全频率的描述，高低频都能描述<br><img src="/Graphics/RTR/EnvironmentMapping/wavelet.png" alt="wavelet"><br>定义在平面上 用球面函数描述2D会出现一个缝，用cubemap来描述<br>对任何一张cubemap做小波变换，都把高频信息留出来，把稍微低频的信息留下，再对低频的信息进行小波变换，不断进行小波变换就能进行很好的压缩。jpeg的格式就用了类似的方式来压缩。但是小波不像SH能支持旋转<br><img src="/Graphics/RTR/EnvironmentMapping/cubemapwavelet.png" alt="cubemapwavelet">  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>OOP</title>
    <url>/CPlusPlus/HouJie/OOP/</url>
    <content><![CDATA[

	<div class="row">
    <embed src="OOP.pdf" width="100%" height="550" type="application/pdf">
	</div>



<p>参考:<br><a href="https://github.com/Light-City/CPlusPlusThings">https://github.com/Light-City/CPlusPlusThings</a>  </p>
]]></content>
      <categories>
        <category>CPlusPlus</category>
        <category>HouJie</category>
      </categories>
  </entry>
  <entry>
    <title>GAMES202</title>
    <url>/Graphics/RTR/GAMES202/</url>
    <content><![CDATA[<h1 id="GAMES202笔记"><a href="#GAMES202笔记" class="headerlink" title="GAMES202笔记"></a>GAMES202笔记</h1><p>Real-Time  </p>
<h2 id="High-Quality"><a href="#High-Quality" class="headerlink" title="High Quality  "></a>High Quality  </h2><p>参考&amp;引用:<br><a href="https://www.bilibili.com/video/BV1YK4y1T7yY/">https://www.bilibili.com/video/BV1YK4y1T7yY/</a><br><a href="https://www.zhihu.com/column/c_1355231954820890624">https://www.zhihu.com/column/c_1355231954820890624</a><br><a href="https://zhuanlan.zhihu.com/p/363333150">https://zhuanlan.zhihu.com/p/363333150</a><br><a href="https://www.zhihu.com/column/c_1473816420539097088">https://www.zhihu.com/column/c_1473816420539097088</a>  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>Global Illumination</title>
    <url>/Graphics/RTR/GlobalIllumination/</url>
    <content><![CDATA[<h1 id="Global-Illumination"><a href="#Global-Illumination" class="headerlink" title="Global Illumination"></a>Global Illumination</h1><p><img src="/Graphics/RTR/GlobalIllumination/GI.jpg" alt="GI"><br>比直接光照多一个bounce的间接光照  </p>
<p>直接光照的物体-次级光源  </p>
<p>计算间接光照  </p>
<ul>
<li>哪些可以成为次级光源  </li>
<li>如何照亮点p  <h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2></li>
</ul>
<h3 id="Reflective-Shadow-Maps-RSM"><a href="#Reflective-Shadow-Maps-RSM" class="headerlink" title="Reflective Shadow Maps (RSM)"></a>Reflective Shadow Maps (RSM)</h3><p>shadowmap上每个像素对应的小片都是次级光源  </p>
<p>shadowmap可以解决哪些物体会被光源照到，把shadowmap的每个像素对应的小片作为次级光源。要用次级光照照亮某个点p,就等于从点p观察这些次级光源</p>
<blockquote>
<p>review:辐射度量学.一个单位立体角下对应的能量就是Radiant Intensity,单位面积下的就是Irradiance,在单位立体角又单位面积就是Radiance.</p>
</blockquote>
<p><img src="/Graphics/RTR/GlobalIllumination/rsm.png" alt="rsm">  </p>
<p>Ques1: 哪些表面会被直接照到<br>Sol: 使用shadow map，shadow map上每一个像素可以看成是一个小surface patch</p>
<p>Ques2: 对于不同点p 出射方向不知道，没法shadering<br>Sol: 假设次级光源都是diffuse的(不好确定光线方向) 不依赖观察的方向  </p>
<p>Ques3: 计算每个surface patch对着色点p的贡献<br>Sol: 如上图q就是RSM中一个Texel所对应的patch去照亮点P<br>    计算q对p点的贡献,要对整个立体角进行采样,浪费很多的sample,直接在light处采样然后计算p点的shading值 即把立体角的积分变成了对light区域面积的积分<br>    小片q的brdf是一个常数(diffuse) q出射的radiance就等于brdf乘以入射的irradiance irrandance就等于flux除以点q的面积 然后把这个式子带到点p的式子Li中,就把点p的面积消掉了 就不需要计算点p的面积 将积分域中所有的结果加在一起,就是着色点最后被间接光照照亮所得到的shading值   </p>
<p>4次方是对的 上面的$x-x_p$没有标准化  </p>
<p>加速: 只找距离比较近的次级光源 假设把shader point投影到shadowmap上,在shadowmap离的比较近,那么就认为在世界距离上比较近 大大减少计算量  </p>
<p>RSM 即shadowmap多存了世界坐标计算距离 多存了法线方向计算cos 多存了flux光源光强  </p>
<p>Pros:易于实现 对于手电筒很适合<br>Cons:  </p>
<ul>
<li>有几个直接光源就得有几个shadowmap  </li>
<li>V项没有做(可见性)  </li>
<li>太多假设diffuse reflectors, depth as distance  </li>
<li>sampling 采样率会导致存在一个效率与质量的trade off  </li>
</ul>
<p>RSM就是光栅化版本的离线渲染VPL方法  </p>
<p>RSM和shadowmap一样属于 <em>图像空间(不是屏幕)</em> 的方法,在这里当成3D空间的方法是不会像图像空间记录不下丢失信息受到影响,且LPV方法会基于RSM  </p>
<h3 id="Light-Propagation-Volumes-LPV"><a href="#Light-Propagation-Volumes-LPV" class="headerlink" title="Light Propagation Volumes(LPV)"></a>Light Propagation Volumes(LPV)</h3><p>LPV就是在三维空间传播光线  </p>
<p>间接光照最核心的问题是shadinng point接受各个方向间接光的radiance有多少 radiance在光线传播过程中不变  </p>
<p>体素化 把场景分成格子Voxel，把格子中的点受到的直接光照注入到格子中，把格子作为次级光源传播到其它格子，实现全局光照  </p>
<p>(体素划分一般至少比场景分辨率少一个数量级)  </p>
<ol>
<li>Generation 用RSM找到哪些点会被直接光照照亮，得到一系列次级光源 (可以降低数量)  </li>
<li>Injection 先把场景分成3D网格 任意一个格子就包含一些次级光源，把这些的光源往四周的radiance加起来 使用3D纹理 用SH压缩radiance  </li>
<li>Propagation 传播 格子有六个面 radiance通过每个面往周围六个格子传播 看穿过各个面的radiance 不断传播最终达到一个稳态 最后得到次级光源的radiance传播过的格子  </li>
<li>Rendering 每个shading point 都有一个对应的格子，已经得到了每个格子的incident radiance，就能直接进行渲染  </li>
</ol>
<p>Cons: Light leaking 格子里的都会被照亮 几何比格子小 会照亮不该照亮的<br>Sol: 用不同大小的格子 也就是Cascade层级加速结构</p>
<p>假设不考虑V项  </p>
<p>只要是用SH压缩，渲染glossy表面都会造成强烈模糊，所以一般只要用了SH都会假设diffuse  </p>
<p>不需要任何的预计算  </p>
<h3 id="Voxel-Global-Illumination-VXGI"><a href="#Voxel-Global-Illumination-VXGI" class="headerlink" title="Voxel Global Illumination (VXGI)"></a>Voxel Global Illumination (VXGI)</h3><p>2pass 场景完全离散成格子  </p>
<p>RSM次级光源是像素中所包含的接受直接光照的微小表面，VXGI把整个场景离散成体素变成网格 可以在最小的格子基础上建立一层大格子 Hierachical树形结构  </p>
<p>RSM和LPV计算radiance都是从次级光源出发传播一次，从而得到全局光照的结果，而VXGI是从camera出发，像有一个Camera Ray打到每一个pixel上 根据打到的像素的材质反射出一个圆锥，相交到之前计算好的voxel(即cones shading)，即每个shading point 都要进行 cone tracing 的计算 <strong><em>光线从传播变为了追踪</em></strong>  </p>
<ul>
<li>pass 1 从光源看 计算直接光照的结果 格子记录体素表面的法线分布和接受的入射光分布信息 不再像LPV一样将所有的radiance加在一起求各方向的初始值 可计算出射 (可以是glossy) 一个个体素格子考虑在一块 建立hierarchy层级<br><img src="/Graphics/RTR/GlobalIllumination/vxgipass1.png" alt="vxgipass1">  <blockquote>
<p>记录的是直接光源从哪些范围来（绿色部分），记录各个反射表面的法线（橙色部分），通过输入方向和法线范围两个信息然后通过表面的材质，来准确的算出出射的分布 比LPV认为格子表面是diffuse再用SH来压缩的方法要准确  </p>
</blockquote>
</li>
<li><p>pass 2 从camera看 对于glossy表面 从shading point的拉出反射的锥体和哪些voxel体素相交再计算 (有之前得到的体素的法线分布和入射光分布 可以算出其输出的radiance,将cone区域内所有体素的radiance都算出，就能得到shading point的间接光照)<br>不用全计算 计算圆锥内一定层级(pass1建立)即可(根据传播出的距离远近找对应层级的体素，然后找覆盖的范围) cone tracing<br><img src="/Graphics/RTR/GlobalIllumination/vxgipass2.png" alt="vxgipass2">  </p>
</li>
<li><p>对于diffuse使用若干圆锥覆盖一个半球<br><img src="/Graphics/RTR/GlobalIllumination/vxgidiffuse.png" alt="vxgidiffuse">  </p>
</li>
</ul>
<p>LPV把所有的次级光源发出的Radiance传播到了场景中的所有位置，只做一次让场景每个Voxel都有自己的radiance，由于LPV使用的3D网格特性，并且采用了SH进行表示和压缩, 只能考虑diffuse, 结果并不准确, 但是速度很快。  </p>
<p>VXGI把场景的次级光源记录为一个层次结构，对于一个Shading Point，我们要去通过Corn Tracing找到哪些次级光源能够照亮这个点。  </p>
<p>cons: 体素化比较慢 计算量大 需要预处理 物体移动，就得重新体素化  </p>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p>只知道camera的视角 信息只来源于当前屏幕 相当于图做一个后期处理，从而来弄出全局光照  </p>
<h3 id="Screen-Space-Ambient-Occlusion-SSAO"><a href="#Screen-Space-Ambient-Occlusion-SSAO" class="headerlink" title="Screen Space Ambient Occlusion (SSAO)"></a>Screen Space Ambient Occlusion (SSAO)</h3><p>AO 环境光遮蔽 通过相对位置来制作阴影，通过一系列的contact shadow(接触阴影)让物体相对位置感和立体感更强，是对全局光照的近似  </p>
<p>SSAO 就是在屏幕空间对全局光照的近似  </p>
<p>假设:  </p>
<ul>
<li>间接光照为常数 (blinnphong的ambient项)  </li>
<li>来自四面八方的间接光照都相同 但shadingpoint不一定都能接收到(考虑遮蔽)  </li>
<li>假设物体是Diffuse的,即使是一个glossy物体也以diffuse去渲染  </li>
</ul>
<p>原理:<br>  渲染方程将Visbility项拆开 拆出$k_A$(按cos加权平均visibility) 近似成kA和间接光照两个项 间接光照为常数 diffuse的brdf也为常数 只用计算kA<br>  <img src="/Graphics/RTR/GlobalIllumination/ssao.png" alt="ssao">  </p>
<blockquote>
<p>deep understanding: RTR常用不等式把一个product integral拆出一个项进行归一化 可以看作fx在gx覆盖范围内的平均 AO中 gx-&gt;间接光照和brdf 满足近似条件<br>$\cos\theta_i d\omega_i$就是立体角在微元面积上的投影<br><img src="/Graphics/RTR/GlobalIllumination/domega.png" alt="domega">  </p>
</blockquote>
<ul>
<li><p>求$k_A$项:  </p>
<blockquote>
<p>在世界空间直接trace光线出去获取visibility再加权平均就能得到  </p>
</blockquote>
<p>屏幕空间:  </p>
<ul>
<li>首先从相机出发，得到屏幕空间的深度信息，写入z-buffer  </li>
<li>对屏幕空间的任意一个像素（着色点），在以它为中心、R为半径的球体范围内随机寻找数个采样点，判断其可见性</li>
<li>若该采样点的深度大于它在屏幕空间对应的深度，则认为该点不可见，记可见性为0（下图绿点）  </li>
<li>计算可见性为1的采样点的占比，作为当前像素的visibility值  </li>
</ul>
<p>早期camera没法又存法线又存深度时，不能通过法线判断用一个半圆来分布点，就只能靠在撒下去的点在物体内部超过半数时才计算ao，而低于半数，就视为不会被遮蔽<br><img src="/Graphics/RTR/GlobalIllumination/kA.png" alt="kA">  </p>
<p>有可能发生如上图二所示camera认为看不到而point实际看的到的情况 但影响不大  </p>
<p>cons:实际离得远的物体在camera视角下认为产生遮挡 false occlusions  </p>
<p>采样周围一个圆的点数量越多效果越好，速度也越慢。那么就可以先用数量少的点数获取AO再模糊处理  </p>
</li>
</ul>
<p>Horizon based ambient occlusion (HBAO)  </p>
<p>知道法线的情况 只考虑了一个半球 可以做cos衰减 更准确 改善冗余阴影，大大减少采样率的需求  </p>
<p>手机端最主流的环境光遮蔽算法  </p>
<p>使用多次光线步进找到着色点切平面与遮挡物采样点形成的最大角度，再通过这个角度来计算物体与物体间的遮挡程度，从而完成对环境光遮蔽的近似  </p>
<h3 id="Screen-Space-Directional-Occlusion-SSDO"><a href="#Screen-Space-Directional-Occlusion-SSDO" class="headerlink" title="Screen Space Directional Occlusion (SSDO)"></a>Screen Space Directional Occlusion (SSDO)</h3><p>不假设接收到的间接光照都相同 把屏幕空间被直接光照照亮的物体视为次级光源  </p>
<p>AO能够产生变暗的效果使得物体相对感更强烈,但AO并不能做到Color Blending（不同颜色的Diffuse会互相照亮 这个颜色的表面上有旁边其它颜色的反射 而不是如AO直接整体变暗）  </p>
<p>类似于path tracing 从shadingpoint发出随机光线看交点<br>DO是从遮挡(光线打到)的物体产生间接光照(来自近的地方)<br>AO则是从没有遮挡的方向产生间接光照 相反 (来自远的地方)<br><img src="/Graphics/RTR/GlobalIllumination/aodo.png" alt="aodo">  </p>
<p>从shadingpoint打出光线，不会被挡住那么就受到直接光照，会被挡住则算出Q点接受的直接光照打到P点的贡献,从而求出P点的间接光照 也就是假设间接光照是从比较近的反射物来的 把直接光照和间接光照的贡献加起来就是全局光照  </p>
<p>判断遮挡: 方法类似于HBAO 在点的上半球撒点，把点连接到camera，用深度图判断会不会被挡住来近似地得到shading point的遮挡情况<br><img src="/Graphics/RTR/GlobalIllumination/ssdo.png" alt="ssdo">  </p>
<p>cons: screen space 丢失信息 只能解决小范围的间接光照(计算附近遮挡物的反射)  </p>
<h3 id="Screen-Space-Reflection-SSR"><a href="#Screen-Space-Reflection-SSR" class="headerlink" title="Screen Space Reflection (SSR)"></a>Screen Space Reflection (SSR)</h3><p>在屏幕空间做光线追踪 不仅仅能做反射，可以做任何光线追踪  </p>
<p>反射的绝大多数信息是屏幕内已有的信息 并不需要3D场景的什么信息  </p>
<p>先获得直接光照，获得法线和深度，得到反射的结果，最终结果就是全局光照  </p>
<p>得到反射的结果:  </p>
<ul>
<li>求交 Intersection: between any ray and the scene 反射光会和屏幕内的场景哪些像素相交<br>Linear Raymarch 反射光每次都往前走一定步长，直到打到场景最浅的深度，就说明和物体接触，得到相交的像素<br>获取步长:<br> Hierachical ray trace 获取动态步长 对深度图mipmap 但用最小值而不是平均值(最小池化) 和最小值不相交则不可能相交 可以跳过很多格子<br><img src="/Graphics/RTR/GlobalIllumination/ssrmipmap.png" alt="ssrmipmap">  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mip = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (level &gt; <span class="number">-1</span>)</span><br><span class="line">  step through current cell;</span><br><span class="line">  <span class="keyword">if</span> (above Z plane) ++level;</span><br><span class="line">  <span class="keyword">if</span> (below Z plane) --level;</span><br></pre></td></tr></table></figure></li>
<li>着色 Shading: contribution from intersected pixels to the shading point<br>SSR是对光追的简化，仅用屏幕内的物体的壳来进行光追<br>可以直接用path tracing算法 是specular材质则cast一次，是glossy材质就用蒙特卡洛重要性采样多次计算 但必须假设次级反射物都是diffuse 才能假设反射物反射到任何方向的radiance都是一样的<br>SSR不用考虑光线的平方衰减，并且可以保证交点的可见性，这是因为SSR的采样对象是brdf本身，而只有在对光源采样的时候才要考虑衰减和遮挡  </li>
</ul>
<p>SSR可以做镜面反射和glossy  </p>
<p>cons:  </p>
<ul>
<li>SSR受限于屏幕空间 无法反射屏幕外的物体 会导致出现明显的断点 但可以把距离远的反射结果虚化来缓解  </li>
<li>不在屏幕中这层“壳”的信息是不会被反射的(是screen space算法的通病)  </li>
</ul>
<p>pros: </p>
<ul>
<li>Sharp and blurry reflections 光滑或者模糊的结果都能得到  </li>
<li>Contact hardening 反射的结果距离越近也会越清晰  </li>
<li>Specular elongation 镜面伸长  </li>
<li>Per-pixel roughness and normal 粗糙物反射体表面不影响  </li>
</ul>
<p>Ext:  </p>
<ul>
<li>反射可以重点采样，如果是diffuse的话还是得大量采样，但diffuse是低频的，可以SH等近似的方式获得，diffuse是最难的也是最简单  </li>
<li>可以用时间和空间上的复用，时间上的复用就是一系列的预计算，空间的复用就是借鉴shading point旁边的shading结果  </li>
<li>可以在先把屏幕空间的反射结果先filter  </li>
</ul>
<h2 id="Probe-Based-Global-Illumination"><a href="#Probe-Based-Global-Illumination" class="headerlink" title="Probe-Based Global Illumination"></a>Probe-Based Global Illumination</h2><p>探针（Probe） 或者说 光照探针（Light Probe），简单理解就是场景中的一个点然后给予这个点去往四面八方收集光照或者说探测光照的能力，并把往四面八方的入射光 radiance 记录下来（其实就是记录环境光   </p>
<p>在对某个 shading point 渲染的时候就可以利用它附近 probes 的环境光信息粗略估计出它所受到的环境光信息  </p>
<p><a href="https://zhuanlan.zhihu.com/p/350753497">https://zhuanlan.zhihu.com/p/350753497</a></p>
<p><a href="https://www.cnblogs.com/KillerAery/archive/2022/10/26/16828304.html">https://www.cnblogs.com/KillerAery/archive/2022/10/26/16828304.html</a></p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>PracticalIndustrialSolutions</title>
    <url>/Graphics/RTR/PracticalIndustrialSolutions/</url>
    <content><![CDATA[<h1 id="Practical-Industrial-Solutions"><a href="#Practical-Industrial-Solutions" class="headerlink" title="Practical Industrial Solutions"></a>Practical Industrial Solutions</h1><h2 id="Temporal-Anti-Aliasing-TAA"><a href="#Temporal-Anti-Aliasing-TAA" class="headerlink" title="Temporal Anti-Aliasing (TAA)"></a>Temporal Anti-Aliasing (TAA)</h2><p>在时间上的抗锯齿或反走样<br>走样的本质为一个像素中的样本数量不足<br>MSAA - 用更多的样本  </p>
<p>Tmeporal AA的思路也是需要用更多的sample，只不过是当前帧会复用上一帧的sample，使得这一帧仍然用1SPP，但是无形中通过temporal的reuse，增加了SPP。思路与RTRT中temporal一样<br>把样本分布到过去的N帧中去，然后每一帧从过去的N帧中取得样本信息然后Filter，达到N倍Super Sampling的效果  </p>
<p>SSAA vs MSAA</p>
<p>image based anti-aliasing solution 基于图像的反走样<br>先渲染出有锯齿的图然后通过图像处理的方法将锯齿给提取出来并替换成没有锯齿的图  </p>
<p>主流:  SMAA(Enhanced subpixel morphological AA)  </p>
<p>History:　FXAA　—-&gt;　MLAA (Morphological AA)　—-&gt;　SMAA  </p>
<p>G-buffers一定不能反走样</p>
<h2 id="Temporal-Super-Resolution"><a href="#Temporal-Super-Resolution" class="headerlink" title="Temporal Super Resolution"></a>Temporal Super Resolution</h2><p>低分辨率变为高分辨率</p>
<p>(DLSS 1.0): out of nowhere / completely guessed 纯猜<br>(DLSS 2.0): from temporal information 从上一帧信息  </p>
<p>类似TAA</p>
<p>关键在于找到更好的复用上一帧信息的方案(不能用clamp)</p>
<h2 id="Deferred-Shading"><a href="#Deferred-Shading" class="headerlink" title="Deferred Shading"></a>Deferred Shading</h2><p>延迟渲染<br>shading最坏情况 传统的光栅化过程每个fragment都要shading(从远到近渲染)</p>
<p>只去渲染可见的fragment</p>
<p>光栅化两次<br>Pass 1: 光栅化中得到fragment之后不shading 只更新深度缓存<br>Pass 2: 只有深度等于最浅深度的fragment才可以通过depth test并进行shading，从而实现了只对visible fragment着色正常  </p>
<p>cons: 依赖于depth buffer(属于G-buffer) 抗锯齿困难 但能用TAA或imaged based AA解决  </p>
<p><a href="https://zhuanlan.zhihu.com/p/102134614">https://zhuanlan.zhihu.com/p/102134614</a>  </p>
<h2 id="Tiled-Shading"><a href="#Tiled-Shading" class="headerlink" title="Tiled Shading"></a>Tiled Shading</h2><p>避免没有意义的shading从而提高效率  </p>
<p>建立在Deferred Shading的基础之上，将屏幕分成若干个小块，比如一个小块是32 * 32，然后对每个小块单独的做shading<br><img src="/Graphics/RTR/PracticalIndustrialSolutions/tiledshading.jpg" alt="tiledshading"><br>节省每个小块要考虑的light数量，每个切出来的小块代表场景中3D的区域，并不是所有的光源都会跟这片区域相交<br>在做light sampling时知道光照强度会随着距离的平方衰减，因此面光源或点光源的覆盖范围是很小的，根据其随距离平方的减少找出最小值，设定一个范围，光源的覆盖范围看做一个球形。在渲染时只需要找会影响到区域的光源即可，不需要考虑所有的光源<br>如图，将屏幕分成了若干个小块，但由于是从camera看向屏幕的俯视因此是个平面图，看起来是分成了若干个小条，圆圈代表的是光源的范围，每个圆代表一个光源 数字代表区域内会影响到它的光源数量  </p>
<h3 id="Clustered-Shading"><a href="#Clustered-Shading" class="headerlink" title="Clustered Shading"></a>Clustered Shading</h3><p>进一步优化  </p>
<p>不仅将其分成若干个小块，还要在深度对其进行切片，也就是我们将整个3D空间拆分成了若干个网格<br><img src="/Graphics/RTR/PracticalIndustrialSolutions/clusteredshading.jpg" alt="clusteredshading"><br>光源可能会对这个小块区域有贡献，但不一定会对根据深度细分后的网格有贡献。所以再划分过后每个网格内的光源数量更少  </p>
<h2 id="Level-of-Detail-Solutions"><a href="#Level-of-Detail-Solutions" class="headerlink" title="Level of Detail Solutions"></a>Level of Detail Solutions</h2><p>核心思路就是为了在任何计算过程中能够快速准确的找出一个正确的level去进行各种运算texture的mip-map就是一个LOD<br>在工业界中运用LOD方法或者在不同情况下选用不同层级的思路称之为”cascaded方法“如<br>Cascaded shadow maps  </p>
<p>shadow map都有一个分辨率，当shadow map上的一个texel离camera越近，其在屏幕中所覆盖的内容越多，反之离camera越远，其所覆盖的内容越少，因此可以知道从camera出发看向场景，离camera远的可以用粗糙的shadow map<br><img src="/Graphics/RTR/PracticalIndustrialSolutions/cascaded%20shadow%20map.jpg" alt="cascaded shadow map">  </p>
<p>shadow map不会变化，实际操作中通常会生成两种或以上不同分辨率的shadow map进行使用的，如图，红色区域是一个高分辨率的shadow map，蓝色区域是覆盖范围更大但分辨率相同也就是更粗糙的shadow map  </p>
<p>根据物体在场景的位置来选用shadow map,远点的就用粗糙的，近处的就用精细的，但是从图中可以看到会有重叠区域内，因为在突然切换层级时会有一个突变的artifact,为了有一个平滑的过度，在这个区域内通过距离，也就是近处的以蓝色区域的shadow map为主将二者blend起来，从而产生平滑的过度  </p>
<p>Cascaded LPV<br>先在细小的格子上，之后随着距离的增加到大一点的格子，再远就更大<br>cons: 在不同层级之间的过渡<br>Sol: 使用blending的方法实现手动平滑过度  </p>
<p>geometric LoD<br>精细的有许多三角形的模型（高模），减化其三角形变成一个低模，生成一系列的低模<br>cons: popping artifacts camera在推进过程中由于是突变的，会出现突然变化几何的现象<br>Sol: TAA<br>Nanite in UE5  </p>
<h2 id="Global-Illumination-Solutions"><a href="#Global-Illumination-Solutions" class="headerlink" title="Global Illumination Solutions"></a>Global Illumination Solutions</h2><p>解决出屏幕, 反射物在camera背后, 壳后等情况<br>使用hybrid solutions结合多种方法<br>如先做一遍SSR，得到一个近似的GI。基于SSR对于SSR无法得到的结果，用其他的ray tracing  </p>
<ul>
<li>Software ray tracing  <ul>
<li>近处:在任意一个shading point周围一定范围内的物体用一个较高分辨率的SDF，SDF可以在shader中快速的tracing  </li>
<li>远处：用一个稍低质量的SDF将整个场景覆盖，至此不论近处还是远处都可以通过SDF得到最终光照打到的结果  </li>
<li>场景中有强烈的方向光源或者点光源，也就是手电筒之类的光源，则通过RSM解决  </li>
<li>场景是diffuse则通过DDGI来解决。Probes that stores irradiance in a 3D grid (Dynamic Diffuse GI, or DDGI)  </li>
</ul>
</li>
<li>Hardware ray tracing<ul>
<li>Doesn’t have to use the original geometry,but low-poly proxies  </li>
</ul>
</li>
</ul>
<p>Probes (RTXGI)，用RTRT的思路结合PROBE的思路，叫做RTXGI  </p>
<p>UE5的lumen  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>PBR</title>
    <url>/Graphics/RTR/PBR/</url>
    <content><![CDATA[<h1 id="Physically-Based-Rendering-PBR-and-PBR-Materials-in-RTR"><a href="#Physically-Based-Rendering-PBR-and-PBR-Materials-in-RTR" class="headerlink" title="Physically-Based Rendering (PBR) and PBR Materials in RTR"></a>Physically-Based Rendering (PBR) and PBR Materials in RTR</h1><p><img src="/Graphics/RTR/PBR/PBR.jpg" alt="PBR">  </p>
<p>PBR就是基于物理的渲染，PBR Materials也就是基于物理渲染的材质<br>PBR不止材质 但一般指的主要是材质<br>实时用的材质种类和质量和准确度不如离线  </p>
<h2 id="For-surfaces-基于表面定义的材质"><a href="#For-surfaces-基于表面定义的材质" class="headerlink" title="For surfaces 基于表面定义的材质"></a>For surfaces 基于表面定义的材质</h2><p>基于物理的渲染遵守微平面理论 Microfacet BRDF<br>Disney Principled BRDF 由于计算量小，能表现的材质总量多，也用于实时渲染，而迪士尼的brdfs也不完全基于物理，更多是为艺术家服务  </p>
<h3 id="Microfacet-BRDF"><a href="#Microfacet-BRDF" class="headerlink" title="Microfacet BRDF"></a>Microfacet BRDF</h3><p>微表面的法线分布函数 法线分布的不同导致渲染的结果也不同<br>Cook-Torrance BRDF<br><img src="/Graphics/RTR/PBR/microfacetbrdf.png" alt="microfacetbrdf">  </p>
<ul>
<li><p>The Fresnel Term (F项)<br>根据入射角不同有多少能量被反射 入射角度越接近掠射角度反射的量越多<br>将两种极化的光线加起来除于二就是结果<br>估计算法: 用基础反射加上基于入射角度的额外反射<br><img src="/Graphics/RTR/PBR/fresnel.png" alt="fresnel">  </p>
</li>
<li><p>Normal Distribution Function(NDF) (D项)<br>定义微表面法线分布函数<br>描述不同粗糙程度的表面 (NDF中lobe是集中在一个点上,还是分布的比较开)<br>Concentrated 集中 &lt;==&gt; glossy<br>Spread 分散 &lt;==&gt; diffuse<br>用不同模型定义NDF:  </p>
<ul>
<li><p>Beckmann NDF<br>类似高斯函数 定义在坡度空间<br><img src="/Graphics/RTR/PBR/beckmann.png" alt="beckmann"><br>$\alpha$ 描述法线分布的集中程度即粗糙程度<br>$\theta_h$ 宏观表面法线（0，0，1）和半程向量夹角 Beckmann NDF只和$\theta_h$有关，所以是描述各向同性(沿着中心旋转相同结果)的brdf<br>用$\tan ^2 \theta_h$不用$\theta_h^2$，$\tan \theta_h$等于无限延申的法线在和半程向量相交的平面和半程向量的距离，这样无论$\tan \theta_h$有多大，$\theta_h$代表的角度都小于90度，就不会出现法线朝下的现象<br>Backmann NDF的分母作用为归一化，NDF需要在-1到1的范围内积分  </p>
</li>
<li><p>GGX NDF<br>long tail 衰减到一定程度就会缓慢衰减，即使是在垂直角度仍会有能量反射<br>高光周围能看到光晕 边缘更加自然 有过渡 diffuse下，高光覆盖的范围更大更柔和  </p>
</li>
<li><p>Extending GGX<br>GTR longer tails $\gamma$ 等于2，等于GGX，$\gamma$ 越小，尾巴越长，$\gamma$越大，越接近Beckmann  </p>
</li>
</ul>
</li>
<li><p>Shadowing-Masking Term (G项)<br>解决微表面之间的自遮挡问题 计算变暗程度<br><img src="/Graphics/RTR/PBR/shadowingmasking.png" alt="shadowingmasking"><br>左边从light出发发生的微表面遮挡现象叫做Shadowing<br>右边从eye出发发生的微表面遮挡现象被称为Masking  </p>
<ol>
<li>darkening现象<br>实际计算出的结果会比理想结果亮,所以加上G项使得结果变暗接近理想结果<br>用于抵消公式中分母的点乘接近0的情况 (没有G项时 边缘会很亮(分母小))<br>The Smith shadowing-masking term 分开shadowing和masking计算  </li>
<li><p>Multiple Bounces<br>自遮挡时，光线会在微表面出现多次弹射，G项只考虑了一次BOUNCE,因此当只考虑一次弹射的时候，越粗糙的表面就损失的能量越多，导致能量不守恒，随着粗糙程度变大,渲染得到的结果却越暗<br>需要把能量给补回来(材质越粗糙越多沟壑反射光越可能被遮挡能量不断损失 颜色越来越暗)<br>离线渲染计算多次弹射类似光追补回能量太慢<br>核心思想: 反射光不被遮挡的时候，这些光就会被看到；当反射光被微表面遮挡的时候，认为这些被挡住的光将进行后续的弹射,直到能被看到  </p>
<ul>
<li><p>The Kulla-Conty Approximation<br>经验式的方法近似地补全丢失的能量 创建一个模拟多次反射表面反射的附加BRDF波瓣-&gt;fms，利用这个BRDF算出消失的能量作为能量补偿项<br>把lighting和brdf和cosine积分得出E(μo)即为射出的总能量(在0-1之间)<br>1-E(μo)就是丢失的能量<br><img src="/Graphics/RTR/PBR/kullaconty1.png" alt="kullaconty1">  </p>
<blockquote>
<p>Li都认为是1 也就是rendering equation中的Lighting项是1（因为是1所以式子中没有出现)<br>假设BRDF各向同性，与i、o无关<br>只计算一个bounce<br>意义是在uniform的lighting=1的情况下,在经历了1 bounce之后射出的总能量 E(uo)<br><img src="/Graphics/RTR/PBR/kullaconty10.png" alt="kullaconty10.png">  </p>
</blockquote>
<p>由于Brdf可逆 要考虑入射丢失的和出射丢失的，需要1 − E(μi)和1 − E(μo)两个项和一个用来归一化的c项来保证结果为1−E(μo) (入射能量Li视为1)<br><img src="/Graphics/RTR/PBR/kullaconty2.png" alt="kullaconty2"><br>就是设计一种可以交换输入输出方向的brdf-&gt;fms,使得它的积分结果正是我们所失去的能量,因此用失去的加射出的能量达到能量守恒<br>需要多次积分，打表预计算$E_{avg}$(只依赖于μ0与粗糙度)减少计算量  </p>
</li>
<li>BRDF 有颜色<br>有颜色代表有能量被物体吸收 也就是有额外能量损失，也就是单次反射的积分结果不是1<br>首先要先不考虑有颜色的情况下把结果算出来，再考虑被吸收掉的能量<br>先算出frensel的平均结果$F_{avg}$(不管入射角 平均每次反射会有多少能量反射)<br><img src="/Graphics/RTR/PBR/avgfrensel.png" alt="avgfrensel"><br>再算E项的平均值$E_{avg}$，$1-E_{avg}$就是会参与后续多次bounce的能量<br>第一次bounnce的结果$F_{avg} E_{avg}$多次bounece就多次乘$F_{avg} (1-E_{avg})$补充丢失的能量<br><img src="/Graphics/RTR/PBR/kullacontycolor.png" alt="kullacontycolor"><br>多次反射相加 得出一个级数表示颜色项，把这个颜色项再乘到不计算颜色的计算多次bounce的brdf上，就得到了结果<br><img src="/Graphics/RTR/PBR/colorterm.png" alt="colorterm">  </li>
</ul>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>WRONG: Combining a Microfacet BRDF with a diffuse lobe不考虑能量损失直接加Diffuse项 (会出现自发光) 不正确  </p>
</blockquote>
<p>常见的Cook-Torrance反射方程:  </p>
<p>$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$<br>$k_d, k_s$分别指入射光线中被折射部分的能量所占的比率与被反射部分的比率(菲涅尔项决定)<br>$f_{lambert}, f_{cook-torrance}$分别指漫反射和镜面反射的BRDF<br>漫反射的BRDF是一个常数 $f_{lambert} = \frac{\rho}{\pi}$  </p>
<blockquote>
<p>$\rho$可以类比光栅化当中的漫反射系数，本质是3维向量，含有物体表面的颜色信息  </p>
</blockquote>
<p>微表面模型是纯specular的模型，并且通常渲染时只考虑表面单次弹射。所以在非常粗糙的表面(沟壑多)，光线被遮挡的几率越高，能量会有损失。加一个diffuse项可以代偿这个能量的损失，尤其是在粗糙度高的表面  </p>
<p>但如WRONG所说加一个diffuse项是绝对不符合物理的 一个表面不可能既是diffuse，又是specular的 虽然通过ks + kd = 1来维持了能量守恒，但是这相当于从diffuse项为specular损失的部分凑了能量。其次，这里选择的fd是一个lambertian的brdf，是不随着roughness变化的一个brdf，更真实的diffuse应该随着roughness而发生变化</p>
<p>严谨的做法还应用上述提到的The Kulla-Conty Approximation  </p>
<p>镜面反射项如Microfacet BRDF所示  </p>
<h3 id="Linearly-Transformed-Cosines-LTC"><a href="#Linearly-Transformed-Cosines-LTC" class="headerlink" title="Linearly Transformed Cosines (LTC)"></a>Linearly Transformed Cosines (LTC)</h3><p>解决微表面模型的shading问题<br>用多边形的光源 不考虑shadow的shading 主要针对GGX模型,其他模型原理也同样适用  </p>
<p><strong>LTC就是在多边形光源的照射下快速求出在ggx模型上不考虑shadow的任意一点的Shading</strong>  </p>
<blockquote>
<p>lobe: 固定一边方向下的brdf的函数图象 BRDF是一个4维的函数,在固定一边之后就变为了2维的函数<br><img src="/Graphics/RTR/PBR/lobe.png" alt="lobe"><br>光源方向L固定的情况下，移动反射方向R，当L和R的半角向量=向量N时反射亮度最强，如果继续向上或向下改变R，反射亮度都会减弱 形状像叶片  </p>
</blockquote>
<p>不用LTC则需要采样 多边形光源上我们需要取很多采样点 速度变慢 为了不采样产生了LTC方法<br>split sum做的是环境光下的shading  </p>
<p>核心方法:  </p>
<ol>
<li>固定入射方向后,将出射的lobe(brdf的lobe)转变为一个余弦函数<br>球面的所有方向经过这个线性变换后使得brdf的lobe朝向向上 且正中间是最大值,依次向周围衰减 像cos一样<br><img src="/Graphics/RTR/PBR/ltc1.png" alt="ltc1">  </li>
<li>转换Brdf的lobe时,将多边形光源也进行变换<br>将四边形光源的四个顶点与shading point相连得到四个方向(向量),让这四个向量也进行相同的线性变换,从而形成新的四边形光源<br>此时原光源与brdf结合去照亮shading point = 新光源与cos函数结合去照亮shading point  </li>
<li>将shading point点任意brdf的lobe在任意多边形光源下积分求shading的问题转变为在一个固定cos函数下对任意的多边形光源积分求shading<br>此时要积分的东西只是cos,积分的范围虽然各不相同,但可以保证这个范围是一个多边形,而且在这个范围内积分是有解析解的,因此可以帮助我们快速求出shading<br><img src="/Graphics/RTR/PBR/ltc2.png" alt="ltc2">  </li>
</ol>
<p><img src="/Graphics/RTR/PBR/ltc3.png" alt="ltc3"><br>多边形光源内的任意radiance都是uniform Li拆出来<br>要通过某种线性变换M把所有的ωi变为新的方向ωi’,从而使F(ωi)变为cos<br>因为是单位球面所以要归一化<br>替换进去后引入一个雅克布项J balabalabala 积分有解析解  </p>
<p>省流: LTC把<em>变化brdf</em>和<em>变化光源</em>通过线性变换变成在<em>固定brdf</em>下<em>变化光源</em>问题  </p>
<h3 id="Disney’s-Principled-BRDF"><a href="#Disney’s-Principled-BRDF" class="headerlink" title="Disney’s Principled BRDF"></a>Disney’s Principled BRDF</h3><p>微表面模型的效果虽然很好,但是不能表示出所有的材质,比如真实材质就无法表示 以及多层材质<br>微表面模型对艺术家来说并不好用  </p>
<p>Disney’s Principled BRDF 使用方便 仍属于PBR 并不要求在物理上完全正确<br><img src="/Graphics/RTR/PBR/disney.png" alt="Disney"><br>所有的属性可以混合在一起使用  </p>
<h2 id="Non-Photorealistic-Rendering-NPR"><a href="#Non-Photorealistic-Rendering-NPR" class="headerlink" title="Non-Photorealistic Rendering (NPR)"></a>Non-Photorealistic Rendering (NPR)</h2><p>非真实感渲染<br>== stylization 风格化<br>art driven  </p>
<p>通常是一些轻量级的处理,一般是在shader中做一些简单但是很聪明的处理从而完成风格化  </p>
<p>Photorealistic Rendering 真实感渲染  </p>
<p>NPR:<br>1.先得到真实渲染的结果<br>2.通过观察,把Photorealistic变为Non-Photorealistic  </p>
<ul>
<li><p>Outline Rendering 轮廓渲染:  </p>
<blockquote>
<p>对Outline的定义:<br>contours-&gt;整个人物轮廓外围的一圈<br>Boundary/border edge-&gt;物体外边界上<br>Crease-&gt;折痕,通常是在两个表面之间的<br>Material edge-&gt;材质边界<br>Silhouette edge-&gt;必须是在物体外边界上且由多个面共享的  </p>
</blockquote>
<ul>
<li>Shading 基于法线<br>描边 观察方向向量和着色表面法线向量点乘,如果得到的值接近于0(更改设定的范围从而改变容忍度),说明着色区域是contour edges 粗细不一样  </li>
<li>Geometry<br>把模型背面增大一圈 染成黑 变成边界<br>将背面的每个顶点沿着顶点的法线方向向外偏移  </li>
<li>Image<br>图像后期处理 找哪些是边  </li>
</ul>
</li>
<li><p>Color blocks<br>正常的Shading model算出来的结果进行一个阈值化的操作(thresholding)<br><img src="/Graphics/RTR/PBR/colorblocks.png" alt="colorblocks"><br>可以设定多个值 从而拥有更多的色块<br>根据需要将不同风格的结果组合在一起,如diffuse和specular都进行阈值化处理,只处理spcular不处理diffuse等组合  </p>
</li>
<li><p>Strokes Surface Stylization<br>素描效果 通过格子密度调整明暗效果<br>TAMs  </p>
<ol>
<li>设计不同密度的纹理表示不同明暗  </li>
<li>设计使其密度不变的mipmap 远处无视距离只和本身密度有关 (缩小图片却不改变密度)<br><img src="/Graphics/RTR/PBR/Strokes%20Surface%20Stylization.png" alt="Strokes Surface Stylization">  </li>
</ol>
</li>
</ul>
<p>NPR做的效果好与坏,其实根本上取决于photorealistic模型,而不是后期的各种处理  </p>
<h2 id="For-volumes-基于体积"><a href="#For-volumes-基于体积" class="headerlink" title="For volumes 基于体积"></a>For volumes 基于体积</h2><p>略  </p>
<hr>
<p>深入学习:<br><a href="https://www.zhihu.com/collection/751205415">https://www.zhihu.com/collection/751205415</a><br><a href="https://zhuanlan.zhihu.com/p/20091064">https://zhuanlan.zhihu.com/p/20091064</a><br>PBR总体框架:<br><img src="/Graphics/RTR/PBR/PBR-Architecture.png" alt="PBR-Architecture">  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>RTRT</title>
    <url>/Graphics/RTR/RTRT/</url>
    <content><![CDATA[<h1 id="Real-Time-Ray-Tracing"><a href="#Real-Time-Ray-Tracing" class="headerlink" title="Real-Time Ray-Tracing"></a>Real-Time Ray-Tracing</h1><p><img src="/Graphics/RTR/RTRT/RTRT.jpg" alt="RTRT">  </p>
<blockquote>
<p>RTX: 硬件的突破 在显卡加装了一个用来做光追的部件 光线追踪做的是光线与场景的求交 做一个树的遍历从而快速判断光线是否与三角形求交,对于GPU来说不好做,NVIDA设计了专门的硬件来帮助我们每秒可以trace更多的光线  </p>
</blockquote>
<p>每秒可以trace 10 Giga的rays 除以分辨率 除以每秒的帧数 1秒中并不是全部时间都在做ray tracing<br>每个像素采样一个样本<br>至少要有四条光线才能构成一个最基本的光路<br>1 SPP path tracing =  </p>
<ul>
<li>1 rasterization (primary) 光栅化与primary ray做的工作是一样的,与其每个pixel去trace一条primary ray,不如直接将整个场景光栅化出来 +  </li>
<li>1 ray (primary visibility) 和光源之间连接进行light sampling并判断是否有遮挡+  </li>
<li>1 ray (secondary bounce)在Hitpoint根据材质采样出一个方向打出一根光线,会打到一个物体上从而得到secondary hitpoint +  </li>
<li>1 ray (secondary vis.)从secondary hitpoint与光源连接判断是否会被光源看到<br><img src="/Graphics/RTR/RTRT/1spp.png" alt="1spp">  </li>
</ul>
<p>path tracing本身是一种蒙特卡洛积分的方法,本身会产生噪声,采样的样本越多,噪声越小,但在games101中用64 spp都得不到很好的结果,何况1spp  </p>
<p>RTRT的核心技术是Denoising降噪  </p>
<p>1 spp是在20系的特点,之后30系以及更高可能会支持更多的spp  </p>
<p>1 SPP 渲染<br>质量 (no overblur 过降噪导致模糊, no artifacts 像裂缝这种可见的bug, keep all details…)<br>速度 (&lt;2ms)  </p>
<h2 id="Industrial-Sulution-Temporal"><a href="#Industrial-Sulution-Temporal" class="headerlink" title="Industrial Sulution: Temporal"></a>Industrial Sulution: Temporal</h2><p>假设整个看的场景的运动是连续的<br>motion vector 用来表示物体在帧与帧之间如何运动<br>认为前一帧是滤波好了的<br>用motion vectors找当前帧某一点在上一帧的对应位置<br>上一帧得到降噪好的结果比如颜色之类的,可以在当前帧复用,相当于增加了spp 递归<br>时间上的复用  </p>
<blockquote>
<p>The G-Buffers<br>几何缓冲区 Geometry buffer<br>轻量 屏幕空间在渲染过程中可以免费得到的额外信息 per pixel depth, normal, world coordinate, etc 需要时拿来用 只是screen space的信息(记录的是camera能看到的信息)  </p>
</blockquote>
<h3 id="Back-Projection"><a href="#Back-Projection" class="headerlink" title="Back Projection"></a>Back Projection</h3><p>找当前帧一个像素里包含的内容在上一帧的哪一个像素里  </p>
<ol>
<li>求出这个点的世界坐标  <ul>
<li>若G-buffer中有世界坐标信息的图直接用  </li>
<li>一个点的世界坐标通过MVP矩阵和视口矩阵得到在screen space上的坐标,可以逆向让screen space这个点按逆顺序乘以他们的逆矩阵就得到了世界坐标<br>$s = M^{-1}V^{-1}P^{-1}E^{-1}x$(screen space是2D坐标,需要深度这一信息来作为Z值)  </li>
</ul>
</li>
<li>将当前帧世界坐标乘以帧移动的逆矩阵就得到了上一帧中这个点的世界坐标  </li>
<li>再乘MVP矩阵和视口矩阵变回屏幕坐标上  </li>
<li>求出motion vector  </li>
</ol>
<h3 id="Temporal-Accum-Denoising"><a href="#Temporal-Accum-Denoising" class="headerlink" title="Temporal Accum./Denoising"></a>Temporal Accum./Denoising</h3><p>先做当前帧自己的降噪 再找上一帧的像素做一个线性的blending<br>80%-90%来自上一帧<br><img src="/Graphics/RTR/RTRT/temporal.png" alt="temporal">  </p>
<p>滤波不会让图变亮 只是因为噪点使得能量砍掉所以有噪声的图会更暗(HDR显示器则不会)  </p>
<h3 id="Temporal-Failure"><a href="#Temporal-Failure" class="headerlink" title="Temporal Failure"></a>Temporal Failure</h3><ol>
<li><p>switching scenes<br>突然切换场景或光源<br>burn-in period 需要一段时间预热  </p>
</li>
<li><p>walking backwards in a hallway<br>倒退走 新出现的物体找不到对应  </p>
</li>
<li><p>suddenly appearing background (disocclusion)<br>从被遮挡状态变成未被遮挡状态<br>强行用上一帧会造成Lagging残影/拖尾<br>solution:  </p>
<ul>
<li>Clamping<br>把上一帧拉到接近当前帧的结果(对上一帧的颜色拉近成这一帧的颜色)<br>和下文中的outlier removal一样 当前帧在spatial filter之后在对应点周围找一个很小的范围,找出均值和方差定一个有效范围 超出范围则clamp 再blending<br>是一个介于noisy和残影的tradeoff  </li>
<li><p>Detection<br>判断是否仍要使用上一帧的结果<br>增加一步操作来判断所对应的是不是同一个物体(给每个物体编号)  </p>
<p>会重新引入噪声  </p>
</li>
</ul>
</li>
</ol>
<p>shading时也会有问题:<br>想追踪的是shading的变换,但其几何不动因此motion vector为0<br>detached/lagging shadows<br>反射滞后  </p>
<h2 id="Implementing-of-filtering"><a href="#Implementing-of-filtering" class="headerlink" title="Implementing of filtering"></a>Implementing of filtering</h2><p>针对当前帧的滤波 滤波实际上就是对原图应用一次 Low-Pass Filter（滤除高频信息）<br>低通滤波 降噪<br>cons:<br>高频信息丢失<br>低频噪声  </p>
<p>滤波核 filter kernel K  </p>
<h3 id="高斯滤波核-Gaussian-filtering"><a href="#高斯滤波核-Gaussian-filtering" class="headerlink" title="高斯滤波核 Gaussian filtering"></a>高斯滤波核 Gaussian filtering</h3><p>类似于正态分布,中心值高,向两边衰减<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">For each pixel i</span><br><span class="line">  sum_of_weights = sum_of_weighted_values = <span class="number">0.0</span></span><br><span class="line">  For each pixel j around i</span><br><span class="line">    Calculate the weight w_ij = G(|i - j|, sigma)</span><br><span class="line">    sum_of_weighted_values += w_ij * C^&#123;input&#125;[j]</span><br><span class="line">    sum_of_weights += w_ij</span><br><span class="line">  C^&#123;output&#125;[I] = sum_of_weighted_values / sum_of_weights</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>中心像素成为i,其余的像素成为j,像素j贡献给i的值通过i和j之间的距离在高斯上找对应的值得出<br>权值和(sum_of_weights),加权贡献值的和(sum_of_weighted_values)<br>对于任何一个中心像素i<br>  我们需要定义 权值和(sum_of_weights),加权贡献值的和(sum_of_weighted_values)<br>  对于中心像素i周围一圈的任意像素j(包括像素i本身)<br>    我们需要根据像素i和像素j之间的距离和高斯的σ找对应的j贡献给i的值(权值) w_ij<br>    将权值w_ij与像素j对应的颜色rgb值相乘得到j的加权贡献值,并加到sum_of_weighted_values里<br>    将权值加到sum_of_weights<br>  进行归一化sum_of_weighted_values/sum_of_weights从而得到像素i最终的结果<br>高斯的滤波核下,sum_of_weights不会为0,但在其他的滤波核下可能会为0,因此在进行归一化从而得到像素i最终的结果之前通常会判断,sum_of_weights是否为0,如果为0则直接输出像素i的值为0  </p>
</blockquote>
<h3 id="Bilateral-Filtering-双边滤波"><a href="#Bilateral-Filtering-双边滤波" class="headerlink" title="Bilateral Filtering 双边滤波"></a>Bilateral Filtering 双边滤波</h3><p>高斯得到整体被模糊 但想边界仍然锐利(保留边界的高频信息)  </p>
<p>认为颜色变化特别剧烈的地方是边界<br>i和j颜色差异大则让像素j给i的贡献变小<br><img src="/Graphics/RTR/RTRT/Bilateral%20Filtering.png" alt="Bilateral Filtering"><br>i和j代表一个像素,k和l代表另一个像素<br>前一项仍旧是高斯滤波核<br>后一项I(i,j)表示第一个像素的值,I(k,l)表示第二个像素的值,他们之间的差异就是分子,如果差异过大,就相当于在原本的高斯核上乘上了一个指数^-(距离)平方,那么距离差异越大,使得其整体变小接近于0  </p>
<p>cons: 分不清噪声和边界  </p>
<h3 id="Cross-Joint-Bilateral-Filtering-联合双边滤波"><a href="#Cross-Joint-Bilateral-Filtering-联合双边滤波" class="headerlink" title="Cross/Joint Bilateral Filtering 联合双边滤波"></a>Cross/Joint Bilateral Filtering 联合双边滤波</h3><p>Gaussian filtering: 高斯滤波核是通过判断两个像素之间的绝对距离distance来查找其需要贡献多少<br>Bilateral filtering: 两个不同的标准，两个像素之间的距离position，和颜色之间的距离color从而在只保留低频信息时候保留了边界的信息  </p>
<p>Joint Bilateral filtering 考虑更多标准features  </p>
<p>利用G-buffers 完全无噪声 且是光栅化代替光追第一次bounce顺便得到的  </p>
<p>联合双边滤波也不需要考虑核是不是normalize的,在代码中实现时最后会进行归一化操作  </p>
<p>不一定必须要使用高斯,只要这个函数满足随着距离衰减就可以使用  </p>
<p>联合双边滤波的本质就是在kernel里多算几组不同feature(深度 normal 等)下的贡献,并将其相乘得到最后的结果  </p>
<h3 id="Implementing-Large-Filters"><a href="#Implementing-Large-Filters" class="headerlink" title="Implementing Large Filters"></a>Implementing Large Filters</h3><p>实现比较大的滤波器 filter将变慢  </p>
<ul>
<li><p>Sol. 1: Separate Passes 拆分实现  </p>
<p>先将它在水平方向上filter一遍,之后再在竖直方向上filter一遍<br>总共访问了2N个纹理(对比之前$N^2$)  </p>
<blockquote>
<p>deeper understanding:<br>2D的高斯函数本来就是拆开定义的 可拆分<br>filtering == convoluation 滤波 == 卷积<br><img src="/Graphics/RTR/RTRT/Separate%20Passes.png" alt="Separate Passes"><br>理论上只适用于高斯 双边滤波,两个高斯相乘,X和Y不容易拆分出来<br>分开是需要存贮横向之后的结果的，本质上就是空间换时间  </p>
</blockquote>
</li>
<li><p>Sol. 2: Progressively Growing Sizes<br>用一个逐步增大的filter,比如先用一个小的filter,然后用中号的filter,最后是大号的filter,通过多趟的filter得到N*N的filter得到的结果  </p>
<p>a-trous wavelet<br>第一趟是i=0,第二趟i=1依此类推,不同趟数的5*5的filter中间是有间隔的,比如i=0时,每隔2^0,也就是1个间隔采样一个,i=1时,2^1间隔采样一个但filter大小仍旧是5<em>5的.依此类推,在第i趟时,样本之间的间隔是2^i<br>假设我们现在要做5趟,每趟都是5 </em> 5的filter,那么i在第五层时候,样本之间的间隔是 2^4 = 16,第五层一共要五个样本,也就是4个间隔,因此大小为64,即第五层时相当于做了一个64 <em> 64的filter,但对于这个像素来说,我们做了五趟,每趟5 </em> 5大小的filter,一共做了125次的纹理查询,对于 64 * 64 = 4096次这个数字来说是很小<br><img src="/Graphics/RTR/RTRT/atrouswavelet.png" alt="atrouswavelet">  </p>
<blockquote>
<p>deeper understanding:<br>用更大的filter == 除掉低频信息(所以不一上来就使用第五趟中间间隔16个样本的filter)<br>采样 = 重复的搬移频谱<br><img src="/Graphics/RTR/RTRT/growingsizes.png" alt="growingsizes"><br>第一趟pass中除去了高频蓝色区域,然后在第二趟pass中相当于在9 <em> 9的filter中采样出5</em>5的filter,我们采样的间隔对应到频谱上正好是右半图的蓝色部分,也就是在第一趟除掉高频信息后的区域的2倍(tips:频谱是左右对称的),正好是尾对着下一个频谱的首,避免了走样  </p>
</blockquote>
</li>
</ul>
<h3 id="Outlier-Removal"><a href="#Outlier-Removal" class="headerlink" title="Outlier Removal"></a>Outlier Removal</h3><p>用蒙特卡洛方法渲染一张图时,得到的结果会出现一些点过亮 filter处理后会使这块区域变亮<br>在filter之前处理掉这些过亮或者过暗的点  </p>
<p>Outlier Detection and Clamping  </p>
<ul>
<li>Detection<br>对于每个像素取周围一个小范围的区域,计算这个范围内颜色的均值(mean)和方差(variance) 正常的范围在均值+-若干方差内,超过这个范围认为是outlier  </li>
<li>Clamping(outlier removal)<br>把outlier点的值给clamp到接近范围的值  </li>
</ul>
<h2 id="Specific-Filtering-Approaches-for-RTRT"><a href="#Specific-Filtering-Approaches-for-RTRT" class="headerlink" title="Specific Filtering Approaches for RTRT"></a>Specific Filtering Approaches for RTRT</h2><h3 id="Spatiotemporal-Variance-Guided-Filtering-SVGF"><a href="#Spatiotemporal-Variance-Guided-Filtering-SVGF" class="headerlink" title="Spatiotemporal Variance-Guided Filtering (SVGF)"></a>Spatiotemporal Variance-Guided Filtering (SVGF)</h3><p>三个指导filtering的重要因素:  </p>
<ol>
<li><p>Depth:<br><img src="/Graphics/RTR/RTRT/depth.png" alt="depth"><br>SVGF用来判断深度贡献权值的公式<br>公式返回的是-x次方,所以差异越大,贡献越小<br>$\epsilon$ : filter时候考虑一个点Q周围所有的点P,也包括这个点Q,因此它是有可能为0的,避免分母为0的情况,而且如果两点足够接近会导致最后的数值太大,为了避免一些数值上的问题加上一个 $\epsilon$<br>$\sigma_z$ : 用来控制指数衰减的快慢的参数,或者理解为控制深度的影响大还是小<br>$\Delta z(p) \cdot (p-q)$ 如图AB两点在一个侧向面上按理应该相互贡献但因为深度有差异计算出来不会有太大贡献 考虑A和B在平面法线方向上的深度变化 深度的梯度就是往某一方向上的变化率 用 深度梯度 X 距离 = 实际深度变化量 (垂直于平面法线上的变化 * 距离 = 实际深度变化量)  </p>
</li>
<li><p>Normal:<br><img src="/Graphics/RTR/RTRT/normal.png" alt="normal"><br>用两个点法线向量求一个点积,由于求出来的值有可能是负值,因此使用max()把负的值给clamp到0<br>点乘结果为正时则使用这个结果<br>$\sigma_n$ 判断点乘的这个cos函数从1到0是快还是慢 判断法线之间的差异的严格程度<br>如果场景中运用了法线贴图来制造凹凸效果,判断时运用平面原本的法线  </p>
</li>
<li><p>Luminance<br><img src="/Graphics/RTR/RTRT/Luminance.png" alt="Luminance"><br>应用双边滤波里给的颜色差异来考虑，将RGB转换为grayscale（灰度），这种颜色我们称其为luminance，只是一个名字，就认为其是颜色<br>颜色差异过大，则认为边界<br>可能刚好选择的点是一个噪声，也就是其特别亮，此时A特别亮，B也特别亮，那么A和B就会互相贡献<br>variance (方差) 当variance比较大时，不应该去过多的相信两点间的颜色差异<br>考虑A点是否贡献到B点时，先看A和B点之间的颜色差异，并且除以B点周围的一个标准差<br>进行 spatial filter —&gt; temporal filter —&gt; spatial filter 从而得到B点精准的variance  </p>
</li>
</ol>
<p>cons: 只移动光源 复用上一帧的阴影 产生“残影“  </p>
<h3 id="Recurrent-AutoEncoder-RAE"><a href="#Recurrent-AutoEncoder-RAE" class="headerlink" title="Recurrent AutoEncoder (RAE)"></a>Recurrent AutoEncoder (RAE)</h3><p>对Monte carlo路径追踪得到的结果进行reconstruction，也就是对RTRT做一个filter<br>后期处理降噪的方法，将一个noisy的图输入最后输出一张clean的图<br>神经网络会自动将temporal的结果累积起来(用到G-buffer)<br>…  </p>
<p><img src="/Graphics/RTR/RTRT/comparison.png" alt="comparison">  </p>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>Shadows</title>
    <url>/Graphics/RTR/Shadows/</url>
    <content><![CDATA[<h1 id="Shadows"><a href="#Shadows" class="headerlink" title="Shadows"></a>Shadows</h1><p><img src="/Graphics/RTR/Shadows/shadows.jpg" alt="Shadows">  </p>
<h2 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h2><p>实现硬阴影<br>A 2-Pass Algorithm 两趟的算法 第一趟从光源看生成shadowmap 第二趟从照相机看  </p>
<p>OpenGL: 1-pass在light处放置一个相机,然后往某一方向看去,定义framebuffer写到某个texture上,然后在fragment shader中定义写的是一个深度而非shading的结果,在2-pass中则只需要用1-pass得到的texture即可  </p>
<p>真正生成阴影时比较两个pass中的depth时需要一致,要么都用投影后的Z值比较,要么通过两点的位置得一向量算实际距离  </p>
<p>cons: 任何一帧都知道物体位置，阴影都是重新算的，shodow map也是重新算的，和物体运不运动无关  </p>
<ul>
<li><p>issues:  </p>
<ul>
<li>Self occlusion 自遮挡<br>shadowmap上一个值对应的一块区域的深度 记录的深度是不连续的，是一个一个像素的深度值组成的 眼睛观察到的像素会误认为深度在前面的像素后面，形成遮挡，即在第二个pass比较深度的时候，shadow map中的深度可能会略低于物体表面的深度，部分片元就会被误计算为阴影 垂直照的时候问题最小，掠射角度grazing angle时问题最大<br><img src="/Graphics/RTR/Shadows/selfocclusion.png" alt="self occlusion"><br>solution:<br>添加一个bias (不是常数)去调节自遮挡现象<br>具体方式就是当一个点深度大于记录深度的值超过一个阈值时，才认为这个点在阴影内(工业)<br>但会发生偏移 脚后面的阴影被舍弃了 即detach shadow<br>OpenGL解决: 通过glPolygonOffset来设置偏移量，入射角越大，偏移量越大<br>学术界解决 Second-depth shadow mapping<br>即在第一个pass时，渲染一张light看到最近深度的图同时渲染一张次近的图(透过最近的深度的像素再渲染一张最近深度)，将两个深度的中间深度来算遮挡阴影 但物体必须watertight且开销大  </li>
<li>Aliasing<br>shadow map有分辨率，自然会走样<br>采用级联阴影（CSM），通过牺牲一些显存来对阴影进行分级，从而提高阴影质量  </li>
</ul>
</li>
<li><p>Shadow mapping 后的数学原理<br>  实时渲染里的常用约等式<br>  $\int_\Omega f(x)g(x) dx \approx \frac{\int_\Omega f(x) dx}{\int_\Omega dx} \cdot \int_\Omega g(x) dx$<br>  当g的积分的范围很小的时候或者g这个函数足够光滑的时候就会比较准确<br>  <img src="/Graphics/RTR/Shadows/the%20rendering%20equation.png" alt="the rendering equation"><br>  把the rendering equation拆开 式子变成左边是visibility(遮挡)右边是shading<br>  适用范围:  </p>
<ul>
<li>积分范围(积分域)小的情况 如只有一个<em>点光源和方向光源</em>  </li>
<li><em>光源的radiance恒定</em> 情况  </li>
<li>右边的函数足够光滑情况 如<em>brdf是diffuse</em>  </li>
<li>环境光因为是近似，也能强行使用  </li>
</ul>
</li>
</ul>
<h2 id="Percentage-closer-soft-shadows-PCSS-软阴影"><a href="#Percentage-closer-soft-shadows-PCSS-软阴影" class="headerlink" title="Percentage closer soft shadows(PCSS) 软阴影"></a>Percentage closer soft shadows(PCSS) 软阴影</h2><p>光源不为点 部分遮挡时产生软阴影  </p>
<h3 id="Percentage-Closer-Filtering-PCF"><a href="#Percentage-Closer-Filtering-PCF" class="headerlink" title="Percentage Closer Filtering (PCF)"></a>Percentage Closer Filtering (PCF)</h3><p>早先是用来anti-aliasing而不是softshadows 后续发现可以用作软阴影发展成PCSS<br>不是对最后已经有锯齿的阴影做模糊<br>也不是直接filtering shadowmap 会造成阴影和物体交界直接糊起来 而且在第二个pass上做深度测试还是非0即1的结果<br>而是Filtering the results of shadow comparisons 对visibility(遮挡的结果)平均 把周围像素深度比较的结果加起来平均一下，就得到一个不是非零即一的数<br><img src="/Graphics/RTR/Shadows/PCF.png" alt="PCF">  </p>
<h3 id="PCSS"><a href="#PCSS" class="headerlink" title="PCSS"></a>PCSS</h3><p>filtering size large-&gt;越模糊-&gt;softer 足够大则能实现软阴影<br>不同位置的filtering size不同 与接受投影的位置和遮挡物blocker的距离有关 前实后虚<br>Filter size &lt;-&gt; blocker distance<br><img src="/Graphics/RTR/Shadows/filtersize.png" alt="filtersize"><br>由相似三角形 filtering的范围大小可以通过遮挡物到被遮挡面的距离除以遮挡物到光源的距离乘以光源面积得到 (面光源不会生成shadowmap 一般取光源中间某一点看作点光源生成)  </p>
<ul>
<li><p>PCSS算法流程  </p>
<ol>
<li>Blocker search<br>getting the average blocker depth in a certain region 先搜索一个范围内哪些像素是遮挡物，把这个范围所有遮挡物的深度记下来取个平均值 得到dblocker  </li>
<li>Penumbra estimation<br>use the average blocker depth to determine filter size 算filtering的范围  </li>
<li><p>Percentage Closer Filtering<br>算pcf 把任意一点p周围一圈texels是否形成遮挡进行加权平均  </p>
<blockquote>
<p>Blocker search<br>首先找到shading point在shadow map上的点 然后在shadow map对应像素周围区域里面每一个像素存的深度信息与shading point实际的深度比较 区域内的哪些像素存储的深度值比shading point的小，然后用里面这多个像素里面存储的值(就是 d blocker，光源到遮挡物的距离)的平均值average blocker作为真正的dblocker  </p>
<p>Blocker search 寻找的范围<br>要么自定义一个范围如4*4 要么如下计算<br>把shader point连向light，看在shadow map所占范围来确定，因为离光源越远，遮挡物也会更多<br><img src="/Graphics/RTR/Shadows/search%20region.png" alt="search region">  </p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>多光源只能一个一个处理<br>第一步和第三步比较慢 都要采样整个区域的深度还要进行比较<br>可以通过随机采样其中的texels，而不全部采样，当然也会造成出现噪声的结果。工业的处理的方式就是先稀疏采样得到一个有噪声的visibility的图 再在图像空间进行降噪(降噪见RTRT)  </p>
<h3 id="Variance-Soft-Shadow-Mapping-VSSM"><a href="#Variance-Soft-Shadow-Mapping-VSSM" class="headerlink" title="Variance Soft Shadow Mapping(VSSM)"></a>Variance Soft Shadow Mapping(VSSM)</h3><p>解决PCSS第一步和第三步慢  </p>
<ul>
<li><p>第三步:<br>  PCF要和周围一圈进行深度比较得出是否被遮挡，进一步就可以理解成有多少texels比取的点深度浅或深度深 要知道一个人的成绩排多少，就要知道全班人的成绩，这就是之前PCF的做法<br>  可以通过值方图得到一个相对精确的排名，可以当做一个正态分布，正态分布就只需要方差和平均值就能得出 找深度在所有深度中排百分之几  </p>
<p>  生成正态分布:  </p>
<ul>
<li>找平均值:  <ul>
<li>mipmap<br>对shadowmap做MIPMAP是做插值，只能在正方形中 在矩形的情况都会有不准  </li>
<li>Summed Area Tables (SAT)<br>前缀和 范围内求平均<br>一维把原本的数进行累加，让SAT的每个数都是原本的数从左到当前这个数的总和。这样求某个区域的和时，只要把该区域在SAT中最后一个数减去该区域前的一个数<br>二维预计算一张从左上角加到右下角的值，这样通过加减的方式，只要采这张图采四次就能得到任意区域的和。这样的结果很准确，但需要O（n（所有元素的个数））的时间和存储<br>即通过建立m行中每行的SAT和在每行的sat基础上再建立n列中每列的SAT，最终可以获得一个2维的SAT因此最终的SAT,由于gpu的并行度很高,行与行或列与列之间的sat可并行,因此具有m×n的时间复杂度<br><img src="/Graphics/RTR/Shadows/SAT.png" alt="SAT">  </li>
</ul>
</li>
<li><p>找方差:<br>  $Var(X) = E(X^2) − E^2(X)$<br>  需要额外一张shadermap(深度的平方)  </p>
<p>得到正态分布 求曲线下的面积 得出有多少texels深度比索取的点小  </p>
<blockquote>
<p>求面积:<br>对于通用的高斯的PDF(概率密度函数)，可以把积分的值打成表，积分的值就是误差函数（error function）。这个积分没有解析解，只有数值解，c++有个内置函数就是erf就能做CDF(累积分布函数 是概率密度函数的积分)  </p>
<p>切比雪夫不等式<br>任意分布，只要有均值和方差，取一个值就能得到这个值右边的面积不大于求出的值。把切比雪夫不等式当约等式，就能得到一个差不多的值(t必须在均值的右边，在左边就不准)<br><img src="/Graphics/RTR/Shadows/Chebychev.png" alt="Chebychev">  </p>
</blockquote>
<p>省流:  </p>
<ol>
<li>通过生成shadow map和square-depth map得到期望值的平方和平方值的期望再根据公式 得到方差  </li>
<li>通过mipmap或者SAT得到期望  </li>
<li>得到期望和方差之后,作出正态分布 根据切比雪夫不等式近似得到一个depth大于shading point点深度的面积.,也就是求出了未遮挡Shading point的概率,从而可以求出一个在0~1之间的visilibity</li>
</ol>
</li>
</ul>
</li>
<li><p>第一步:<br>要得到一个范围内遮挡物的平均深度。要把所有texels都得采样一遍很耗时<br>遮挡物的平均深度定义为$Z_occ$ ,不是遮挡物的平均深度定义为$Z_unocc$<br>平均深度 = 遮挡物所占比例 * 遮挡物的平均深度 + 非遮挡为所占比例 * 非遮挡平均深度<br>遮挡物所占比例和非遮挡为所占比例依旧可以用切比雪夫不等式近似得成，把非遮挡物的深度假设为当前shaderpoint的深度，就能得到遮挡物的平均深度。这样就不需要采样每个texels  </p>
</li>
</ul>
<p>VSSM 大胆假设 接受平面是曲面或者与光源不平行的时候就会出问题 主流还是PCSS  </p>
<p>cons: 漏光 不连续阴影  </p>
<h3 id="Moment-shadow-mapping-MSM"><a href="#Moment-shadow-mapping-MSM" class="headerlink" title="Moment shadow mapping (MSM)"></a>Moment shadow mapping (MSM)</h3><p>VSSM 的假设有时并不准确 MSM解决分布不为正态分布的问题<br><img src="/Graphics/RTR/Shadows/vssmincorrect.png" alt="vssmincorrect"><br><img src="/Graphics/RTR/Shadows/vssmissues.png" alt="vssmissues"><br>只有三个片的遮挡的情况下，那么深度的分布就在这三个遮挡度深度周围，形成了三个峰值<br>不是正态分布强行按正态分布算就会出现漏光和过暗的结果。在阴影的承接面不是平面的情况下也会出现阴影断掉的现象 light leaking  </p>
<ul>
<li>solution:<br>  要描述的更准确，就要使用更高阶的moment(矩)，矩的定义有很多，最简单的矩就是记录一个数的次方，所以VSSM就等于用了前两阶的矩。这样多记录几阶矩就能得到更准确的结果 <em>(类似泰勒展开?)</em><br>  如果保留前M阶的矩，就能描述一个阶跃函数，阶数等2/M,就等于某种展开。越多的阶数就和原本的分布越拟合。一般来说4阶就够用<br>  <img src="/Graphics/RTR/Shadows/moment.png" alt="moment">  </li>
</ul>
<h2 id="Distance-field-soft-shadows-DFSS"><a href="#Distance-field-soft-shadows-DFSS" class="headerlink" title="Distance field soft shadows (DFSS)"></a>Distance field soft shadows (DFSS)</h2><p>SDF<br>空间任何一个点到物体表面的最小距离，通过数值正负得到是否在物体内部，就是距离场distance function（SDF 有向距离场）。SDF引用在3D场景的话，需要存储一整个3d格子，这样存储开销就很大<br>当距离0为实，即可认为是物体的边界，SDF可以很准确地反应物体的边界。几何转换SDF的时候，可以很好地把几何进行过渡  </p>
<ul>
<li>usages:  <ul>
<li>字体渲染  </li>
<li>几何形变(GAMES101)  </li>
<li>Ray marching<br>当我们已经获得整个场景里物体SDF，有一根光线需要和SDF定义的物体隐含表面进行求交，最简单的求交方式就是sphere tracing。当光线于任意一点时，通过sdf就能得出一个安全范围内，这个光线在安全距离可以任意地向前走，在到达新的点的时候又可以通过sdf确定新的安全距离。当这个光线的距离场足够小的时候就可以很方便地和物体表面求交，或者这个光线走的足够远的时候就可以放弃这个光线的追踪<br><img src="/Graphics/RTR/Shadows/ratmarching.png" alt="raymarching">  </li>
<li>soft shadows<br>通过sdf可以获得大概有多少的范围被挡住，将安全距离的概念进行延伸，在任意一点通过sdf可以获得一个安全角度。把shading point和光源相连，所得到的安全角度越小，被遮蔽的可能越高，就可以认为安全角度越小，阴影越黑，安全角度够大就视为不被遮挡没有阴影 也就越趋近于软阴影<br><img src="/Graphics/RTR/Shadows/sdf.png" alt="sdf"><br><img src="/Graphics/RTR/Shadows/sdf2.png" alt="sdf2"><br><img src="/Graphics/RTR/Shadows/sdf3.png" alt="sdf3"><br>在光线延伸的路径上，每个点都有一个安全距离，光源和安全距离的点所形成的圆的切线和光线能形成夹角，角度最小的夹角就是安全。但这么算的复杂度太高，只要sdf长度除以光线走过的距离乘一个值k，再限定到1以内，就能得到遮挡值，而k的大小就能控制阴影的软硬程度<br>SDF用来做软阴影的速度非常快，而且质量很高，但是在存储上的消耗非常大，而且生成SDF的花的时间也要很久，SDF是预计算，在有动态的物体的情况就得重新计算SDF SDF生成的物体表面不太好贴纹理  </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Graphics</category>
        <category>RTR</category>
      </categories>
  </entry>
  <entry>
    <title>C# 语言基础</title>
    <url>/Unity/Csharp/CsharpFUNDAMENTAL/</url>
    <content><![CDATA[<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C# 语言基础"></a>C# 语言基础</h1><p>.NET 一个运行库和一个全面的基础类库。</p>
<p>.NET Framework</p>
<p>NET 平台主要有几三个构造块组成，如下：</p>
<span id="more"></span>
<ul>
<li><p>CLR Common Language Runtime，表示的是公共语言运行库。<br>  CLR 的主要作用是为我们定位、加载和管理.NET 类型，同时也负责一些低层细节的工作，如内存管理、应用托管、处理线程、案例检查等。</p>
</li>
<li><p>CTS Common Type System，表示公共类型系统。<br>  CTS 完整描述了运行库所支持的所有可能的数据类型和编程结构，指定了这些实体间如何交互、也规定了它们在 .NET 元数据格式中的表示（关于元数据，可以从网上获取参考资料）。</p>
</li>
<li><p>CLS Common  Language  Specification，它表示的是公共语言规范。<br>  CLS 定义了一个让所有 .NET 语言都支持的公共类型和编程结构的子集。这样，如果构造的 .NET 类型仅公开与CLS兼容的类型，那么可以肯定其他所有支持 .NET 的语言都能使用他们。反之，如果使用了不兼容的，就不能交互。</p>
</li>
</ul>
<p>文档注释：符号是3条斜线“///”,定在类、方法或属性的前面。</p>
<p>数组的静态初始化<br>使用静态初始化时，数组的声明与初始化必须放在同一条语句中，不能分开写；如：<br>　　int[]  ages  = { 20, 21, 25, 28, 30 } ;  </p>
<p>数组的动态初始化<br>声明与初始化可以分开或一起写 数组名 = new 数组类型[长度] 自动分配默认值<br>int[]   ages   =   new  int[5] { 20 , 22 , 24 , 26 , 30 } ;</p>
<p>foreach 是一种更简单更明了的读取数组元素的语句。<br>特点：<br>    —用于读取容器类数据（数组、集合等）<br>    — 适合一次性读取全部元素<br>    —不能修改元素<br>    foreach(  数据类型   变量名   in    数组名)<br>    {<br>        //变量名此时表示的就是数组中的每一个元素<br>    }  </p>
<p>二维数组<br>数据类型[,] 数组名 = new 数据类型[行数,列数]</p>
<p>参数修饰符</p>
<ul>
<li>out修饰符<br>定义为带有输出参数（通过关键字out）的方法有义务在退出这个方法之前，给参数赋一个恰当的值（如果不这样做，会出现编译错误）调用该方法时，也需要使用out修饰符<br>允许传递未分配(未初始化)的数据<br><strong>通过它，调用者只使用一次方法调用就能获得多个返回值。</strong></li>
</ul>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="keyword">out</span> <span class="built_in">int</span> addValue, <span class="keyword">out</span> <span class="built_in">int</span> subValue</span>)</span>&#123;</span><br><span class="line">    addValue = x + y;</span><br><span class="line">    subValue = x - y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ref修饰符<br>输出参数不需要在它们被传递给方法前初始化，因为方法在退出之前必须为输出参数赋值。<br>引用参数必须在它们被传递给方法之前初始化，因为是在传递一个对已存在变量的引用。如果不赋给它初始值，就相当于木对一直未赋值的本地变量进行操作。  </li>
</ul>
<p>方法重载<br>在同一个类的一组方法（至少大于或等于两个方法）<br>这些方法的方法名称相同，参数类型或参数个数不同<br>能否构成方法的重载，跟方法的返回值没有关系  </p>
<ul>
<li><p>protected<br>一般用于含有继承关系的子父类当中。可以由定义它们的类型及其任意子类使用，但外部类无法通过 C# 的“.”操作符访问。  </p>
</li>
<li><p>internal：内部的<br>用于修饰：类型或者类型成员<br>作用范围：当前项目下的所有类<br>使用internal修饰类中的字段或方法，在当前项目所有类下都可访问，但是其它项目是访问不到的。  </p>
</li>
<li><p>protected  internal ：受保护的内部的<br>用于修饰：类型成员或者嵌套类型　<br>如果使用了 protected  internal 关键字，作用范围在定义它们的程序集、类以及派生类中可用。  </p>
</li>
</ul>
<p>封装性  </p>
<ul>
<li><p>广义封装<br>更多的是从整个项目的项目架构设计上考虑的，比如说完成一个项目时，该项目有几个模块组件，每个模块应该包含哪些对象，对象与对象之间的关系，模块与模块之间的关系划分等，这些可以使用广义封装解决</p>
</li>
<li><p>狭义封装<br>对象的内部数据不应该从对象实例直接访问。对象数据应该被定义为私有的，如果调用者想改变对象的状态，就要间接使用公共成员。<br>狭义封装，表示的是是对一个类中的成员（字段、方法等）的访问权限（作用范围）进行的一种限制操作。<br>通常情况下，使用C#中的访问控制符（又叫访问修饰符）来修饰类中的字段和方法的作用范围，是目前实现狭义封装的一种方式。  </p>
<ol>
<li>创建完一个类后，类中的字段使用 private 修饰，类中的方法使用 public 修饰；</li>
<li>为类中用 private 修饰的字段添加一组方法，以保证既能保护类中的字段不被任何赋值修改，又可在外界必须访问这些字段时，提供一种间接访问方式；</li>
<li>说明：这组间接的访问方法叫做：Get和Set方法。</li>
</ol>
</li>
<li><p>标准属性<br>基本语法:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[访问修饰符]  　数据类型 　属性名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123;  <span class="keyword">return</span>　 字段名；  &#125; </span><br><span class="line"><span class="keyword">set</span> &#123;   字段名  = <span class="keyword">value</span> ;   &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>注意事项：<br>访问修饰符，一般都是使用 public<br>数据类型，就是当前操作的字段的类型<br>属性名，就是当前操作的字段名（使用Pascal命名法）。  </p>
<p>标准属性基本特点：<br>一个字段通常对应一个属性，属性的类型应与当前字段定义时的类型保持一致；<br>一个属性中包含一组方法 , get用于获取字段值 , set 用于为字段赋值，赋值时系统存在一个隐式变量,为value 在为字段赋值时，业务逻辑处理的代码，也是放在set中的；<br>属性本身不保存任何数据，访问字段为字段赋值等操作，看似操作的是属性，实质对数据的访问设置还是对字段的操作，且是由这两个方法实现；<br>标准属性，可设置只读 | 只写属性 ，只读权限时只保留get 方法即可；只写权限时只保留 set 方法即可；即可读又可写权限时 get 和 set 都要保留。<br>对象.属性 = xxx 时会将xxx自动传给隐式变量value set中可判断value的取值范围，满足要求再传给属性字段  </p>
</li>
<li><p>自动属性<br>当属性（又叫属性访问器）中不需要任何其他逻辑时(即不需要在set方法中添加任何业务代码)使用自动属性可以更加简洁。<br>自动属性本质就是一个字段两个方法。<br>语法：[访问修饰符]  数据类型  属性名  {  get ;  set ;  }  </p>
<p>自动属性特点：<br>自动属性可利用编译器自动生成，以简化代码的编写注：代码中输入prop，按两下Tab键即可自动生成；<br>自动属性只能成对出现,即:不能只有一个get或一个set，也就是，自动属性不支持设置 只读 | 只写 操作；<br>自动属性不支持在 set 中添加业务逻辑代码；<br>编译器在生成自动属性时，会自动添加一个私有的字段，我们在写时，不用再自己声明私有字段，只需要直接添加属性即可。  </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> name&#123;</span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> Name&#123;</span><br><span class="line">    <span class="keyword">get</span>;<span class="keyword">set</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>继承性<br>单继承，即：一个子类只能有一个直接父类（继承的单层性）；<br>编译器是先进入到父类中，调用父类无参数的构造方法，如果父类没有无参数构造方法，编译器会自动为父类添加无参数，执行完父类无参数后，再执行子类自己的构造方法<br>如果父类有其它形式构造方法，但是没有无参数的构造方法，此时程序会报错。  </p>
<ul>
<li>base<br>访问父类中的同名方法，适合于子类中存在与父类相同签名的方法时；<br>访问父类的构造方法，在子类构造方法的小括号后面使用  : base( 参数值列表 )  表示访问父类的构造方法；<br>子类构造方法小括号后面默认省略 :base()  </li>
</ul>
<p>多态性<br><strong>父类变量，创建子类对象</strong><br>基本语法：<br>　　父类　变量名　　=　　new  　子类（参数列表）<br>向上转型<br>在执行期间判断对象的类型，决定执行子类还是父类的方法的机制称之为动态绑定。<br>  当子类和父类都有相同的方法时，调用子类自己的方法；<br>  当子类没有该方法时，调用父类的方法；<br>  当子类和父类都没有调用的方法时，程序编译报错。<br>应用：  </p>
<ul>
<li>多态在数组方面的应用<br>  多态数组<br>  创建Car类的数组，可放不同子类的对象，并override不同子类的方法，自动识别</li>
<li><p>多态特性作用于方法的参数上<br>  方法参数多态<br>  定义方法的参数类型时，要求参数既可以接收多种子类型，此时就可以将参数的类型定义为父类型，而运行时会根据传递过来的参数类型具体匹配。</p>
</li>
<li><p>多态特性作用于方法的返回值上  </p>
</li>
</ul>
<p>Static  </p>
<ul>
<li>静态成员变量<br>静态成员变量属于类，类被加载时初始化，且只有一份。<br>特点：存在优先于对象，被所有对象所共享，常驻内存。  </li>
<li>静态构造函数<br>初始化类的静态数据成员。<br>仅在类被加载时执行一次。<br>不允许使用访问修饰符。  </li>
<li>静态方法<br>通过引用调用实例方法时，会隐式的传递对象引用，以便在方法内部可以正确访问该对象成员变量。<br>通过类名调用静态方法时，因为没有具体对象，所以在static方法中不能访问实例成员。  </li>
<li><p>静态类<br>不能实例化，只能包含静态成员。<br>静态类不能被继承，但是静态方法、属性都可以被继承。  </p>
</li>
<li><p>利：单独空间存储，所有对象共享，可直接被类名调用。<br>弊：静态方法中只能访问静态成员，共享数据被多个对象访问会出现并发。  </p>
</li>
<li>适用场合：  <ol>
<li>所有对象需要共享的数据。</li>
<li>在没有对象前就要访问成员。</li>
<li>工具类适合做静态类(常用，不需要过多数据)。</li>
</ol>
</li>
</ul>
<p>struct<br>与类语法相似，都可以包含数据成员和方法成员。但结构属于值类型，类属于引用类型。<br>适用表示点、颜色等轻量级对象。如创建存储1000个点的数组，如果使用类，将为每个对象分配更多内存，使用结构可以节约资源。<br>除非字段被声明为 const 或 static，否则无法初始化。<br>结构不能继承，但可以实现接口。<br>结构总会包含无参数构造函数。<br>构造函数中必须初始化所有字段。<br>结构不能包含显式的无参数构造函数  </p>
<p>集合<br>可对集合中的元素进行增删改查操作，作用都是原集合，而不会产生新的集合。  </p>
<ul>
<li>ArrayList<br>底层就是一个可动态扩展的数组；<br>提供了用于在集合中添加、删除或查找项的方法;<br>ArrayList 集合不支持泛型（即：可放任意类型的数据）；<br>使用 ArrayList 集合之前，应先导入命名命名空间：using  System.Collections ;  </li>
<li>List<br>类似于ArrayList集合，同样也提供了很多用于在集合中添加、删除或查找项的方法;提供了比ArrayList更多操作集合的方法<br>List 集合支持泛型；<br>List 集合默认的命名命名空间：using System.Collections.Generic;  </li>
<li>Dictionary</li>
</ul>
<p>内存分配</p>
<ul>
<li>类型分配<br>值类型：存储数据本身。声明在栈中，数据存储在栈中。<br>引用类型：存储数据的引用(内存地址) 声明在栈中，数据存储在堆中，栈中存储该数据的引用。  </li>
<li>内存分配<br>程序运行时，CLR将申请的内存空间从逻辑上进行划分。<ul>
<li>栈区：<br>— 空间小(1MB)，读取速度快。<br>— 用于存储正在执行的方法，分配的空间叫做栈帧。栈帧中存储方法的参数以及变量等数据。方法执行完毕后，对应的栈帧将被清除。  </li>
<li>堆区：<br>— 空间大，读取速度慢。<br>— 用于存储引用类型的数据。  </li>
</ul>
</li>
<li><p>GC(Garbage Collection)是CLR中一种针对托管堆自动回收释放内存的服务。<br>GC线程从栈中的引用开始跟踪，从而判定哪些内存是正在使用的，若GC无法跟踪到某一块堆内存，那么就认为这块内存不再使用了，即为可回收的。  </p>
<p>使用比较运算符比较值类型时，对比的是存储的数值。<br>比较引用类型时，对比的是引用的地址而不是数据。  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title>C# 设计模式</title>
    <url>/Unity/Csharp/CsharpDesignPattern/</url>
    <content><![CDATA[<h1 id="C＃设计模式"><a href="#C＃设计模式" class="headerlink" title="C＃设计模式"></a>C＃设计模式</h1><ul>
<li><p>什么是设计模式？</p>
<ul>
<li>在长久的面向对象开发过程以来，遇到种种的场景和问题，提出的解决问题的思路和方案。沉淀下来后，总结出来的解决问题的套路</li>
</ul>
</li>
<li><p>什么是设计原则？</p>
<ul>
<li>面向对象过程中，前辈大咖们推荐的一些指导性原则 遵循这些原则可以让你的设计更有竞争力。<span id="more"></span>
<h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2></li>
</ul>
</li>
</ul>
<h3 id="单一职责原则（SRP：Single-Responsibility-Principle）"><a href="#单一职责原则（SRP：Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（SRP：Single Responsibility Principle）"></a>单一职责原则（SRP：Single Responsibility Principle）</h3><blockquote>
<p>单一职责原则，SRP又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因。该原则由罗伯特C.马丁（Robert C.Martin）于《敏捷软件开发：原则、模式和实践》一书中给出的。</p>
</blockquote>
<ul>
<li><p>定义</p>
<ul>
<li><p>一个模块只负责一件事。</p>
</li>
<li><p>一个类只负责一件事</p>
</li>
<li><p>一个方法只负责一件事。</p>
</li>
</ul>
</li>
<li><p>常见违背单一职责场景</p>
<ul>
<li><p>在方法中出现多个分支，分别去执行各自的逻辑，功能虽然可以实现。</p>
</li>
<li><p>但如果需求变更，就会非常的不稳定。</p>
</li>
</ul>
</li>
<li><p>如何遵守单一职责原则</p>
<ul>
<li>定义抽象父类or父类虚方法</li>
<li>子类继承后重写，不同的实现</li>
</ul>
</li>
<li><p>实例：不同动物的叫声处理，喊叫方法中多个分支，还是不同类不同喊叫方法。</p>
</li>
<li><p>单一职责的优缺点</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>每个类相对简单，只负责自己的事情。</p>
</li>
<li><p>需求变更时，只修改变更类，其他类不受影响。</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>代码量会有所增加</p>
</li>
<li><p>解读代码成本增加</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>何时遵循？何时不遵守？</p>
<ul>
<li><p>类型逻辑足够简单，方法足够少，可以不遵守</p>
</li>
<li><p>类型复杂，方法很多，一定要遵循单一职责原则</p>
</li>
</ul>
</li>
<li><p>单一职责的不同层面</p>
<ul>
<li><p>以方法为单位</p>
<ul>
<li><p>一个方法只负责一件事</p>
</li>
<li><p>方法中可以封装成一个新方法的，就封装成一个新方法</p>
</li>
</ul>
</li>
<li><p>以类为单位 </p>
<ul>
<li><p>一个类只负责一件事</p>
</li>
<li><p>不属于该类的内容，创建新的类去封装</p>
</li>
</ul>
</li>
<li><p>以模块／项目为单位</p>
<ul>
<li><p>一个模块／项目只负责一件事</p>
</li>
<li><p>不属于该模块的内容，交由属于的模块去负责<br><code>abstract override</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="里氏替换原则（LSP：Liskov-Substitution-Principle）"><a href="#里氏替换原则（LSP：Liskov-Substitution-Principle）" class="headerlink" title="里氏替换原则（LSP：Liskov Substitution Principle）"></a>里氏替换原则（LSP：Liskov Substitution Principle）</h3><blockquote>
<p>里氏替换原则，OCP作为OO的高层原则，主张使用“抽象（Abstraction）＂和“多态（Polymorphism）＂将设计中的静态结构改为动态结构，维持设计的封闭性。“抽象”是语言提供的功能。“多态”由继承语义实现。</p>
</blockquote>
<ul>
<li><p>定义</p>
<ul>
<li><p>任何使用基类的地方，都可以安全的去使用其子类。</p>
<ul>
<li><p>父类有的内容，子类必须有【类的强继承】</p>
<ul>
<li><p>如果父类出现了子类不应该有的内容，那么就应该断开两个类的继承关系</p>
</li>
<li><p>然后，重新创建新的父类，包含子类该拥有的内容</p>
</li>
</ul>
</li>
<li><p>父类已经实现的内容，子类不要再写【不要使用new关键词隐藏父类方法］</p>
<ul>
<li>如果子类希望可以重写父类方法，父类方法用abstruct或virtual修饰</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实例：游戏角色中的攻击方法，不能被不能攻击的子类继承。<br>对于子类自己独有的行为特征 不在父类中定义再override 而是直接在子类定义</p>
</li>
</ul>
<h3 id="迪米特法则（LKP：Least-Knowledge-Principle）"><a href="#迪米特法则（LKP：Least-Knowledge-Principle）" class="headerlink" title="迪米特法则（LKP：Least Knowledge Principle）"></a>迪米特法则（LKP：Least Knowledge Principle）</h3><blockquote>
<p>迪米特法则（Law of Demeter）又叫作最少知识原则（Least Knowledge Principle 简写LKP），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解，只和朋友通信，不和陌生人说话.</p>
</blockquote>
<ul>
<li><p>定义</p>
<ul>
<li>一个对象应该对其他对象保持最少的了解 只与直接朋友进行通信。</li>
</ul>
</li>
<li><p>类与类之间的关系：</p>
<ul>
<li><p>纵向：继承关系</p>
</li>
<li><p>横向：聚合、组合、关联、依赖「出现在方法内部」</p>
</li>
</ul>
</li>
<li><p>高内聚、低耦合</p>
<ul>
<li><p>降低耦合度的方法</p>
<ol>
<li>少使用类的继承，多用接口隐藏实现的细节。</li>
<li>模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。(其实这是高内聚的一种说法，高内聚低耦合一般同时出现)。</li>
<li>遵循一个定义只在一个地方出现</li>
<li>少使用全局变量。</li>
<li>类属性和方法的声明少用public，多用private关键字。</li>
<li>多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。</li>
<li>尽量不用”硬编码”的方式写程序，同时也尽量避免直接用SQL语句操作数据库.</li>
<li>避免直接操作或调用其它模块或类(内容耦合)；如果模块间必须存在耦合，原则上尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，避免使用内容耦合。</li>
</ol>
</li>
<li><p>增强内聚度方法</p>
<ol>
<li>模块只对外暴露最小限度的接口，形成最低的依赖关系。</li>
<li>只要对外接口不变，模块内部的修改，就不得影响其他模块；</li>
<li>删除一个模块，应当只影响有依赖关系的其他模块，而不应该影响其他无关部分；</li>
</ol>
</li>
<li>通过降低访问修饰符权限，减少联系，减少耦合</li>
</ul>
</li>
</ul>
<h3 id="依赖倒置原则-DIP-Dependence-Inversion-Principle"><a href="#依赖倒置原则-DIP-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(DIP:Dependence Inversion Principle)"></a>依赖倒置原则(DIP:Dependence Inversion Principle)</h3><blockquote>
<p>依赖倒置原则(Dependence Inversion Principle)是程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
</blockquote>
<ul>
<li>定义<ul>
<li>高层模块不应该依赖于低层模块，两者应该依赖抽象 而不是依赖细节。</li>
<li>高层：方法调用方</li>
<li>底层：被调用方</li>
</ul>
</li>
<li>面向抽象编程<ul>
<li>属性、字段、方法参数、返回值，一切都尽量使用抽象【类接口】</li>
<li>抽象不变，高层就不变</li>
<li>抽象一般是稳定的，低层的扩展变化不会影响到高层，低层就可以横向的自由扩展，架构稳定</li>
<li>80%的设计模式跟抽象有关</li>
</ul>
</li>
<li>抽象的好处<ul>
<li>一个方法可以满足不同类型的参数传入</li>
<li>支持动态扩展，只要是实现了这个抽象，不需要修改上层</li>
</ul>
</li>
<li>实例：学生类实现不同手机的使用方法，学生依赖手机，新手机出现时，学生类也要更新新方法。<ul>
<li>不同的手机应该依赖抽象（手机），学生类也应该依赖于抽象(手机用户)</li>
</ul>
</li>
</ul>
<h3 id="接口隔离原则-ISP-Interface-Segregation-Principle"><a href="#接口隔离原则-ISP-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(ISP:Interface Segregation Principle)"></a>接口隔离原则(ISP:Interface Segregation Principle)</h3><blockquote>
<p>客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。</p>
</blockquote>
<ul>
<li>定义：<ul>
<li>使用多个专门的接口比使用单一的总接口要好，但也不建议一个接口只对应一个方法。</li>
<li>一个类对另外一个类的依赖性应当是建立在最小的接口上的。</li>
<li>一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。</li>
</ul>
</li>
<li>接口的正确定义<ul>
<li>既不能大而全，也不能一个接口一个方法</li>
<li>应该按照功能的密不可分来定义接口</li>
<li>应该是动态的，随业务变化而变化，设计的时候要留好提前量，避免抽象的变化</li>
</ul>
</li>
<li>实例：手机的核心功能就是打电话和发短信，拍照、上网等其他功能的接口，不要被手机所依颗。</li>
<li>参看.Net类中的接口的设计与实现</li>
</ul>
<h3 id="开闭原则-OCP-Open-Closed-Principle-【总则】"><a href="#开闭原则-OCP-Open-Closed-Principle-【总则】" class="headerlink" title="开闭原则(OCP:Open Closed Principle)【总则】"></a>开闭原则(OCP:Open Closed Principle)【总则】</h3><blockquote>
<p>在面向对象编程领域中，开闭原则规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。该特性在产品化的环境中是特别有价值的，在这种环境中，改变源代码需要代码审查，单元测试以及诸如此类的用以确保产品使用质量的过程。遵循这种原则的代码在扩展时并不发生改变，因此无需上述的过程。</p>
</blockquote>
<ul>
<li>定义<ul>
<li>对扩展开放 对修改关闭<ul>
<li>扩展：添加新代码（类）</li>
<li>修改：修改原代码（类）</li>
</ul>
</li>
</ul>
</li>
<li>开闭原则是一个目标，没有任何手段，又被称为总则</li>
<li>为什么要遵循开闭原则<ul>
<li>面向对象语言是静态语言，最害怕变化，因为会波及很多东西。</li>
<li>最理想的就是新增类，对原代码没有改动，原有代码才是可信的</li>
</ul>
</li>
<li>遇到需求变更该怎么办呢？<ul>
<li>直接修改现有方法    (最不可取)</li>
<li>增加方法    (稍好一些)</li>
<li>增加类  (那更好啦)</li>
<li>增加类库/框架   (那最好啦)</li>
</ul>
</li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p><img src="/Unity/Csharp/CsharpDesignPattern/Factory.png" alt="factory"></p>
<h4 id="Csharp"><a href="#Csharp" class="headerlink" title="Csharp"></a>Csharp</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LegencyFunction</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> Old</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">float</span>? result = Count(<span class="number">10</span>, <span class="number">21</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Debug.Log(result);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> New</span></span><br><span class="line"></span><br><span class="line">        BinaryOperation operation = OperationFactory.CreateOperation(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;+&quot;</span>);</span><br><span class="line">        operation.SetNumber(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">float</span> newresult = operation.GetResult();</span><br><span class="line">        Debug.Log(newresult);</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">region</span> Old</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span>? Count(<span class="built_in">float</span> num01, <span class="built_in">float</span> num02, <span class="built_in">string</span> sign)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (sign)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num01 + num02;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num01 - num02;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num01 * num02;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num01 / num02;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;%&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> num01 % num02;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">BinaryOperation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">float</span> number01;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">float</span> number02;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinaryOperation</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNumber</span>(<span class="params"><span class="built_in">float</span> number01,<span class="built_in">float</span> number02</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.number01 = number01;</span><br><span class="line">            <span class="keyword">this</span>.number01 = number02;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BinaryOperation</span>(<span class="params"><span class="built_in">float</span> number01, <span class="built_in">float</span> number02</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.number01 = number01;</span><br><span class="line">            <span class="keyword">this</span>.number02 = number02;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">float</span> <span class="title">GetResult</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlusOperation</span> : <span class="title">BinaryOperation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">PlusOperation</span>(<span class="params"><span class="built_in">float</span> number01, <span class="built_in">float</span> number02</span>) : <span class="title">base</span>(<span class="params">number01, number02</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetResult</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> number01 + number02;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SubtractionOperation</span> : <span class="title">BinaryOperation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SubtractionOperation</span>(<span class="params"><span class="built_in">float</span> number01, <span class="built_in">float</span> number02</span>) : <span class="title">base</span>(<span class="params">number01, number02</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetResult</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> number01 - number02;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MulOperation</span> : <span class="title">BinaryOperation</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MulOperation</span>(<span class="params"><span class="built_in">float</span> number01, <span class="built_in">float</span> number02</span>) : <span class="title">base</span>(<span class="params">number01, number02</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">float</span> <span class="title">GetResult</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> number01 * number02;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BinaryOperation <span class="title">CreateOperation</span>(<span class="params"><span class="built_in">float</span> number01, <span class="built_in">float</span> number02,<span class="built_in">string</span> sign</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (sign)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PlusOperation(number01, number02);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SubtractionOperation(number01, number02);</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> MulOperation(number01, number02);</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UnityAssetsFactory.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitAssetsFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnityAsset <span class="title">CreateUnityAsset</span>(<span class="params"><span class="built_in">string</span> assetType</span>)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (assetType)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;GameObject&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> PrefabAsset(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;Sprite&quot;</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> SpriteAsset(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="literal">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">UnityAsset</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> path;</span><br><span class="line">	<span class="keyword">protected</span> <span class="built_in">object</span> asset;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnityAsset</span>(<span class="params"><span class="built_in">string</span> path</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Load</span>()</span> &#123;</span><br><span class="line">		asset = Resources.Load(path);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Instantiate</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Show</span>()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PrefabAsset</span> : <span class="title">UnityAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrefabAsset</span>(<span class="params"><span class="built_in">string</span> path</span>) : <span class="title">base</span>(<span class="params">path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Instantiate</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		GameObject go = GameObject.Instantiate(asset <span class="keyword">as</span> GameObject);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpriteAsset</span> : <span class="title">UnityAsset</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpriteAsset</span>(<span class="params"><span class="built_in">string</span> path</span>) : <span class="title">base</span>(<span class="params">path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Instantiate</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">		GameObject go = <span class="keyword">new</span> GameObject(<span class="string">&quot;Sprite&quot;</span>);</span><br><span class="line">		SpriteRenderer spriteRenderer = go.AddComponent&lt;SpriteRenderer&gt;();</span><br><span class="line"></span><br><span class="line">		Sprite sprite = Sprite.Create(asset <span class="keyword">as</span> Texture2D, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>), Vector2.zero);</span><br><span class="line">		sprite.name = <span class="string">&quot;sprite&quot;</span>;</span><br><span class="line">		spriteRenderer.sprite = sprite;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Show</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UnitySingtonFactory.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitySingtonFactory</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UnitySingtonFactory instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetAsset</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> assetPath</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Resources.Load&lt;T&gt;(assetPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T[] <span class="title">GetAssets</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="built_in">string</span> assetsPath</span>) <span class="keyword">where</span> T : Object</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Resources.LoadAll&lt;T&gt;(assetsPath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//UnityFactoryConsole.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnityFactoryConsole</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//第一步，工厂生产对象</span></span><br><span class="line">        <span class="comment">//UnityAsset unityAsset = UnitAssetsFactory.CreateUnityAsset(&quot;GameObject&quot;, &quot;Cube&quot;);</span></span><br><span class="line">        <span class="comment">//UnityAsset unityAsset = UnitAssetsFactory.CreateUnityAsset(&quot;Sprite&quot;);</span></span><br><span class="line">        <span class="comment">//unityAsset.path = &quot;sword&quot;;</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/第二步，对象加载资源</span></span><br><span class="line">        <span class="comment">//unityAsset.Load();</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span>/第三步，生产该资源</span></span><br><span class="line">        <span class="comment">//unityAsset.Instantiate();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//单例工厂 --&gt; 直接获取资源</span></span><br><span class="line">        GameObject cubePrefab = UnitySingtonFactory.instance.GetAsset&lt;GameObject&gt;(<span class="string">&quot;Cube&quot;</span>);</span><br><span class="line">        Instantiate(cubePrefab);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><img src="/Unity/Csharp/CsharpDesignPattern/Strategy.png" alt="strategy"></p>
<p>工厂模式输入参数返回对象obj<br>策略模式输入参数返回方法</p>
<h4 id="Csharp-1"><a href="#Csharp-1" class="headerlink" title="Csharp"></a>Csharp</h4><p><img src="/Unity/Csharp/CsharpDesignPattern/Strategy1.png" alt="strategy1"><br><img src="/Unity/Csharp/CsharpDesignPattern/Strategy2.png" alt="strategy2"><br><img src="/Unity/Csharp/CsharpDesignPattern/Strategy3.png" alt="strategy3"></p>
<h4 id="Unity-游戏角色攻击方式不同"><a href="#Unity-游戏角色攻击方式不同" class="headerlink" title="Unity 游戏角色攻击方式不同"></a>Unity 游戏角色攻击方式不同</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Skill.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Skill</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameHero[] AttackTargets &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameHero SkillFireHero &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span>[] SkillParameters &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Damage &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 圆形攻击技能</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CircleSkill</span> : <span class="title">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到玩家坐标</span></span><br><span class="line">        Vector3 playerPos = SkillFireHero.HeroTra.position;</span><br><span class="line">        <span class="comment">//计算技能中心--&gt; playerPos + forword * length</span></span><br><span class="line">        Vector3 skillCenter = playerPos + SkillFireHero.HeroTra.forward * SkillParameters[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AttackTargets.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算该目标与技能中心的距离</span></span><br><span class="line">            <span class="built_in">float</span> dis = Vector3.Distance(skillCenter, AttackTargets[i].HeroTra.position);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果距离小于技能半径</span></span><br><span class="line">            <span class="keyword">if</span> (dis &lt;= SkillParameters[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                AttackTargets[i].TakeDamage(Damage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 矩形攻击技能</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CubeSkill</span> : <span class="title">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//拿到玩家坐标</span></span><br><span class="line">        Vector3 playerPos = SkillFireHero.HeroTra.position;</span><br><span class="line">        <span class="comment">//计算技能中心--&gt; playerPos + forword * length</span></span><br><span class="line">        Vector3 skillCenter = playerPos + SkillFireHero.HeroTra.forward * SkillParameters[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; AttackTargets.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算该目标与技能中心的距离</span></span><br><span class="line">            Vector3 dir = AttackTargets[i].HeroTra.position - skillCenter;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计算技能方向向量在横向Right和纵向Forword的投影向量</span></span><br><span class="line">            Vector3 rightDir = Vector3.Project(dir, SkillFireHero.HeroTra.right);</span><br><span class="line">            Vector3 forwardDir = Vector3.Project(dir, SkillFireHero.HeroTra.forward);</span><br><span class="line">            <span class="comment">//如果在矩形范围内</span></span><br><span class="line">            <span class="keyword">if</span> (rightDir.magnitude &lt; SkillParameters[<span class="number">1</span>]/<span class="number">2</span> &amp;&amp; forwardDir.magnitude &lt; SkillParameters[<span class="number">2</span>]/<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//收到伤害</span></span><br><span class="line">                AttackTargets[i].TakeDamage(Damage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扇形攻击技能</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SectorSkill</span> : <span class="title">Skill</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameHero</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> HeroHP &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Transform HeroTra &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Skill Skill &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GameHero</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FireSkill</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Skill.SkillFireHero = <span class="keyword">this</span>;</span><br><span class="line">        Skill.TakeDamage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TakeDamage</span>(<span class="params"><span class="built_in">float</span> damage</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        HeroHP -= damage;</span><br><span class="line"></span><br><span class="line">        Debug.Log(name + <span class="string">&quot;收到伤害&quot;</span> + damage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StrategyConsole.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StrategyConsole</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Transform angelTra;</span><br><span class="line">    <span class="keyword">public</span> Transform libaiTra;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameHero angel = <span class="keyword">new</span> GameHero(<span class="string">&quot;安琪拉&quot;</span>);</span><br><span class="line">        angel.HeroHP = <span class="number">1000</span>;</span><br><span class="line">        angel.HeroTra = angelTra;</span><br><span class="line">        GameHero libai = <span class="keyword">new</span> GameHero(<span class="string">&quot;李白&quot;</span>);</span><br><span class="line">        libai.HeroHP = <span class="number">1200</span>;</span><br><span class="line">        libai.HeroTra = libaiTra;</span><br><span class="line"></span><br><span class="line">        GameHero[] allHeros = <span class="keyword">new</span> GameHero[] &#123; angel, libai &#125;;</span><br><span class="line"></span><br><span class="line">        Skill skill01 = <span class="keyword">new</span> CubeSkill();</span><br><span class="line">        skill01.Damage = <span class="number">100</span>;</span><br><span class="line">        skill01.SkillParameters = <span class="keyword">new</span> <span class="built_in">float</span>[] &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        skill01.AttackTargets = allHeros;</span><br><span class="line"></span><br><span class="line">        Skill skill02 = <span class="keyword">new</span> CircleSkill();</span><br><span class="line">        skill02.Damage = <span class="number">100</span>;</span><br><span class="line">        skill02.SkillParameters = <span class="keyword">new</span> <span class="built_in">float</span>[] &#123; <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        skill02.AttackTargets = allHeros;</span><br><span class="line"></span><br><span class="line">        angel.Skill = skill01;</span><br><span class="line">        libai.Skill = skill02;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)<span class="comment">//协程一直释放技能</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            angel.FireSkill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p><img src="/Unity/Csharp/CsharpDesignPattern/Facade.png" alt="facade"></p>
<h4 id="Csharp-2"><a href="#Csharp-2" class="headerlink" title="Csharp"></a>Csharp</h4><p><img src="/Unity/Csharp/CsharpDesignPattern/Facade1.png" alt="facade1"><br><img src="/Unity/Csharp/CsharpDesignPattern/Facade2.png" alt="facade2"><br><img src="/Unity/Csharp/CsharpDesignPattern/Facade3.png" alt="facade3"><br><img src="/Unity/Csharp/CsharpDesignPattern/Facade4.png" alt="facade4"><br><img src="/Unity/Csharp/CsharpDesignPattern/Facade5.png" alt="facade5"></p>
<h4 id="Unity-框架启动模式"><a href="#Unity-框架启动模式" class="headerlink" title="Unity 框架启动模式"></a>Unity 框架启动模式</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//UIFrameFacade.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIFrameFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FrameStart</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        UIAssets.instance.LoadPanel(<span class="string">&quot;MainPanel&quot;</span>);</span><br><span class="line">        UIManager.instance.PushPanel(<span class="string">&quot;MainPanel&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIAssets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> UIAssets instance = <span class="keyword">new</span> UIAssets();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIAssets</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">LoadPanel</span>(<span class="params"><span class="built_in">string</span> panelName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(panelName + <span class="string">&quot;的资源已经加载完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UIManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> UIManager instance = <span class="keyword">new</span> UIManager();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UIManager</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PushPanel</span>(<span class="params"><span class="built_in">string</span> panelName</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">&quot;已经打开窗口...&quot;</span> + panelName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//FacadeConsole.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FacadeConsole</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//框架启动</span></span><br><span class="line">        UIFrameFacade facade = <span class="keyword">new</span> UIFrameFacade();</span><br><span class="line">        facade.FrameStart();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DemoWindowFacade.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DemoWInodwFacade</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button[] buttons;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        buttons = GetComponentsInChildren&lt;Button&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BindEvent</span>(<span class="params">UnityAction unityAction</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buttons.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            buttons[i].onClick.AddListener(unityAction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><img src="/Unity/Csharp/CsharpDesignPattern/Observer.png" alt="observer"></p>
<h4 id="Unity-1"><a href="#Unity-1" class="headerlink" title="Unity"></a>Unity</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NormalObserver.cs 简单观察者模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NormalObserver</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> interval = <span class="number">3f</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        timer += Time.deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer &gt; interval)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line"></span><br><span class="line">            timer = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//复杂</span></span><br><span class="line"><span class="comment">//Observer.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象观察者</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbObserver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">ReveiveBeatifulGirlMsg</span>(<span class="params"><span class="built_in">string</span> canDateTime</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 具体的观察者</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Observer</span> : <span class="title">AbObserver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observer</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">ReveiveBeatifulGirlMsg</span>(<span class="params"><span class="built_in">string</span> canDateTime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(name + canDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Subject.cs</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象的通知者</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">AbSubject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 添加观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;observer&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddObserver</span>(<span class="params">AbObserver observer</span>)</span>;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 移除观察者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;observer&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RemoveObserver</span>(<span class="params">AbObserver observer</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 通知消息</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Notify</span>()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 具体的通知者</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Subject</span> : <span class="title">MonoBehaviour</span>, <span class="title">AbSubject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IList&lt;AbObserver&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> canDateTime = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        observers = <span class="keyword">new</span> List&lt;AbObserver&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (BeautifulGirl.instance.CanData())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//此时的时间</span></span><br><span class="line">            canDateTime = Time.time.ToString();</span><br><span class="line">            Notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddObserver</span>(<span class="params">AbObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!observers.Contains(observer))</span><br><span class="line">            observers.Add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveObserver</span>(<span class="params">AbObserver observer</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (observers.Contains(observer))</span><br><span class="line">            observers.Remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Notify</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; observers.Count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            observers[i].ReveiveBeatifulGirlMsg(canDateTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//BeautifulGirl.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeautifulGirl</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> canDateProbability = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BeautifulGirl instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">CanData</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Random.Range(<span class="number">1</span>, <span class="number">101</span>) &lt;= canDateProbability;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ObserverConsole.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObserverConsole</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//ObserverConsole</span></span><br><span class="line"></span><br><span class="line">        AbObserver ceo = <span class="keyword">new</span> Observer(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        AbObserver cto = <span class="keyword">new</span> Observer(<span class="string">&quot;老李&quot;</span>);</span><br><span class="line">        AbObserver cfo = <span class="keyword">new</span> Observer(<span class="string">&quot;老刘&quot;</span>);</span><br><span class="line"></span><br><span class="line">        AbSubject subjectZhao = GetComponent&lt;Subject&gt;();</span><br><span class="line"></span><br><span class="line">        subjectZhao.AddObserver(ceo);</span><br><span class="line">        subjectZhao.AddObserver(cto);</span><br><span class="line">        subjectZhao.AddObserver(cfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><img src="/Unity/Csharp/CsharpDesignPattern/Proxy.png" alt="proxy"></p>
<h4 id="Csharp-3"><a href="#Csharp-3" class="headerlink" title="Csharp"></a>Csharp</h4><p><img src="/Unity/Csharp/CsharpDesignPattern/Proxy1.png" alt="proxy1"><br><img src="/Unity/Csharp/CsharpDesignPattern/Proxy2.png" alt="proxy2"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CsharpProxy</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PayFine self = <span class="keyword">new</span> NormalDriver(<span class="string">&quot;老王&quot;</span>,<span class="string">&quot;11011111111111111&quot;</span>,<span class="string">&quot;1010101001&quot;</span>);</span><br><span class="line">        FriendDrive friendProxy = <span class="keyword">new</span> FriendDrive(<span class="string">&quot;小王&quot;</span>, <span class="string">&quot;11016666661111&quot;</span>, <span class="string">&quot;666666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立代理关系</span></span><br><span class="line">        friendProxy.realDriver = self;</span><br><span class="line">        <span class="comment">//自己交罚款</span></span><br><span class="line">        friendProxy.Pay(<span class="number">200</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">PayFine</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 违章者的身份证</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> violatorID;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 违章者驾驶证</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> violatorDriveID;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PayFine</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> violatorID, <span class="built_in">string</span> violatorDriveID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.violatorID = violatorID;</span><br><span class="line">        <span class="keyword">this</span>.violatorDriveID = violatorDriveID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 支付罚款、扣除分数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;money&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;score&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params"><span class="built_in">float</span> money,<span class="built_in">float</span> score</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NormalDriver</span> : <span class="title">PayFine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalDriver</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> violatorID, <span class="built_in">string</span> violatorDriveID</span>) : <span class="title">base</span>(<span class="params">name, violatorID, violatorDriveID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params"><span class="built_in">float</span> money, <span class="built_in">float</span> score</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="built_in">string</span> .Format(</span><br><span class="line">            <span class="string">&quot;我是&#123;0&#125;,身份证号&#123;1&#125;,驾驶证号&#123;2&#125;,今交罚款&#123;3&#125;,扣除分数&#123;4&#125;&quot;</span>,</span><br><span class="line">            name,violatorID,violatorDriveID,money,score));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FriendDrive</span> : <span class="title">PayFine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 真正的驾驶员，如果没有，设置为null</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> PayFine realDriver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriendDrive</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> violatorID, <span class="built_in">string</span> violatorDriveID</span>) : <span class="title">base</span>(<span class="params">name, violatorID, violatorDriveID</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Pay</span>(<span class="params"><span class="built_in">float</span> money, <span class="built_in">float</span> score</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (realDriver != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(<span class="string">&quot;代理人:&quot;</span> + name);</span><br><span class="line">            realDriver.Pay(money,score);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Unity-2"><a href="#Unity-2" class="headerlink" title="Unity"></a>Unity</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnityProxy</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.AddComponent&lt;DelayProxy&gt;();</span><br><span class="line">        <span class="comment">//延时执行方法</span></span><br><span class="line">        <span class="comment">//DelayProxy.instance.DelayCall(ShowTime,3);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取方法</span></span><br><span class="line">            MethodInfo methodInfo = GetType().GetMethod(<span class="string">&quot;ShowCurrentTime&quot;</span>);</span><br><span class="line">            <span class="comment">//通过反射，延时执行方法</span></span><br><span class="line">            DelayProxy.instance.DelayCallByReflection(methodInfo, <span class="keyword">this</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; Time.time &#125;, <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowTime</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Time:&quot;</span> + Time.time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowCurrentTime</span>(<span class="params"><span class="built_in">float</span> crtTime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;移动延时时间：&quot;</span> + crtTime);</span><br><span class="line">        Debug.Log(<span class="string">&quot;执行时间：&quot;</span> + Time.time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DelayProxy</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DelayProxy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DelayCallByReflection</span>(<span class="params">MethodInfo methodInfo,<span class="built_in">object</span> obj,<span class="built_in">object</span>[] parameters,<span class="built_in">float</span> delayTime = <span class="number">3f</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(IEDelayCallByReflection(methodInfo, obj, parameters, delayTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">IEDelayCallByReflection</span>(<span class="params">MethodInfo methodInfo, <span class="built_in">object</span> obj, <span class="built_in">object</span>[] parameters, <span class="built_in">float</span> delayTime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待几秒</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">delayTime</span>)</span>;</span><br><span class="line">        methodInfo.Invoke(obj, parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DelayCall</span>(<span class="params">System.Action action,<span class="built_in">float</span> delayTime = <span class="number">3f</span></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        StartCoroutine(IEDelayCall(action, delayTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">IEnumerator <span class="title">IEDelayCall</span>(<span class="params">System.Action action, <span class="built_in">float</span> delayTime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//等待几秒</span></span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">delayTime</span>)</span>;</span><br><span class="line">        action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title>C# 高级</title>
    <url>/Unity/Csharp/CsharpHL/</url>
    <content><![CDATA[<h1 id="C-高级"><a href="#C-高级" class="headerlink" title="C# 高级"></a>C# 高级</h1><span id="more"></span>
<h2 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h2><p>把框架写入命名空间中<br>System和System.Collections.Generic不是父子或包含关系 除非存在嵌套<br>同一个namespace的类名不能重复 不同间的可以</p>
<p><img src="/Unity/Csharp/CsharpHL/namespace.png" alt="namespace"></p>
<p>DLL文件为动态链接库文件，又称“应用程序拓展”，DLL文件中存放的是各类程序的函数(子过程)实现过程，当程序需要调用函数时需要先载入DLL，然后取得函数的地址，最后进行调用。</p>
<h2 id="TryCatch"><a href="#TryCatch" class="headerlink" title="TryCatch"></a>TryCatch</h2><p><img src="/Unity/Csharp/CsharpHL/trycatch.png" alt="trycatch"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(xxxException ex)&#123;</span><br><span class="line">    Debug.Log();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个catch异常类型子类在前父类在后</p>
<p>自定义异常<br>由于用户操作(如不符合规定的输入)引发的异常</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">xxxException</span> : <span class="title">Exception</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">xxxException</span>(<span class="params"><span class="built_in">string</span> message</span>):<span class="title">base</span>(<span class="params">message</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> xxxException(<span class="string">&quot;xxx异常&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="ReflectionType"><a href="#ReflectionType" class="headerlink" title="ReflectionType"></a>ReflectionType</h2><h3 id="获取反射类型"><a href="#获取反射类型" class="headerlink" title="获取反射类型"></a>获取反射类型</h3><ol>
<li><p>typeof 通过类名<br> <code>Type xxxType = typeof(xxx);</code><br> <code>Type xxxType = typeof(namespace.xxx);//有命名空间的类</code></p>
</li>
<li><p>GetType() 通过对象<br> <code>Type transformType = transform.GetType();</code></p>
</li>
<li><p>static GetType() 通过类名的字符串<br> <code>Type xxxType = Type.GetType(namespace.xxx);</code></p>
</li>
</ol>
<h3 id="Type类中的属性"><a href="#Type类中的属性" class="headerlink" title="Type类中的属性"></a>Type类中的属性</h3><p><img src="/Unity/Csharp/CsharpHL/type01.png" alt="property"></p>
<h3 id="Type类中的方法"><a href="#Type类中的方法" class="headerlink" title="Type类中的方法"></a>Type类中的方法</h3><p><img src="/Unity/Csharp/CsharpHL/type02.png" alt="function"></p>
<p><img src="/Unity/Csharp/CsharpHL/type03.png" alt="BindingFlags"></p>
<h3 id="用类型实例化对象"><a href="#用类型实例化对象" class="headerlink" title="用类型实例化对象"></a>用类型实例化对象</h3><p><img src="/Unity/Csharp/CsharpHL/activator.png" alt="activator"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------使用public且无参的构造函数去实例化</span></span><br><span class="line"><span class="comment">//获取类型</span></span><br><span class="line">Type goType = <span class="keyword">typeof</span>(GameObject);</span><br><span class="line"><span class="comment">//用这个类型实例化对象————必会调用构造函数</span></span><br><span class="line"><span class="built_in">object</span> goObj = Activator.CreateInstance(goType);</span><br><span class="line"><span class="comment">//使用的时候需要类型转换</span></span><br><span class="line">(goObj <span class="keyword">as</span> GameObject).AddComponent&lt;ParticleSystem&gt;();</span><br><span class="line"><span class="comment">//以上两句话相当于--&gt;GameObject go = new GameObject();</span></span><br><span class="line"><span class="comment">//-------------使用private且无参的构造函数去实例化</span></span><br><span class="line"><span class="comment">//Singleton single = new Singleton();正常情况：私有构造是无法实例化的</span></span><br><span class="line">Type singletonType = <span class="keyword">typeof</span>(Singleton);</span><br><span class="line"><span class="built_in">object</span> sgObj = Activator.CreateInstance(singletonType,<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//访问单例中的字段</span></span><br><span class="line">Debug.Log((sgObj <span class="keyword">as</span> Singleton).name);</span><br><span class="line"><span class="comment">//-------------使用public且有参的构造函数去实例化</span></span><br><span class="line">Type singletonType = <span class="keyword">typeof</span>(Singleton);</span><br><span class="line"><span class="comment">//用public有参的构造函数去实例化对象</span></span><br><span class="line"><span class="built_in">object</span> stObj = Activator.CreateInstance(singletonType, <span class="string">&quot;laowang&quot;</span>);</span><br><span class="line"><span class="comment">//打印name</span></span><br><span class="line">Debug.Log((stObj <span class="keyword">as</span> Singleton).name);</span><br><span class="line"><span class="comment">//-------------使用private且有参的构造函数去实例化</span></span><br><span class="line">Type singletonType = <span class="keyword">typeof</span>(Singleton);</span><br><span class="line"><span class="comment">//使用private且有参的构造函数去实例化</span></span><br><span class="line"><span class="built_in">object</span> obj = Activator.CreateInstance(singletonType, BindingFlags.Instance | BindingFlags.Public, <span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">12</span> &#125;, <span class="literal">null</span>);</span><br><span class="line">Debug.Log((obj <span class="keyword">as</span> Singleton).name);</span><br><span class="line">Debug.Log((obj <span class="keyword">as</span> Singleton).age);</span><br><span class="line">obj = Activator.CreateInstance(singletonType, BindingFlags.Instance | BindingFlags.NonPublic, <span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;xiaomei&quot;</span>, <span class="number">12</span>, <span class="string">&quot;beijing&quot;</span> &#125;, <span class="literal">null</span>);</span><br><span class="line">Debug.Log((obj <span class="keyword">as</span> Singleton).name);</span><br><span class="line">Debug.Log((obj <span class="keyword">as</span> Singleton).age);</span><br><span class="line">Debug.Log((obj <span class="keyword">as</span> Singleton).address);</span><br></pre></td></tr></table></figure>
<h3 id="通过反射访问字段"><a href="#通过反射访问字段" class="headerlink" title="通过反射访问字段"></a>通过反射访问字段</h3><p><img src="/Unity/Csharp/CsharpHL/fieldinfo.png" alt="fieldinfo"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类型</span></span><br><span class="line">Type sgType = <span class="keyword">typeof</span>(Singleton);</span><br><span class="line"><span class="comment">//获取name字段</span></span><br><span class="line">FieldInfo nameField = sgType.GetField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//实例化单例对象</span></span><br><span class="line"><span class="built_in">object</span> sgObj = Activator.CreateInstance(sgType, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//设置单例对象的name字段值</span></span><br><span class="line">nameField.SetValue(sgObj, <span class="string">&quot;胖枫&quot;</span>);</span><br><span class="line"><span class="comment">//获取单例对象的name字段的值</span></span><br><span class="line"><span class="built_in">object</span> nameValue = nameField.GetValue(sgObj);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">Debug.Log(nameValue);</span><br><span class="line"><span class="comment">//获取私有字段</span></span><br><span class="line">FieldInfo moneyField = sgType.GetField(<span class="string">&quot;money&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line"><span class="comment">//设置私有字段的值</span></span><br><span class="line">moneyField.SetValue(sgObj, <span class="number">9999</span>);</span><br><span class="line">(sgObj <span class="keyword">as</span> Singleton).GetMoney();</span><br></pre></td></tr></table></figure>
<h3 id="通过反射访问方法"><a href="#通过反射访问方法" class="headerlink" title="通过反射访问方法"></a>通过反射访问方法</h3><p><img src="/Unity/Csharp/CsharpHL/memberinfo.png" alt="memberinfo"></p>
<p><img src="/Unity/Csharp/CsharpHL/methodinfo.png" alt="methodinfo"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Type sgType = <span class="keyword">typeof</span>(Singleton);</span><br><span class="line"><span class="comment">//获取私有的成员方法</span></span><br><span class="line">MethodInfo setMoneyMethod = sgType.GetMethod(<span class="string">&quot;SetMoney&quot;</span>, BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">setMoneyMethod.Invoke(Singleton.GetInstance(), <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="number">8888</span> &#125;);</span><br><span class="line">Singleton.GetInstance().GetMoney();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果方法有重载，如何获取？</span></span><br><span class="line">MethodInfo setmoneyMethod = sgType.GetMethod(<span class="string">&quot;SetMoney&quot;</span>,</span><br><span class="line">    BindingFlags.Instance | BindingFlags.NonPublic,</span><br><span class="line">    <span class="literal">null</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>) &#125;, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line">setmoneyMethod.Invoke(Singleton.GetInstance(), <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;8888&quot;</span> &#125;);</span><br><span class="line">Singleton.GetInstance().GetMoney();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法有多个参数时</span></span><br><span class="line">MethodInfo setmoneyMethod = sgType.GetMethod(<span class="string">&quot;SetMoney&quot;</span>,</span><br><span class="line">    BindingFlags.Instance | BindingFlags.NonPublic,</span><br><span class="line">    <span class="literal">null</span>, <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(<span class="built_in">float</span>) &#125;, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//执行方法</span></span><br><span class="line">setmoneyMethod.Invoke(Singleton.GetInstance(), <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;8888&quot;</span>, <span class="number">2</span> &#125;);</span><br><span class="line">Singleton.GetInstance().GetMoney();</span><br></pre></td></tr></table></figure>
<p>批量调用方法<br>{“methods”:[“A”,”B”,”C”]}</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span>[] methods = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;SetName&quot;</span>,<span class="string">&quot;SetMoney&quot;</span>,<span class="string">&quot;SetEquips&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methods.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            InvokeMethod(methods[i], <span class="keyword">new</span> Type[] &#123; <span class="keyword">typeof</span>(<span class="built_in">string</span>), <span class="keyword">typeof</span>(<span class="built_in">float</span>) &#125;, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; <span class="string">&quot;8888&quot;</span>, <span class="number">2</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">InvokeMethod</span>(<span class="params"><span class="built_in">string</span> methodName,Type[] types,<span class="built_in">object</span>[] realParams</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type sgType = <span class="keyword">typeof</span>(Singleton);</span><br><span class="line">    MethodInfo setmoneyMethod = sgType.GetMethod(methodName,</span><br><span class="line">        BindingFlags.Instance | BindingFlags.NonPublic,</span><br><span class="line">        <span class="literal">null</span>, types, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//执行方法</span></span><br><span class="line">    setmoneyMethod.Invoke(Singleton.GetInstance(), realParams);</span><br><span class="line">    Singleton.GetInstance().GetMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Unity/Csharp/CsharpHL/property.png" alt="property"></p>
<h2 id="Attrubutes"><a href="#Attrubutes" class="headerlink" title="Attrubutes"></a>Attrubutes</h2><p><img src="/Unity/Csharp/CsharpHL/attrubute01.png" alt="01"></p>
<p><img src="/Unity/Csharp/CsharpHL/attrubutedescribe.png" alt="describe"></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><h4 id="Net"><a href="#Net" class="headerlink" title=".Net"></a>.Net</h4><p><img src="/Unity/Csharp/CsharpHL/attributeusage.png" alt="attributeusage"></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.All,AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthorAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> authorName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">char</span> authorSex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> datatime;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AuthorAttribute</span>(<span class="params"><span class="built_in">string</span> authorName,<span class="built_in">char</span> authorSex,<span class="built_in">string</span> datatime</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.authorName = authorName;</span><br><span class="line">        <span class="keyword">this</span>.authorSex = authorSex;</span><br><span class="line">        <span class="keyword">this</span>.datatime = datatime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/Unity/Csharp/CsharpHL/conditional.png" alt="conditional"></p>
<p><img src="/Unity/Csharp/CsharpHL/obsolete.png" alt="obsolete"><br>第二个参数为true则旧方法会报错</p>
<h4 id="customize"><a href="#customize" class="headerlink" title="customize"></a>customize</h4><p><img src="/Unity/Csharp/CsharpHL/customize.png" alt="customize"></p>
<p>用反射展示某个类型的信息</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ShowMemberAuthorMsg(gameObject.GetType());</span><br><span class="line">MemberInfo[] memberInfo = <span class="keyword">this</span>.GetType().GetMembers();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; memberInfo.Length; i++)</span><br><span class="line">    ShowMemberAuthorMsg(memberInfo[i]);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowMemberAuthorMsg</span>(<span class="params">MemberInfo memberInfo</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//TypeAttributes typeAttributes = type.Attributes;</span></span><br><span class="line">    <span class="comment">//获取类型的所有</span></span><br><span class="line">    <span class="built_in">object</span>[] atts = memberInfo.GetCustomAttributes(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = atts.Length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断该特性，是否是作者信息特性</span></span><br><span class="line">        <span class="keyword">if</span> (atts[i] <span class="keyword">is</span> AuthorAttribute)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将Object对象转换为AuthorAttribute</span></span><br><span class="line">            AuthorAttribute author = atts[i] <span class="keyword">as</span> AuthorAttribute;</span><br><span class="line">            <span class="comment">//打印该特性对象中的信息</span></span><br><span class="line">            <span class="comment">//Debug.Log(&quot;Author Name : &quot; + author.authorName);</span></span><br><span class="line">            <span class="comment">//Debug.Log(&quot;Author Sex : &quot; + author.authorSex);</span></span><br><span class="line">            <span class="comment">//Debug.Log(&quot;Author DataTime : &quot; + author.datatime);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于MethodInfo</span></span><br><span class="line">methodInfo.GetCustomAttributes(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title>C#面向对象</title>
    <url>/Unity/Csharp/CsharpOOP/</url>
    <content><![CDATA[<h1 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C#面向对象"></a>C#面向对象</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>面向过程的程序 = 算法 + 数据结构； 关心解决问题的步骤。</p>
<p>面向对象的程序 = 对象 + 交互； 关心谁在解决问题。</p>
<p>类：一个抽象的概念，即为生活中的&quot;类别&quot;。</p>
<p>对象：类的具体实例，即归属于某个类别的&quot;个体&quot;。</p>
<p>同类型的多个对象，行为相同，数据不同。</p>
<span id="more"></span>
<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p><strong>分而治之</strong> —- 将一个大的需求分解为许多类，每个类处理一个独立的模块。</p>
<p>拆分好处：独立模块便于分工，每个模块便于复用，可扩展性强。</p>
<p><strong>封装变化</strong> —- 变化的地方独立封装，避免影响其他模块。</p>
<p><strong>高 内 聚</strong> —- 类中各个方法都在完成一项任务(单一职责的类)。</p>
<p>复杂的实现封装在内部，对外提供简单的调用。</p>
<p><strong>低 耦 合</strong> —- 类与类的关联性依赖度要低(每个类独立)。</p>
<p>让一个模块的改变，尽少影响其他模块。</p>
<p>[例如：硬件高度集成化，又要可插拔]</p>
<p>最高的内聚莫过于类中仅包含1个方法，将会导致高内聚高耦合。</p>
<p>最低的耦合莫过于类中包含所有方法，将会导致低耦合低内聚。</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>复用，灵活，简单。</p>
<h3 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h3><p><strong>封装：</strong></p>
<p>数据角度讲，将一些基本数据类型复合成一个自定义类型。</p>
<p>方法角度讲，向类外提供功能，隐藏实现的细节。</p>
<p><strong>设计角度讲</strong> ，分而治之，高内聚低耦合，封装变化。</p>
<p><strong>继承：</strong></p>
<p>统一概念。</p>
<p>重用现有类的功能，在此基础上进行扩展。</p>
<p><strong>多态：</strong></p>
<p>父类的同一种动作或者行为，在不同的子类上有不同的实现。</p>
<p>(父类调用同一方法，在不同的子类上有不同的执行效果)</p>
<p>实现手段：虚方法、抽象方法、接口方法。</p>
<h3 id="类的四大关系"><a href="#类的四大关系" class="headerlink" title="类的四大关系"></a>类的四大关系</h3><p><strong>泛化：</strong> 子类与父类的关系，概念的复用，耦合度最高；</p>
<p>B类泛化A类，意味B类是A类的一种；</p>
<p>做法：B类继承A类</p>
<p><strong>实现：</strong> 抽象行为的具体实现，两者体现功能的关系，变化只影响行为；</p>
<p>A类实现B类，意味A类必须具体实现B类中所有抽象成员。</p>
<p>做法：实现抽象类、接口中的抽象成员。</p>
<p><strong>关联**</strong> ( <strong><strong>聚合</strong></strong> / <strong><strong>组合</strong></strong> ) <strong>**：</strong> 部分与整体的关系，功能的复用，变化影响一个类；</p>
<p>A与B关联，意味着B是A的一部分；</p>
<p>做法：在A类中包含B类型成员。</p>
<p><strong>依赖：</strong> 合作关系，一种相对松散的协作，变化影响一个方法；</p>
<p>A类依赖B类，意味A类的某些功能靠B类实现；</p>
<p>做法：B类型作为A类中方法的参数，并不是A的成员。</p>
<h3 id="设计的八大原则"><a href="#设计的八大原则" class="headerlink" title="设计的八大原则"></a>设计的八大原则</h3><h4 id="开-闭原则（目标、总的指导思想）"><a href="#开-闭原则（目标、总的指导思想）" class="headerlink" title="开-闭原则（目标、总的指导思想）"></a>开-闭原则（目标、总的指导思想）</h4><p><strong>O</strong> pen <strong>C</strong> losed <strong>P</strong> rinciple</p>
<p>对扩展开放，对修改关闭。</p>
<p>增加新功能，不改变原有代码。</p>
<h4 id="类的单一职责（一个类的定义）"><a href="#类的单一职责（一个类的定义）" class="headerlink" title="类的单一职责（一个类的定义）"></a>类的单一职责（一个类的定义）</h4><p><strong>S</strong> ingle <strong>R</strong> esponsibility <strong>P</strong> rinciple</p>
<p>一个类有且只有一个改变它的原因。</p>
<p>适用于基础类，不适用基于基础类构建复杂的聚合类。</p>
<h4 id="依赖倒置（依赖抽象）"><a href="#依赖倒置（依赖抽象）" class="headerlink" title="依赖倒置（依赖抽象）"></a>依赖倒置（依赖抽象）</h4><p><strong>D</strong> ependency <strong>I</strong> nversion <strong>P</strong> rinciple</p>
<p>客户端代码(调用的类)尽量依赖(使用)抽象的组件。</p>
<p>抽象的是稳定的。实现是多变的。</p>
<h4 id="组合复用原则（复用的最佳实践）"><a href="#组合复用原则（复用的最佳实践）" class="headerlink" title="组合复用原则（复用的最佳实践）"></a>组合复用原则（复用的最佳实践）</h4><p>Composite Reuse Principle</p>
<p>如果仅仅为了代码复用优先选择组合复用，而非继承复用。</p>
<p>组合的耦合性相对继承低。</p>
<h4 id="里氏替换（继承后的重写，指导继承的设计）"><a href="#里氏替换（继承后的重写，指导继承的设计）" class="headerlink" title="里氏替换（继承后的重写，指导继承的设计）"></a>里氏替换（继承后的重写，指导继承的设计）</h4><p><strong>L</strong> iskov <strong>S</strong> ubstitution <strong>P</strong> rinciple</p>
<p>父类出现的地方可以被子类替换，在替换后依然保持原功能。</p>
<p>子类要拥有父类的所有功能。</p>
<p>子类在重写父类方法时，尽量选择扩展重写，防止改变了功能。</p>
<h4 id="接口隔离（功能拆分）"><a href="#接口隔离（功能拆分）" class="headerlink" title="接口隔离（功能拆分）"></a>接口隔离（功能拆分）</h4><p><strong>I</strong> nterface <strong>S</strong> egregation <strong>P</strong> rinciple</p>
<p>尽量定义小而精的接口interface，少定义大而全的接口。本质与单一职责相同。</p>
<p>小接口之间功能隔离，实现类需要多个功能时可以选择多实现.或接口之间做继承。</p>
<h4 id="面向接口编程而非面向实现（切换、并行开发）"><a href="#面向接口编程而非面向实现（切换、并行开发）" class="headerlink" title="面向接口编程而非面向实现（切换、并行开发）"></a>面向接口编程而非面向实现（切换、并行开发）</h4><p>客户端通过一系列抽象操作实例，而无需关注具体类型。</p>
<p>便于灵活切换一系列功能。</p>
<p>实现软件的并行开发。</p>
<h4 id="迪米特法则（类与类交互的原则）"><a href="#迪米特法则（类与类交互的原则）" class="headerlink" title="迪米特法则（类与类交互的原则）"></a>迪米特法则（类与类交互的原则）</h4><p>Law of Demeter</p>
<p>不要和陌生人说话。</p>
<p>类与类交互时，在满足功能要求的基础上，传递的数据量越少越好。因为这样可能降低耦合度。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数据角度讲，将一些基本数据类型复合成一个自定义类型。</p>
<p>方法角度讲，向类外提供功能，隐藏实现的细节。</p>
<p><strong>设计角度讲</strong> ，分而治之，高内聚低耦合，封装变化。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>松散耦合，降低了程序各部分之间的依赖性。</li>
<li>简化编程，使用者不必了解具体的实现细节，只需要调用对外提供的功能。</li>
<li>增强安全性，以特定的访问权限来使用类成员，保护成员不被意外修改。</li>
</ol>
<h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ol>
<li>private：私有的， <strong>类成员默认级别</strong> ，仅在类内部可见。</li>
<li>internal：内部的， <strong>类默认级别</strong> ，仅在程序集内可见。</li>
<li>protected：受保护的，类内部与派生类中可见。</li>
<li>protected internal：意为 internal 或 protected； 程序集内或者派生类中可见。</li>
<li>public：公有的，类内类外都可见。</li>
</ol>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol>
<li>玩家可以通过摇杆控制主角运动。</li>
<li>运动过程中播放相应的动画。</li>
<li>玩家控制主角打怪，怪受伤，可能死亡。</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>角色系统，成长系统，技能系统，动画系统，运动系统，任务系统，背包系统，结算系统。</p>
<ol>
<li>识别对象：主角，小怪，输入控制，动画。</li>
<li>分配职责：</li>
</ol>
<p>主角：存储状态(攻击力，攻击速度,生命，魔法)，受伤，死亡。</p>
<p>小怪：存储状态(攻击力，攻击速度,生命，魔法)，受伤，死亡。</p>
<p>马达：移动, 旋转。</p>
<p>输入控制：控制移动,控制攻击。</p>
<p>动画系统：管理动画片段，提供动画事件。,</p>
<ol>
<li>建立交互：</li>
</ol>
<p>移动: 检测到玩家开始移动-&gt;调用动画系统播动画-&gt;调用马达的移动方法-&gt;检测到玩家松开按钮结束触摸-&gt;调用动画系统取消动画。</p>
<p>打怪: 按下技能按钮-&gt;调用技能系统释放技能-&gt;调用动画系统播动画-&gt;处理动画事件</p>
<p>-&gt;调用小怪的受伤-&gt;可能调用死亡方法。</p>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p><strong>运动系统</strong></p>
<p>角色马达：CharacterMotor</p>
<p>数据：移动速度 moveSpeed,转向速度 rotationSpeed,角色控制器(chController)</p>
<p>行为：移动（Movement），转向(LookAtTarget)</p>
<p><strong>动画系统</strong></p>
<p>角色动画参数类：CharacterAnimationParameter</p>
<p>数据：动画片段</p>
<p>*动画事件行为：AnimationEventBehaviour</p>
<p>数据：动画组件(anim)</p>
<p>行为: 攻击时使用(OnAttack),撤销动画播放(OnCancelAnim)</p>
<p><strong>角色系统</strong></p>
<p>主角状态：PlayerStatus</p>
<p>数据：生命(HP,maxHP),魔法(SP,maxSP),基础攻击力(baseATK),防御(defence),攻击间隔 (attackInterval),攻击距离(attackDistance),动画参数(animParams)</p>
<p>行为：受击(Damage) 死亡(Dead)</p>
<p>小怪状态：MonsterStatus</p>
<p>数据：生命(HP,maxHP),魔法(SP,maxSP),基础攻击力(baseATK),防御(defence),攻击间隔 (attackInterval),攻击距离(attackDistance),动画参数(animParams)</p>
<p>行为：受击(Damage),死亡(Dead)</p>
<p>摇杆输入控制：CharacterInputController</p>
<p>数据：马达(chMotor), (EasyTouch插件)</p>
<p>行为：摇杆移动执行的方法，摇杆停止时执行的方法</p>
<h2 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>重用现有类的功能，在此基础上进行扩展(功能、概念)。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>复用代码的一种方式。</li>
<li>统一概念，以层次化的方式管理类。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>耦合度高：父类的改变直接影响到所有的子类，而不需要通知子类。</p>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ol>
<li>多个类具有相同的数据或行为。</li>
<li>多个类从概念上是一致的，且需要进行统一处理。</li>
</ol>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>class A: B</p>
<p>{</p>
<p>}</p>
<p>表示A类继承B类，A类称为子类（派生类）,B类称为父类（基类，超类）</p>
<p>通过this关键字访问本类成员、通过base关键字访问父类成员。</p>
<p>一个类最多只能继承另一个类。</p>
<h3 id="继承中的构造方法"><a href="#继承中的构造方法" class="headerlink" title="继承中的构造方法"></a>继承中的构造方法</h3><p>构造方法不会继承给子类，但是在创建子类对象时，自动调用父类的构造方法，且父类构造方法先执行，子类构造方法后执行.</p>
<p>当子类采用无参构造方法创建对象时，默认调用父类的无参构造方法，如果父类没有无参构造方法，则报编译错误，解决方法有两个: 1.为父类添加无参构造方法, 2.在子类的构造方法中用base关键字指明要调用父类的哪一个有参构造方法</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>语法：</p>
<p>用abstract修饰类即为抽象类.</p>
<p>抽象类不能创建对象</p>
<p>抽象类中可能包含抽象成员(方法，属性)</p>
<p>语义：</p>
<p>抽象类表示一个概念的抽象.</p>
<p>抽象只表示做什么，拥有什么数据，但往往不表达具体做法，不表达数据具体取值</p>
<p>适用性：</p>
<ol>
<li>当不希望类创建对象的时候。</li>
<li>当有行为，但是不需要实现的时候。</li>
<li>当有一些行为，在做法上有多种可能时，但又不希望客户了解具体做法。</li>
</ol>
<p>抽象类与普通类区别：</p>
<p>相同：都可以有静态、实例成员(数据、方法、构造函数)</p>
<p>不同：抽象类使用abstract修饰，可能有抽象方法，不能直接创建对象</p>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>语法：</p>
<p>用abstract修饰并且没有实现的方法.只有方法声明，没有实现。</p>
<p>抽象方法只能出现在抽象类中。</p>
<p>抽象方法在本类中不实现，实现推迟到子类中，子类必须重写override实现。</p>
<p>语义：</p>
<p>抽象方法表达抽象行为,只关注本身，不关注行为实现。</p>
<p>抽象方法描述做什么，不描述怎么做。</p>
<p>抽象方法一个行为的抽象。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>父类同一种动作或者行为(父类型的引用调用同一方法)，在不同的子类上有不同的实现。</p>
<p>继承将相关概念的共性进行抽象，并提供了一种复用的方式；多态在共性的基础上，体现类型及行为的个性化，即一个行为有多个不同的实现。</p>
<h2 id><a href="#" class="headerlink" title="#"></a>#</h2><h2 id="实现手段"><a href="#实现手段" class="headerlink" title="实现手段"></a><strong>实现手段</strong></h2><ol>
<li>虚方法： 父类型的引用 指向 子类的对象，调用虚方法，执行子类中的重写方法。</li>
<li>抽象方法：抽象类的引用 指向 实现类的对象，调用抽象方法，执行实现类中重写方法。</li>
<li>接口：接口的引用 指向 实现类的对象，调用接口方法，执行实现类中实现方法。</li>
</ol>
<h3 id="方法隐藏"><a href="#方法隐藏" class="headerlink" title="方法隐藏"></a>方法隐藏</h3><p>定义：在子类中使用new关键字修饰的与父类同签名的方法。</p>
<p>作用：父类的方法在子类中不适用，且通过子类型引用调用时，隐藏掉父类继承的旧方法，好像该方法不存在。</p>
<h4 id="隐藏原理"><a href="#隐藏原理" class="headerlink" title="隐藏原理"></a>隐藏原理</h4><p>子类在方法表中 <strong>增加</strong> 一个新地址。</p>
<p>所以通过子类引用调用时使用新纪录，执行子类中新方法；</p>
<p>通过父类引用调用时使用旧纪录，执行父类中方法。</p>
<h3 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h3><p>定义：用vritual关键修饰的已实现方法。</p>
<p>作用：可以在子类中重写的方法。</p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>语法：在子类中使用override关键字修饰的方法。</p>
<p>作用：父类的方法在子类中不适用（虚方法），或父类没有实现(抽象方法)。子类重写可以满足对该方法的不同需求。方法重写时必须在方法前加override关键字。</p>
<p>三种方法可以重写：</p>
<p>abstract 方法在子类必须重写，除非子类也是抽象类。</p>
<p>virtual 方法在子类可以重写，父类方法的做法与子类不同。</p>
<p>override方法，已经重写过的方法，在子类还可以继续重写，除非被标识为sealed。</p>
<h4 id="重写原理"><a href="#重写原理" class="headerlink" title="重写原理"></a>重写原理</h4><p>子类在方法表中 <strong>修改</strong> 对应的地址。</p>
<p>所以不管通过父类还是子类型的引用，调用方法时，都执行对象真实类型中定义的方法。</p>
<h3 id="动态绑定-晚期绑定-与静态绑定-早期绑定"><a href="#动态绑定-晚期绑定-与静态绑定-早期绑定" class="headerlink" title="动态绑定(晚期绑定)与静态绑定(早期绑定)"></a>动态绑定(晚期绑定)与静态绑定(早期绑定)</h3><p>绑定：类型与关联的方法的调用关系，通俗讲就是一个类型能够调用哪些方法。</p>
<p>静态绑定：是指调用关系是在运行之前确定的，即编译期间。</p>
<p>动态绑定：是指调用关系是在运行期间确定的。</p>
<p>静态绑定因为在编译期确定，不占用运行时间，所以调用速度比动态绑定要快。</p>
<p>动态绑定因为在运行期确定，占用运行时间，但是更灵活。</p>
<p>方法重写是动态绑定。</p>
<p>方法隐藏是静态绑定。</p>
<h3 id="密封-Sealed"><a href="#密封-Sealed" class="headerlink" title="密封 Sealed"></a>密封 Sealed</h3><ol>
<li>用在类的定义上，指示当前类不能做父类,也就是任何类都不可继承当前类</li>
<li>用在重写的成员，指示当前类的子类，不能再次重写该成员</li>
</ol>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>接口定义一组对外的行为规范，要求它的实现类必须遵循。</p>
<p>接口只关注行为，不关注数据，且不关注行为的实现，实现由实现类完成。</p>
<p>接口自身表达&quot;能够做&quot;,不表达&quot;如何做&quot;。</p>
<p>接口是一组行为的抽象。</p>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>规范不同类型的行为,达到了不同类型在行为上是一致的。</p>
<p>扩展一个已有类的行为。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>使用interface关键定义。接口名建议用&quot;I&quot;开头，其后单词首字母大写。</p>
<p>接口中不能包含字段，可以包含：方法，属性，索引器，事件。</p>
<p>接口中的成员一定是public abstract的，但是不能写。</p>
<p>接口中的所有成员不能有实现，全部默认抽象的。</p>
<p>实现类实现接口用&quot;：&quot;与继承相同。</p>
<p>实现类实现可以实现多个接口，且每个接口中所有的成员必须都实现。</p>
<p>接口中的成员在实现类中以public的方式实现（除显式实现）。</p>
<p>接口的引用可以指向实现类的对象。</p>
<p>接口与接口之间可继承，且可以多继承。</p>
<p>类与类是单继承，类与接口是多实现，接口与接口是多继承。</p>
<p>结构（struct）可以实现接口，但不能被继承。</p>
<h3 id="抽象类与接口的选择策略"><a href="#抽象类与接口的选择策略" class="headerlink" title="抽象类与接口的选择策略"></a>抽象类与接口的选择策略</h3><p>抽象类与子类之间关系：is a [是一种]</p>
<p>接口与实现类之间关系：can do [能够做(功能)]</p>
<h3 id="接口的显式实现"><a href="#接口的显式实现" class="headerlink" title="接口的显式实现"></a>接口的显式实现</h3><p>作用：</p>
<ol>
<li>解决多接口实现时的二义性</li>
<li>解决接口中的成员对实现类不适用的问题</li>
</ol>
<p>做法：</p>
<p>在实现的成员前加接口名，并且不能加任何访问修饰符,默认为private</p>
<p>显式实现成员只能通过接口类型的引用调用。</p>
<p>Void InterFace1.Fun()</p>
<p>{ }</p>
<h3 id="Framework常用接口"><a href="#Framework常用接口" class="headerlink" title="Framework常用接口"></a>Framework常用接口</h3><p>IComparable 可比较，使类型支持比大小的功能</p>
<p>IComparer 比较器，提供比较的方法，常用于排序比较</p>
<p>IEnumerable 可枚举，使类型支持简单迭代(foreach)</p>
<p>IEnumerator 枚举器,支持MoveNext ,自己可以控制迭代的节奏</p>
<h3 id="Unity-协同程序-Coroutine"><a href="#Unity-协同程序-Coroutine" class="headerlink" title="Unity 协同程序(Coroutine)"></a>Unity 协同程序(Coroutine)</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>具有多个返回点，可以在特定时机分部执行的函数。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Unity每帧处理GameObject中的协同程序，直到函数执行完毕。</p>
<p>当一个协程函数启动时，本质创建迭代器对象；调用MoveNext方法，执行到 yield 暂时退出；待满足条件后再次调用MoveNext方法，执行后续代码，直至遇到下一个yield为止。如此循环至整个函数结束。</p>
<h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><p>通过MonoBehaviour中的StartCoroutine启动，StopCoroutine停止。</p>
<p>协程函数返回值类型为IEnumerator，方法体中通过yield关键字定义返回点，通过return xx对象定义继续执行的条件。</p>
<p>可以被yield return 的对象：</p>
<ol>
<li>null 或者 数字 —-\&gt; 等待一个渲染帧</li>
<li>new WaitForSeconds(1) —\&gt; 等待指定时间</li>
<li>new WaitForSecondsRealtime(1) —\&gt; 等待指定时间(不受时间缩放影响)</li>
<li>new WaitForFixedUpdate() —\&gt; 等待一个物理帧</li>
<li>new WaitForEndOfFrame() —\&gt; 等待一帧结束</li>
<li>new WaitWhile( 委托 ) —-\&gt; (下回分解……)</li>
<li>Coroutine —\&gt; 在另一个协程函数执行完毕后再执行。</li>
<li>WWW —\&gt;</li>
</ol>
<h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ol>
<li>延时调用。</li>
<li>分解操作。</li>
</ol>
<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>将方法包装成对象，通过调用委托对象 <strong>间接</strong> 调用方法，实现回调机制。</p>
<p>委托是引用类型，使用方法创建委托对象，方法必须符合委托的原型。</p>
<p>委托是一类行为的抽象。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>定义委托数据类型 delegate返回值 方法签名</li>
</ol>
<p>delegate void Handler();</p>
<ol>
<li>声明委托变量 Handler handler;</li>
<li>调用委托handler();</li>
<li>创建委托类型对象</li>
</ol>
<p>handler = new Handler(Fun);</p>
<h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ol>
<li>将方法做为参数进行传递，可以将一个方法的执行代码注入到另一个方法中。</li>
<li>实现回调，且比接口更加灵活。</li>
<li>实现任意方法的异步调用。</li>
<li>事件实现的基础。</li>
</ol>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ol>
<li>自定义的委托类型本质就是个类，包含Invoke、BeginInvoke、EndInvoke方法。</li>
<li>该类继承<a href="http://msdn.microsoft.com/zh-cn/library/system.multicastdelegate(v=vs.110">MulticastDelegate</a>.aspx)类，包含委托链<a href="http://referencesource.microsoft.com/mscorlib/system/object.cs.html#d9262ceecc1719ab">Object</a><a href="http://referencesource.microsoft.com/mscorlib/R/78b7357b3527057e.html">_invocationList</a>，实质就是<a href="http://referencesource.microsoft.com/mscorlib/system/delegate.cs.html#0dd8585ba1833ad7">Delegate</a>[]类型。</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/system.multicastdelegate(v=vs.110">MulticastDelegate</a>.aspx)类又继承Delegate类，包含实例方法的对象引用Object _target,方法句柄<a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.IntPtr">IntPtr</a><a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Delegate/_methodPtr:IntPtr">_methodPtr</a>。</li>
<li>创建委托对象(绑定方法),就是设置<a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Delegate/_target:Object">_target</a>与<a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Delegate/_methodPtr:IntPtr">_methodPtr</a>字段。</li>
<li>调用委托对象，本质就是调用Invoke方法，内部找到<a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Delegate/_methodPtr:IntPtr">_methodPtr</a>字段,从而调用方法。</li>
</ol>
<h3 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h3><ol>
<li>本质上是委托的一种特殊形式，以 <strong>委托链</strong> 的形式存在。</li>
<li>多播委托绑定的方法有返回值，调用委托对象时默认只会接收到最后一个方法的值。</li>
<li>获取每个方法返回值：调用委托GetInvocationList()方法，获取委托链,然后循环调用DynamicInvoke方法，即动态调用每个方法，可获取返回值。</li>
</ol>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ol>
<li>委托对象绑定(+=)多个方法时，本质调用Delegate.Combine(原对象,新对象)方法。</li>
<li><p>Combine方法内部创建新委托链(Delegate[]),再创建新委托对象，存入<a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.MulticastDelegate/_invocationList:Object">_invocationList</a>字段中。</p>
<p><img src="/Unity/Csharp/CsharpOOP/oop1.png" alt></p>
</li>
<li><p>委托对象移除(-=)某个方法时，本质调用Delegate.Remove(原对象,删除对象)方法。</p>
</li>
<li>Remove方法内部删除匹配的委托(判断_target与<a href="http://127.0.0.1/roeder/dotnet/Default.aspx?Target=code://mscorlib:4.0.0.0:b77a5c561934e089/System.Delegate/_methodPtr:IntPtr">_methodPtr</a>)。</li>
<li>如果删除后委托链中只剩下一个委托，则返回该委托；否则再新创建一个委托对象，初始化新委托链。</li>
</ol>
<h3 id="委托实现方法的异步调用"><a href="#委托实现方法的异步调用" class="headerlink" title="委托实现方法的异步调用"></a>委托实现方法的异步调用</h3><p>同步调用方法：排队调用，前一个方法执行时，后一个方法等待它的结束后才能启动。</p>
<p>异步调用方法：不排队调用，后一个方法不必等待它的结束就可启动，异步调用的方法是创建了一个新线程来工作的，与后一个方法所在不同的线程，各自独立，互不影响。</p>
<p>Framework中的任何方法都可以通过委托异步调用。(BeginInvoke)</p>
<p>步骤：</p>
<ol>
<li>为需要异步调用的方法定义一个相应的委托。</li>
<li>创建该委托的引用指向需要异步调用的方法。</li>
<li>使用委托类型的BeginInvoke方法开始异步调用。<ol>
<li>BeginInvoke中的参数IAsyncCallback 表示异步调用的方法结束时执行的回调方法，往往用回调方法来处理异步的结果。</li>
<li>BeginInvoke中的参数object 表示在回调方法中需要用到的数据，该数据被封装在IAsyncResult的AsyncState属性中。</li>
</ol>
</li>
<li>如方法有返回值，则需要调用EndInvoke取得返回值。</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>当某一对象达到某种条件或发生某种改变时，将消息及时的 <strong>通知</strong> 到其它对象。</p>
<p><img src="/Unity/Csharp/CsharpOOP/oop2.png" alt></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol>
<li>定义事件参数类 XXX <strong>EventArgs</strong> ：封装引发事件时需要由事件源传递给响应者的信息。</li>
<li>定义 <strong>委托 ：</strong> public delegate void XXX <strong>EventHandler</strong> (XXXEventArgs e);</li>
<li>定义事件源类</li>
</ol>
<p>— 基于委托声明事件 public event XXXEventHandler XXX;</p>
<p>— 在 <strong>某个</strong> 方法内部引发事件。</p>
<ol>
<li>响应者</li>
</ol>
<p>— 实例化事件源对象。</p>
<p>— 注册方法：对象名.事件名+=方法名；</p>
<p>温馨提示：即时第一次注册事件，也使用+=操作符。</p>
<h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>仅仅允许类的外部注册、注销事件，防止了例如清空委托链、直接引发事件等不正当操作，体现了封装思想。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>在事件源中声明事件，会编译为一个私有委托字段，一个公开add_XXX方法用于注册事件，一个移除remove_XXX方法用于注销事件。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>动态获取类型信息,动态创建对象,动态访问成员的过程。</p>
<h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>在编译时无法了解类型，在运行时获取类型信息，创建对象，访问成员。</p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol>
<li>得到数据类型</li>
<li>动态创建对象</li>
<li>查看类型信息（了解本身信息,成员信息）</li>
</ol>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ol>
<li>取得数据类型Type</li>
</ol>
<p>方式一：Type.GetType(&quot;类型全名&quot;);</p>
<p>适合于类型的名称已知</p>
<p>方式二：obj.GetType();</p>
<p>适合于类型名未知，类型未知，存在已有对象</p>
<p>方式三：typeof(类型)</p>
<p>适合于已知类型</p>
<p>方式四：Assembly.Load(&quot;XXX&quot;).GetType(&quot;名字&quot;);</p>
<p>适合于类型在另一个程序集中</p>
<p>Type类常用Get系列方法 Is系列属性。</p>
<ol>
<li>MethodInfo(方法)</li>
</ol>
<p>重要方法: Invoke</p>
<ol>
<li>PropertyInfo(属性)</li>
</ol>
<p>重要方法：SetValue GetValue</p>
<ol>
<li>FieldInfo(字段)</li>
</ol>
<p>重要方法：SetValue GetValue</p>
<ol>
<li>ConstructInfo(构造方法)</li>
</ol>
<p>重要方法：Invoke</p>
<h3 id="动态创建对象"><a href="#动态创建对象" class="headerlink" title="动态创建对象"></a>动态创建对象</h3><p>Activator.CreateInstance(string 程序集名称,string 类型全名)</p>
<p>Activator.CreateInstance(Type type);</p>
<p>Assembly assembly = Assembly.Load(程序集);</p>
<p>assembly.CreateInstance(Type);</p>
<p>//找到有参构造方法，动态调用构造方法</p>
<p>type.GetConstructor(typeof(string)).Invoke()</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title>SQLite</title>
    <url>/Unity/DataPersistence/SQLite/</url>
    <content><![CDATA[<h1 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h1><span id="more"></span>
<p><img src="/Unity/DataPersistence/SQLite/SQLite.png" alt="SQLite"></p>
<p>新建文件夹Plugins导入Mono.Data Mono.Data.Sqlite sqlite3 sqlite3等资源即可调用相关库<br><code>using Mono.Data.Sqlite;</code><br>新建文件夹streamingAssets导入创建的DataBase(文件夹名字不能错)</p>
<p>以下为需要定义的对象</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据库访问路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> dataBasePath;</span><br><span class="line"><span class="comment">//数据库连接对象</span></span><br><span class="line"><span class="keyword">private</span> SqliteConnection con;</span><br><span class="line"><span class="comment">//数据库指令对象</span></span><br><span class="line"><span class="keyword">private</span> SqliteCommand cmd;</span><br><span class="line"><span class="comment">//数据库读取对象</span></span><br><span class="line"><span class="keyword">private</span> SqliteDataReader reader;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到数据库的路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">    dataBasePath = <span class="string">&quot;Data Source = &quot;</span> + Application.streamingAssetsPath + <span class="string">&quot;/xxxDataBase(文件名).sqlite&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_STANDALONE_WIN</span></span><br><span class="line">    dataBasePath = <span class="string">&quot;Data Source = &quot;</span> + Application.streamingAssetsPath + <span class="string">&quot;/xxxDataBase.sqlite&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//实例化数据库连接对象，并绑定数据库路径链接</span></span><br><span class="line">con = <span class="keyword">new</span> SqliteConnection(dataBasePath);</span><br><span class="line"><span class="comment">//开始链接</span></span><br><span class="line">con.Open();</span><br><span class="line"><span class="comment">//创建数据库指令对象</span></span><br><span class="line">cmd = con.CreateCommand();</span><br></pre></td></tr></table></figure>
<ul>
<li>SQL三种执行方法</li>
</ul>
<ol>
<li><p><code>cmd.CommandText = &quot;Insert Into StudentsTable Values(&#39;xiaohong&#39;,&#39;18&#39;,&#39;TianJin&#39;)&quot;;</code><br> <code>int row = cmd.ExecuteNonQuery();</code><br> <code>Debug.Log(row);</code><br> 执行SQL，返回受影响的行数<br> 用于执行增删改</p>
</li>
<li><p><code>cmd.CommandText = &quot;Select Name From StudentsTable&quot;;</code><br> <code>object val = cmd.ExecuteScalar();</code><br> <code>Debug.Log(val);</code><br> 执行SQL语句,返回查询到的第一行第一列的数据<br> 用于执行查询单个数据</p>
</li>
<li><p><code>cmd.CommandText = &quot;Select * From StudentsTable&quot;;</code><br> 执行SQL语句,返回查询后的结果<br> 用于执行查询多个数据<br> <code>reader = cmd.ExecuteReader();</code><br> 读取下一行，若没有下一行，则返回null<br> <code>reader.Read();</code><br> 打印结果的列数reader.FieldCount</p>
 <figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> currentColumn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; reader.FieldCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        currentColumn += reader.GetName(i).ToString();</span><br><span class="line">        currentColumn += <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Debug.Log(currentColumn);</span><br><span class="line">    <span class="keyword">while</span> (reader.Read())</span><br><span class="line">    &#123;</span><br><span class="line">        currentColumn = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; reader.FieldCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentColumn += reader.GetValue(i).ToString();</span><br><span class="line">            currentColumn += <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Debug.Log(currentColumn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!reader.IsClosed)</span><br><span class="line">    &#123;</span><br><span class="line">        reader.Close();<span class="comment">//read使用完一次就要关闭一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 程序关闭时调用一次</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnApplicationQuit</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(reader != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reader.Close();</span><br><span class="line">        reader = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cmd != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cmd.Dispose();</span><br><span class="line">        cmd = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(con != <span class="literal">null</span>)</span><br><span class="line">        con.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Unity</category>
        <category>DataPersistence</category>
      </categories>
  </entry>
  <entry>
    <title>数据存储</title>
    <url>/Unity/DataPersistence/Storage/</url>
    <content><![CDATA[<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><span id="more"></span>
<p><img src="/Unity/DataPersistence/Storage/storage.png" alt="storage"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>DataPersistence</category>
      </categories>
  </entry>
  <entry>
    <title>AStarPathFinding</title>
    <url>/Unity/Frame/AStarPathFinding/</url>
    <content><![CDATA[<span id="more"></span>
<p>前面的区域，以后再来探索吧</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>FSM</title>
    <url>/Unity/Frame/FSM/</url>
    <content><![CDATA[<span id="more"></span>
<p>前面的区域，以后再来探索吧</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>Photon</title>
    <url>/Unity/Frame/Photon/</url>
    <content><![CDATA[<span id="more"></span>
<p>前面的区域，以后再来探索吧</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>AssetBundle</title>
    <url>/Unity/Frame/AssetBundle/</url>
    <content><![CDATA[<span id="more"></span>
<p>前面的区域，以后再来探索吧</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>xLua</title>
    <url>/Unity/Frame/xLua/</url>
    <content><![CDATA[<span id="more"></span>
<p>前面的区域，以后再来探索吧</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>动画系统</title>
    <url>/Unity/UnityFundamental/Animation/</url>
    <content><![CDATA[<h1 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a>动画系统</h1><span id="more"></span>
<p><img src="/Unity/UnityFundamental/Animation/ani_01.png" alt="ani01"><br><img src="/Unity/UnityFundamental/Animation/ani_02.png" alt="ani02"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>UIFrame</title>
    <url>/Unity/Frame/UIFrame/</url>
    <content><![CDATA[<h1 id="UIFrame"><a href="#UIFrame" class="headerlink" title="UIFrame"></a>UIFrame</h1><p><a href="https://github.com/vzerzz/UIFrame">项目文件</a></p>
<p><a href="https://github.com/vzerzz/UIFrame/tree/master/Assets/Scripts">代码文件</a></p>
<span id="more"></span>
<p><img src="/Unity/Frame/UIFrame/UIFrame1.png" alt="UIFrame"></p>
<h2 id="UI框架-方便解决的问题"><a href="#UI框架-方便解决的问题" class="headerlink" title="UI框架 方便解决的问题"></a>UI框架 方便解决的问题</h2><ul>
<li>游戏UI中出现多个窗口，窗口与窗口之间的模态关系<ul>
<li>当出现多个窗口，上面的窗口是当前只能操作的窗口</li>
<li>下面的窗口是模态的，看不清的，也是不能操作的</li>
</ul>
</li>
<li>经常需要找对象，找组件，找组件里的方法或属性【重复性非常高的体力活】<ul>
<li>通过对所有模块对象的统一管理</li>
<li>组件的统一设置</li>
<li>事件的统一调配</li>
</ul>
</li>
<li>本地化语言问题【中文/英文】</li>
<li>消息机制</li>
</ul>
<h2 id="管理UI窗口与模态处理"><a href="#管理UI窗口与模态处理" class="headerlink" title="管理UI窗口与模态处理"></a>管理UI窗口与模态处理</h2><h3 id="通过一个名字返回该名字所对应的窗口的预设体"><a href="#通过一个名字返回该名字所对应的窗口的预设体" class="headerlink" title="通过一个名字返回该名字所对应的窗口的预设体"></a>通过一个名字返回该名字所对应的窗口的预设体</h3><ul>
<li>定义：什么是窗口？<ul>
<li>开发者自定义，可以是一个Panel管理或者是一个空对象管理</li>
<li>游戏的外观模式<ul>
<li>游戏开始时，创建中只有几个基础的游戏对象</li>
<li>所有的内容，都是外观模式作为入口动态生成的</li>
</ul>
</li>
</ul>
</li>
<li>窗口的动态生成<ul>
<li>所有窗口都是一个资源【预设体】<ul>
<li>如何加载资源<ul>
<li>Resource.Load();【本地】</li>
<li>AssetsBundle()【服务器】</li>
</ul>
</li>
<li>所有资源都放在Resource文件夹下<ul>
<li>资源缓存机制<ul>
<li>第一次从Resource文件夹中加载资源</li>
<li>从第二次开始，从缓存中加载资源</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>关于所有资源的路径配置<ul>
<li>不同的窗口，资源的路径时不一样的</li>
<li>就需要一个配置文件去统一管理所有窗口的资源路径<ul>
<li>配置文件选择 XML/JSON</li>
</ul>
</li>
</ul>
</li>
<li>Json也是一个文件，也需要加载<ul>
<li>配置文件的路径—&gt;可以使用系统常数类来管理</li>
<li>Resource加载的类型【TextAssets】</li>
</ul>
</li>
<li>通过单例模板，建立资源管理单例</li>
<li>Json文件的解析<ul>
<li>LitJson/UnityJson库</li>
<li>解析后存储到内存</li>
</ul>
</li>
<li>最终目的–&gt;对外接口，通过一个名字返回该名字所对应的窗口的预设体</li>
</ul>
<h3 id="实现UI的模态处理"><a href="#实现UI的模态处理" class="headerlink" title="实现UI的模态处理"></a>实现UI的模态处理</h3><ul>
<li>所有UI模块都有统一的基类组件:UIModuleBase,依赖于Canvas Group</li>
<li>非当前模块不能进行UI操作<ul>
<li>Canvas Group组件<ul>
<li>Blocks Raycasts<ul>
<li>True： 检测射线，从而触发事件，可以操作UI</li>
<li>False：不检测射线，不能触发事件，不可以操作UI</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="实现UI模块的状态管理"><a href="#实现UI模块的状态管理" class="headerlink" title="实现UI模块的状态管理"></a>实现UI模块的状态管理</h3><ul>
<li><p>OnEnter进入状态 Canvas Group Blocks Ratcasts = true;</p>
</li>
<li><p>OnParse暂停状态 Canvas Group Blocks Ratcasts = false;</p>
</li>
<li><p>OnResume恢复状态 Canvas Group Blocks Ratcasts = true;</p>
</li>
<li><p>OnExit离开状态 Canvas Group Blocks Ratcasts = false;</p>
</li>
</ul>
<h3 id="整体UI模块栈管理"><a href="#整体UI模块栈管理" class="headerlink" title="整体UI模块栈管理"></a>整体UI模块栈管理</h3><p><code>Stack&lt;UIModuleBase&gt;</code></p>
<ul>
<li><p>PushUI(string panelName)</p>
</li>
<li><p>PopUI()</p>
</li>
</ul>
<h2 id="对模块中需要访问的对象，组件，组件的属性-方法进行封装"><a href="#对模块中需要访问的对象，组件，组件的属性-方法进行封装" class="headerlink" title="对模块中需要访问的对象，组件，组件的属性/方法进行封装"></a>对模块中需要访问的对象，组件，组件的属性/方法进行封装</h2><ul>
<li><p>通过UIManager管理所有模块<code>Module</code>以及模块中的元件<code>Widget</code></p>
</li>
<li><p>UIManger通过模块名称找到相应名称找到相应的模块</p>
</li>
<li><p>模块可以通过元件的名称找到相应的元件</p>
</li>
<li><p>管理示例</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>MainModule</th>
<th>TaskModule</th>
<th>SystemModule</th>
</tr>
</thead>
<tbody>
<tr>
<td>TaskButton_F</td>
<td>GetRewardButton_F</td>
<td>ShutDownVoiceButton_F</td>
</tr>
<tr>
<td>SystemButton_F</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>所有可操作元件上自动添加脚本组件<code>UIWidgetBase</code></p>
</li>
<li><p>这样的管理结构为：<code>Dictionary&lt;string,Dictionary&lt;string,UIWidgetBase&gt;&gt;</code></p>
</li>
<li><p>每个模块去遍历所有有用的子对象【元件】</p>
<ul>
<li>给每个元件添加脚本组件<code>UIWidgetBase</code></li>
<li>每个元件生成后，会自动注册到UIManager</li>
</ul>
</li>
<li><p>这样，就可以通过UIManager找到任意一个已经生成了的模块元件</p>
</li>
<li><p>每个UIWidget都可以实现UI的所有功能</p>
<ul>
<li>创建各个组件的接口<ul>
<li>IText，IImage，IButton…</li>
</ul>
</li>
</ul>
</li>
<li><p>拿到任意一个UIWidget都可以使用里面封装好的方法</p>
</li>
<li><p>最终每个UIModule对应一个控制器，基类<code>UIControllerBase</code></p>
<ul>
<li>每个控制器处理当前模块的业务逻辑【真正的框架使用】</li>
</ul>
</li>
</ul>
<h2 id="本地化语言"><a href="#本地化语言" class="headerlink" title="本地化语言"></a>本地化语言</h2><p><img src="/Unity/Frame/UIFrame/UIFrame2.png" alt="LocLanguage"></p>
<ul>
<li><p>语言管理类<code>LocalizationManager</code></p>
<ul>
<li>简体中文，繁体中文，英文，日文，法文…</li>
<li>添加委托注册和取消委托注册方法的接口</li>
<li>更换语言方法<code>ChangeLanguage</code>，根据设置的语言，调用所有注册的SetText方法<ul>
<li>设置生成后，将语言ID存储在本地，持久存在</li>
</ul>
</li>
</ul>
</li>
<li><p>给支持本地化的Text，绑定组件<code>LocalizationText</code></p>
<ul>
<li>需要做多语言的Text都添加该脚本组件</li>
</ul>
</li>
</ul>
<ol>
<li>从Json配置文件中读取该文件的多语言内容string[]</li>
<li>在LocalizationManager中注册自己的SetText(语言ID)方法</li>
</ol>
<h2 id="具体细则"><a href="#具体细则" class="headerlink" title="具体细则"></a>具体细则</h2><p>Scripts</p>
<ul>
<li>Facade<ul>
<li>GameFacade.cs</li>
</ul>
</li>
<li>UIFrame<ul>
<li>Managers<ul>
<li>UIManager.cs<blockquote>
<p>建立管理UIModule和Widget的字典和管理Module的栈<br>Module GameObject:输入UIType使panel模块实例化在canvas中且返回模块<br>Module Stack:建立栈存储Module 且执行出栈入栈时的操作 UIPanelName-&gt;UIType-&gt;Module 提供公共的函数供外界使用<br>widget相关操作：<br>UI Widgets-&gt;Module (Un)Register:向字典中添加modules(第一个string)<br>UI Widgets Add/Remove:添加或删除widgets<br>Find Widget:找module中的widgets</p>
</blockquote>
</li>
<li>UITypeManager.cs panelName获得UIType</li>
</ul>
</li>
<li>Models<ul>
<li>JsonLocalizationModel.cs 把json的文本转换成class的loc模型</li>
<li>JsonPanelsModel.cs 把json的文本转换成class的panel模型</li>
<li>UIType.cs 储存panel数据的一个class 输入路径返回class 单个panel的模型</li>
</ul>
</li>
<li>UIBases<ul>
<li>UIControllerBase.cs 写模块中组件的逻辑的基类</li>
<li>UIModuleBase.cs 实现panel模块的基类</li>
<li>UIWidgetBase.cs 实现添加移除模块中组件的基类</li>
</ul>
</li>
<li>UIInterface<ul>
<li>…各种组件的接口 定义要实现的功能</li>
<li>UIMono.cs 综合上诉接口实现功能的函数</li>
</ul>
</li>
<li>Utility<ul>
<li>AssetsManager.cs 输入路径返回物体 加载文件</li>
<li>JsonDataManager.cs 解析json 先变为model再变为字典存储</li>
<li>Singleton.cs 单例基类 子类私有构造</li>
<li>SystemDefine.cs 常数类</li>
</ul>
</li>
</ul>
</li>
<li>UserLogic用于实现需求的<ul>
<li>UIControllers绑定不同panel上要实现的功能<ul>
<li>MainPanelController.cs</li>
<li>…</li>
</ul>
</li>
<li>UIModules挂载在每个Penel的prefab上 实现进出动画等<ul>
<li>MainPanelModule.cs</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
<li>Localization<ul>
<li>LocalizationManager.cs</li>
<li>LocalizationText.cs</li>
</ul>
</li>
</ul>
<p>UI动画 Dotween插件</p>
<p>用字典实现缓存池 TryGetValue函数 减少重复导入</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Frame</category>
      </categories>
  </entry>
  <entry>
    <title>初识</title>
    <url>/Unity/UnityFundamental/Base/</url>
    <content><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p><img src="/Unity/UnityFundamental/Base/UnityRount.png" alt="UnityRoute"></p>
<p><img src="/Unity/UnityFundamental/Base/Base_01.png" alt="01"></p>
<p><img src="/Unity/UnityFundamental/Base/Base_02.png" alt="02"></p>
<h2 id="跟随目标转动"><a href="#跟随目标转动" class="headerlink" title="跟随目标转动"></a>跟随目标转动</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Vector3 vec = (target.position - transform.position);</span><br><span class="line">Quaternion rotate = Quaternion.LookRotation(vec);</span><br><span class="line">transform.localRotation = Quaternion.Slerp(transform.localRotation, rotate, angleSpeed);</span><br></pre></td></tr></table></figure>
<h2 id="每隔一段时间调用"><a href="#每隔一段时间调用" class="headerlink" title="每隔一段时间调用"></a>每隔一段时间调用</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1  协程</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Func</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">2.0f</span></span>)</span>;</span><br><span class="line">            <span class="comment">//Specific functions put here </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2  计算时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> passedTime; </span><br><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> targetTime; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Repete</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(passedTime&gt;targetTime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// function</span></span><br><span class="line">            passedTime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        passedTime += Time.deltaTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3  </span></span><br><span class="line">InvokeRepeating(<span class="string">&quot;functionName&quot;</span>, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//放在start或awake中 不能放update中 0为前摇 3为时间间隔</span></span><br><span class="line">CancelInvoke(<span class="string">&quot;functionName&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Lerp-和-SLerp"><a href="#Lerp-和-SLerp" class="headerlink" title="Lerp 和 SLerp"></a>Lerp 和 SLerp</h2><p>用于可控制时间的缓慢旋转 transform.Rotation = Quaterntion.Lerp()<br>线性插值 球形插值<br>从四元数的角度来看，线性插值每帧得出的旋转结果是不均匀的，这个比Slerp更快但是如果旋转较远看起来就比较差。因此球形插值更为合理，它不改变长度  </p>
<h2 id="通过标签来查找"><a href="#通过标签来查找" class="headerlink" title="通过标签来查找"></a>通过标签来查找</h2><p>  GameObject.FindWithTag( 标签名 )如果场景中存在指定标签的游戏对象，那么返回该对象的引用，否则返回null；<br>  如果多个游戏对象使用同一标签，那么返回第一个游戏对象的引用（这里的第一个，指的是最后一个添加的游戏对象）。<br>  如果场景中有多个相同标签的游戏对象，可以通过FindGameobjectWithTag()方法获取游戏对象数组。</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>协程</title>
    <url>/Unity/UnityFundamental/Coroutine/</url>
    <content><![CDATA[<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><span id="more"></span>
<p><img src="/Unity/UnityFundamental/Coroutine/coroutine.png" alt="coroutine"></p>
<p>每隔一段时间实现一个功能时使用</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>特效系统</title>
    <url>/Unity/UnityFundamental/Effects/</url>
    <content><![CDATA[<h1 id="特效系统"><a href="#特效系统" class="headerlink" title="特效系统"></a>特效系统</h1><span id="more"></span>
<p><img src="/Unity/UnityFundamental/Effects/effects.png" alt="effects"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>导航系统</title>
    <url>/Unity/UnityFundamental/Navigation/</url>
    <content><![CDATA[<h1 id="导航系统"><a href="#导航系统" class="headerlink" title="导航系统"></a>导航系统</h1><span id="more"></span>
<p><img src="/Unity/UnityFundamental/Navigation/nav.png" alt="nav"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>物理系统</title>
    <url>/Unity/UnityFundamental/Physics/</url>
    <content><![CDATA[<h1 id="物理系统"><a href="#物理系统" class="headerlink" title="物理系统"></a>物理系统</h1><span id="more"></span>
<p><img src="/Unity/UnityFundamental/Physics/physics.png" alt="physics"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>UGUI</title>
    <url>/Unity/UnityFundamental/UGUI/</url>
    <content><![CDATA[<h1 id="UGUI"><a href="#UGUI" class="headerlink" title="UGUI"></a>UGUI</h1><span id="more"></span>
<p><img src="/Unity/UnityFundamental/UGUI/ugui_01.png" alt="ugui01"><br><img src="/Unity/UnityFundamental/UGUI/ugui_02.png" alt="ugui02"><br><img src="/Unity/UnityFundamental/UGUI/ugui_03.png" alt="ugui03"></p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
  <entry>
    <title>WWW</title>
    <url>/Unity/UnityFundamental/WWW/</url>
    <content><![CDATA[<h1 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h1><span id="more"></span>
<p>在WWW上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫URL（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址。</p>
<p>等待WWW下载完毕<code>yield return www</code></p>
<p>对于视频等长时间下载:<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!www.isDone)&#123;</span><br><span class="line">    <span class="comment">//打印进度</span></span><br><span class="line">    Debug.Log(<span class="string">&quot;进度: &quot;</span> + www.progress);</span><br><span class="line">    <span class="comment">//等待</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/Unity/UnityFundamental/WWW/www.png" alt="www"></p>
<p>新方法:WebRequest</p>
]]></content>
      <categories>
        <category>Unity</category>
        <category>Fundamental</category>
      </categories>
  </entry>
</search>
